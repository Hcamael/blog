title: 16位汇编学习小记
date: 2015-08-23 17:14:07
---
![汇编](/img/assem.jpg)
<!--more-->

最近开始学习汇编了, 记录一些我记不住的知识点. and 想到啥写啥...

>* *x -> 通用寄存器   eg: ax, bx ,cx ....
>* mov ax, bx     可以想象成是寄存器的赋值指令 -> ax = bx 
>* add ax, bx      可以想象成是  ->   ax += bx     对应的有  sub ax, bx   ->   ax -= bx
>* SS:SP  指向的地址是栈顶地址, push ax   把ax推入栈中, ppo ax  把栈中元素赋值给ax...  具体原理这里不做叙述..
>* CS:IP 指向的是下一句命令
>* [0] == DS:0   [BX]  ==  DS:BX   改方式称为寻址方式, 中括号里的只能是常量, bx, si, di, bp(si, di不能同时出现, bx, bp不能同时出现. ), bx 对应的段寄存器是bs, bp 对应的段寄存器是ss
>* 汇编中的循环:

    sss: 
        mov ax, bx
    loop sss

> 这里还涉及到一个寄存器CX, 一个汇编程序, CX初始为汇编源码的长度... loop 先cx -= 1 然后才是判断cx是否为0
>* debug 调试器的一些简单的命令... t 执行一个指令, g xxxx 执行到xxxx位置, 不指定xxxx则运行到结束, p 一步执行完循环, a 写汇编, d 查看二进制, r 查看寄存器, u 查看汇编代码, e 写二进制, q 退出
> * 汇编里也有and 和 or 运算....其实跟编程语言里一样...:

    and ax, 01011100B     # 相当与  ax and 01011100B
    or ax, 00011001B    #同理,  相当与 ax or 00011001B
    
> * word ptr 和 byte ptr 指定内存单元长度, 是字单元还是字节单元.
> * db/dw/dd 重复次数 dup (重复的数据)
> * div 是除法...有点复杂..直接理解记忆了.懒得再写出来了...
> * offset 标号  .... 取得段内标号的地址...
> * jmp short 标号  -> 段内短转移 -128-127  为啥? 很简单... 2**8
> * jmp near ptr 标号  -> 段内近转移  2**16  正负各半...用不到那么多位的时候会有Nop占位.. 
> * jmp far ptr 标号 -> 段间转移   还有 jmp word/dword(两个字) ptr 内存单元
> * 终于学到判断了... jcxz 标号(如果 cx == 0 则跳转到标号处执行.)
> * inc xxx 自增1   dec xxx 自减1
