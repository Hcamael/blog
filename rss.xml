<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Hc1m1</title>
    <link>//0x48.pw/</link>
    <atom:link href="/rss.xml" rel="self" type="application/rss+xml"/>
    
    <description>水平不济整日被虐这也不会那也得学脑子太蠢天天垫底这看不懂那学不会</description>
    <pubDate>Thu, 12 Jul 2018 09:03:51 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>以太坊智能合约OPCODE逆向之理论基础篇</title>
      <link>//0x48.pw/2018/07/09/0x45/</link>
      <guid>//0x48.pw/2018/07/09/0x45/</guid>
      <pubDate>Mon, 09 Jul 2018 03:52:45 GMT</pubDate>
      <description>
      
        &lt;p&gt;在我们对etherscan等平台上合约进行安全审查时，常常会遇到没有公布Solidity源代码的合约，只能获取到合约的OPCODE，所以一个智能合约的反编译器对审计无源码的智能合约起到了非常重要的作用。&lt;/p&gt;
&lt;p&gt;目前在互联网上常见的反编译工具只有porosity&lt;a href=&quot;#jump1&quot;&gt;[1]&lt;/a&gt;，另外在Github上还找到另外的反编译工具ethdasm&lt;a href=&quot;#jump2&quot;&gt;[2]&lt;/a&gt;，经过测试发现这两个编译器都有许多bug，无法满足我的工作需求。因此我开始尝试研究并开发能满足我们自己需求的反编译工具，在我看来如果要写出一个优秀的反汇编工具，首先需要有较强的OPCODE逆向能力，本篇Paper将对以太坊智能合约OPCODE的数据结构进行一次深入分析。&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<p>在我们对etherscan等平台上合约进行安全审查时，常常会遇到没有公布Solidity源代码的合约，只能获取到合约的OPCODE，所以一个智能合约的反编译器对审计无源码的智能合约起到了非常重要的作用。</p>
<p>目前在互联网上常见的反编译工具只有porosity<a href="#jump1">[1]</a>，另外在Github上还找到另外的反编译工具ethdasm<a href="#jump2">[2]</a>，经过测试发现这两个编译器都有许多bug，无法满足我的工作需求。因此我开始尝试研究并开发能满足我们自己需求的反编译工具，在我看来如果要写出一个优秀的反汇编工具，首先需要有较强的OPCODE逆向能力，本篇Paper将对以太坊智能合约OPCODE的数据结构进行一次深入分析。</p>
<a id="more"></a>
<h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><p>智能合约的OPCODE是在EVM(Ethereum Virtual Machine)中进行解释执行，OPCODE为1字节，从<code>0x00 - 0xff</code>代表了相对应的指令，但实际有用的指令并没有0xff个，还有一部分未被使用，以便将来的扩展</p>
<p>具体指令可参考Github<a href="#jump3">[3]</a>上的OPCODE指令集，每个指令具体含义可以参考相关文档<a href="#jump4">[4]</a></p>
<h2 id="IO"><a href="#IO" class="headerlink" title="IO"></a>IO</h2><p>在EVM中不存在寄存器，也没有网络IO相关的指令，只存在对栈(stack)，内存(mem), 存储(storage)的读写操作</p>
<ul>
<li>stack</li>
</ul>
<p>使用的push和pop对栈进行存取操作，push后面会带上存入栈数据的长度，最小为1字节，最大为32字节，所以OPCODE从<code>0x60-0x7f</code>分别代表的是<code>push1-push32</code></p>
<p><code>PUSH1</code>会将OPCODE后面1字节的数据放入栈中，比如字节码是<code>0x6060</code>代表的指令就是<code>PUSH1 0x60</code></p>
<p>除了<code>PUSH</code>指令，其他指令获取参数都是从栈中获取，指令返回的结果也是直接存入栈中</p>
<ul>
<li>mem</li>
</ul>
<p>内存的存取操作是<code>MSTORE</code>和<code>MLOAD</code></p>
<p><code>MSTORE(arg0, arg1)</code>从栈中获取两个参数，表示<code>MEM[arg0:arg0+32] = arg1</code></p>
<p><code>MLOAD(arg0)</code>从栈中获取一个参数，表示<code>PUSH32(MEM[arg0:arg0+32])</code></p>
<p>因为<code>PUSH</code>指令，最大只能把32字节的数据存入栈中，所以对内存的操作每次只能操作32字节</p>
<p>但是还有一个指令<code>MSTORE8</code>，只修改内存的1个字节</p>
<p><code>MSTORE(arg0, arg1)</code>从栈中获取两个参数，表示<code>MEM[arg0] = arg1</code></p>
<p>内存的作用一般是用来存储返回值，或者某些指令有处理大于32字节数据的需求</p>
<p>比如: <code>SHA3(arg0, arg1)</code>从栈中获取两个参数，表示<code>SHA3(MEM[arg0:arg0+arg1])</code>，SHA3对内存中的数据进行计算sha3哈希值，参数只是用来指定内存的范围</p>
<ul>
<li>storage</li>
</ul>
<p>上面的stack和mem都是在EVM执行OPCODE的时候初始化，但是storage是存在于区块链中，我们可以类比为计算机的存储磁盘。</p>
<p>所以，就算不执行智能合约，我们也能获取智能合约storage中的数据:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">eth.getStorageAt(合约地址, slot)   </div><div class="line"># 该函数还有第三个参数，默认为&quot;latest&quot;，还可以设置为&quot;earliest&quot;或者&quot;pending&quot;，具体作用本文不做分析</div></pre></td></tr></table></figure>
<p>storage用来存储智能合约中所有的全局变量</p>
<p>使用<code>SLOAD</code>和<code>SSTORE</code>进行操作</p>
<p><code>SSTORE(arg0, arg1)</code>从栈中获取两个参数，表示<code>eth.getStorageAt(合约地址, arg0) = arg1</code></p>
<p><code>SLOAD(arg0)</code>从栈中获取一个参数，表示<code>PUSH32(eth.getStorageAt(合约地址, arg0))</code></p>
<h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><p>智能合约的变量从作用域可以分为三种, 全局公有变量(public), 全局私有变量(private), 局部变量</p>
<p>全局变量和局部变量的区别是，全局变量储存在storage中，而局部变量是被编译进OPCODE中，在运行时，被放在stack中，等待后续使用</p>
<p>公有变量和私有变量的区别是，公有变量会被编译成一个constant函数，后面会分析函数之前的区别</p>
<p>因为私有变量也是储存在storage中，而storage是存在于区块链当中，所以相当于私有变量也是公开的，所以不要想着用私有变量来储存啥不能公开的数据。</p>
<h3 id="全局变量的储存模型"><a href="#全局变量的储存模型" class="headerlink" title="全局变量的储存模型"></a>全局变量的储存模型</h3><p>不同类型的变量在storage中储存的方式也是有区别的，下面对各种类型的变量的储存模型进行分析</p>
<ol>
<li>定长变量</li>
</ol>
<p>第一种我们归类为定长变量，所谓的定长变量，也就是该变量在定义的时候，其长度就已经被限制住了</p>
<p>比如定长整型(int/uint……), 地址(address), 定长浮点型(fixed/ufixed……), 定长字节数组(bytes1-32)</p>
<p>这类的变量在storage中都是按顺序储存</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">uint a;       // slot = 0</div><div class="line">address b;    // 1</div><div class="line">ufixed c;     // 2</div><div class="line">bytes32 d;    // 3</div><div class="line">## </div><div class="line">a == eth.getStorageAt(contract, 0)</div><div class="line">d == eth.getStorageAt(contract, 3)</div></pre></td></tr></table></figure>
<p>上面举的例子，除了<code>address</code>的长度是160bits，其他变量的长度都是256bits，而storage是256bits对齐的，所以都是一个变量占着一块storage，但是会存在连续两个变量的长度不足256bits的情况</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">address a;      // slot = 0</div><div class="line">uint8 b;        // 0</div><div class="line">address c;      // 1</div><div class="line">uint16 d;       // 1</div></pre></td></tr></table></figure>
<p>在opcode层面，获取a的值得操作是: <code>SLOAD(0) &amp; 0xffffffffffffffffffffffffffffffffffffffff</code></p>
<p>获取b值得操作是: <code>SLOAD(0) // 0x10000000000000000000000000000000000000000 &amp; 0xff</code></p>
<p>获取d值得操作是: <code>SLOAD(1) // 0x10000000000000000000000000000000000000000 &amp; 0xffff</code></p>
<p>因为b的长度+a的长度不足256bits，变量a和b是连续的，所以他们在同一块storage中，然后在编译的过程中进行区分变量a和变量b，但是后续在加上变量c，长度就超过了256bits，因此把变量c放到下一块storage中，然后变量d跟在c之后</p>
<p>从上面我们可以看出，storage的储存策略一个是256bits对齐，一个是顺序储存。(并没有考虑到充分利用每一字节的储存空间，我觉得可以考虑把d变量放到b变量之后)</p>
<ol>
<li>映射变量</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">mapping(address =&gt; uint) a;</div></pre></td></tr></table></figure>
<p>映射变量就没办法想上面的定长变量按顺序储存了，因为这是一个键值对变量，EVM采用的机制是: </p>
<p><code>SLOAD(sha3(key.rjust(64, &quot;0&quot;)+slot.rjust(64, &quot;0&quot;)))</code></p>
<p>比如: <code>a[&quot;0xd25ed029c093e56bc8911a07c46545000cbf37c6&quot;]</code>首先计算sha3哈希值:</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> sha3 <span class="keyword">import</span> keccak_256</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>data = <span class="string">"d25ed029c093e56bc8911a07c46545000cbf37c6"</span>.rjust(<span class="number">64</span>, <span class="string">"0"</span>)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>data += <span class="string">"00"</span>.rjust(<span class="number">64</span>, <span class="string">"0"</span>)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>keccak_256(data.encode()).hexdigest()</div><div class="line"><span class="string">'739cc24910ff41b372fbcb2294933bdc3108bd86ffd915d64d569c68a85121ec'</span></div><div class="line"><span class="comment"># </span></div><div class="line">a[<span class="string">"0xd25ed029c093e56bc8911a07c46545000cbf37c6"</span>] == SLOAD(<span class="string">"739cc24910ff41b372fbcb2294933bdc3108bd86ffd915d64d569c68a85121ec"</span>)</div></pre></td></tr></table></figure>
<p>我们也可以使用以太坊客户端直接获取: </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&gt; eth.getStorageAt(合约地址, &quot;739cc24910ff41b372fbcb2294933bdc3108bd86ffd915d64d569c68a85121ec&quot;)</div></pre></td></tr></table></figure>
<p>还有slot需要注意一下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">address public a;                       // slot = 0</div><div class="line">mapping(address =&gt; uint) public b;      // slot = 1</div><div class="line">uint public d;                          // slot = 1</div><div class="line">mapping(address =&gt; uint) public c;      // slot = 3</div></pre></td></tr></table></figure>
<p>根据映射变量的储存模型，或许我们真的可以在智能合约中隐藏私密信息，比如，有一个secret，只有知道key的人才能知道secret的内容，我们可以<code>b[key] = secret</code>, 虽然数据仍然是储存在storage中，但是在不知道key的情况下却无法获取到<code>secret</code>。</p>
<p>不过，storage是存在于区块链之中，目前我猜测是通过智能合约可以映射到对应的storage，storage不可能会初始化256*256bits的内存空间，那样就太消耗硬盘空间了，所以可以通过解析区块链文件，获取到storage全部的数据。</p>
<p>上面这些仅仅是个人猜想，会作为之后研究以太坊源码的一个研究方向。</p>
<ul>
<li>7/12更新: 区块的每个交易都是公开透明的，所以key也是公开透明的，不存在不知道key的情况</li>
</ul>
<ol>
<li>变长变量</li>
</ol>
<p>变长变量也就是数组，长度不一定，其储存方式有点像上面两种的结合</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">uint a;         // slot = 0</div><div class="line">uint[] b;       // 1</div><div class="line">uint c;         // 2</div></pre></td></tr></table></figure>
<p>数组任然会占用对应slot的storage，储存数组的长度(<code>b.length == SLOAD(1)</code>)</p>
<p>比如我们想获取<code>b[1]</code>的值，会把输入的<code>index</code>和<code>SLOAD(1)</code>的值进行比较，防止数组越界访问</p>
<p>然后计算slot的sha3哈希值: </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; from sha3 import keccak_256</div><div class="line">&gt;&gt;&gt; slot = &quot;01&quot;.rjust(64, &quot;0&quot;)</div><div class="line">&gt;&gt;&gt; keccak_256(slot.encode()).hexdigest()</div><div class="line">&apos;20ec45d096f1fa2aeff1e3da8a84697d90109524958ed4be9f6d69e37a9140a4&apos;</div><div class="line"></div><div class="line">#</div><div class="line">b[X] == SLOAD(&apos;20ec45d096f1fa2aeff1e3da8a84697d90109524958ed4be9f6d69e37a9140a4&apos; + X)</div><div class="line"></div><div class="line"># 获取b[2]的值</div><div class="line">&gt; eth.getStorageAt(合约地址, &quot;20ec45d096f1fa2aeff1e3da8a84697d90109524958ed4be9f6d69e37a9140a6&quot;)</div></pre></td></tr></table></figure>
<p>在变长变量中有两个特例: <code>string</code>和<code>bytes</code></p>
<p>字符串可以认为是字符数组，bytes是byte数组，当这两种变量的长度在<code>0-31</code>时，值储存在对应slot的storage上，最后一字节为<code>长度*2|flag</code>, 当flag = 1，表示长度&gt;31，否则长度&lt;=31</p>
<p>下面进行举例说明</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">uint i;                // slot = 0</div><div class="line">string a = &quot;c&quot;*31;     // 1</div><div class="line">SLOAD(1) == &quot;c*31&quot; + &quot;00&quot; | 31*2 == &quot;636363636363636363636363636363636363636363636363636363636363633e&quot;</div></pre></td></tr></table></figure>
<p>当变量的长度大于31时，<code>SLOAD(slot)</code>储存<code>length*2|flag</code>，把值储存到<code>sha3(slot)</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">uint i;                // slot = 0</div><div class="line">string a = &quot;c&quot;*36;     // 1</div><div class="line">SLOAD(1) == 36*2|1 == 0x49</div><div class="line">SLOAD(SHA3(&quot;01&quot;.rjust(64, &quot;0&quot;))) == &quot;c&quot;*36</div></pre></td></tr></table></figure>
<ol>
<li>结构体</li>
</ol>
<p>结构体没有单独特殊的储存模型，结构体相当于变量数组，下面进行举例说明:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">struct test &#123;</div><div class="line">    uint a;</div><div class="line">    uint b;</div><div class="line">    uint c;</div><div class="line">&#125;</div><div class="line">address g;</div><div class="line">Test e;</div><div class="line"></div><div class="line"># 上面变量在storage的储存方式等同于</div><div class="line">address g;</div><div class="line">uint a;</div><div class="line">uint b;</div><div class="line">uint c;</div></pre></td></tr></table></figure>
<h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><h3 id="两种调用函数的方式"><a href="#两种调用函数的方式" class="headerlink" title="两种调用函数的方式"></a>两种调用函数的方式</h3><p>下面是针对两种函数调用方式说明的测试代码，发布在测试网络上: <a href="https://ropsten.etherscan.io/address/0xc9fbe313dc1d6a1c542edca21d1104c338676ffd#code" target="_blank" rel="external">https://ropsten.etherscan.io/address/0xc9fbe313dc1d6a1c542edca21d1104c338676ffd#code</a> </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">pragma solidity ^0.4.18;</div><div class="line"></div><div class="line">contract Test &#123;</div><div class="line"></div><div class="line">  address public owner;</div><div class="line">  uint public prize;</div><div class="line"></div><div class="line">  function Test() &#123;</div><div class="line">    owner = msg.sender;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  function test1() constant public returns (address) &#123;</div><div class="line">    return owner;</div><div class="line">  &#125;</div><div class="line">  </div><div class="line">  function test2(uint p) public &#123;</div><div class="line">      prize += p;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>整个OPCODE都是在EVM中执行，所以第一个调用函数的方式就是使用EVM进行执行OPCODE:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"># 调用test1</div><div class="line">&gt; eth.call(&#123;to: &quot;0xc9fbe313dc1d6a1c542edca21d1104c338676ffd&quot;, data: &quot;0x6b59084d&quot;&#125;)</div><div class="line">&quot;0x0000000000000000000000000109dea8b64d87a26e7fe9af6400375099c78fdd&quot;</div><div class="line">&gt; eth.getStorageAt(&quot;0xc9fbe313dc1d6a1c542edca21d1104c338676ffd&quot;, 0)</div><div class="line">&quot;0x0000000000000000000000000109dea8b64d87a26e7fe9af6400375099c78fdd&quot;</div></pre></td></tr></table></figure>
<p>第二种方式就是通过发送交易:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"># 调用test2</div><div class="line">&gt; eth.getStorageAt(&quot;0xc9fbe313dc1d6a1c542edca21d1104c338676ffd&quot;, 1)</div><div class="line">&quot;0x0000000000000000000000000000000000000000000000000000000000000005&quot;</div><div class="line">&gt; eth.sendTransaction(&#123;from: eth.accounts[0], to: &quot;0xc9fbe313dc1d6a1c542edca21d1104c338676ffd&quot;, data: &quot;0xcaf446830000000000000000000000000000000000000000000000000000000000000005&quot;&#125;)</div><div class="line">&gt; eth.getStorageAt(&quot;0xc9fbe313dc1d6a1c542edca21d1104c338676ffd&quot;, 1)</div><div class="line">&quot;0x000000000000000000000000000000000000000000000000000000000000000a&quot;</div></pre></td></tr></table></figure>
<p>这两种调用方式的区别有两个:</p>
<ol>
<li>使用call调用函数是在本地使用EVM执行合约的OPCODE，所以可以获得返回值</li>
<li>通过交易调用的函数，能修改区块链上的storage</li>
</ol>
<p>一个调用合约函数的交易(比如<br><code>https://ropsten.etherscan.io/tx/0xab1040ff9b04f8fc13b12057f9c090e0a9348b7d3e7b4bb09523819e575cf651</code>)的信息中，是不存在返回值的信息，但是却可以修改storage的信息(一个交易是怎么修改对应的storage信息，是之后的一个研究方向)</p>
<p>而通过call调用，是在本地使用EVM执行OPCODE，返回值是存在MEM中return，所以可以获取到返回值，虽然也可以修改storage的数据，不过只是修改你本地数据，不通过发起交易，其他节点将不会接受你的更改，所以是一个无效的修改，同时，本地调用函数也不需要消耗gas，所以上面举例中，在调用信息的字典里，不需要<code>from</code>字段，而交易却需要指定(设置<code>from</code>)从哪个账号消耗gas。</p>
<h3 id="调用函数"><a href="#调用函数" class="headerlink" title="调用函数"></a>调用函数</h3><p>EVM是怎么判断调用哪个函数的呢？下面使用OPCODE来进行说明</p>
<p>每一个智能合约入口代码是有固定模式的，我们可以称为智能合约的主函数，上面测试合约的主函数如下:</p>
<p>PS: Github<a href="#jump5">[5]</a>上面有一个EVM反汇编的IDA插件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line">[     0x0] | PUSH1                | [&apos;0x80&apos;]</div><div class="line">[     0x2] | PUSH1                | [&apos;0x40&apos;]</div><div class="line">[     0x4] | MSTORE               | None</div><div class="line">[     0x5] | PUSH1                | [&apos;0x4&apos;]</div><div class="line">[     0x7] | CALLDATASIZE         | None</div><div class="line">[     0x8] | LT                   | None</div><div class="line">[     0x9] | PUSH2                | [&apos;0x61&apos;]</div><div class="line">[     0xc] | JUMPI                | None</div><div class="line">[     0xd] | PUSH4                | [&apos;0xffffffff&apos;]</div><div class="line">[    0x12] | PUSH29               | [&apos;0x100000000000000000000000000000000000000000000000000000000&apos;]</div><div class="line">[    0x30] | PUSH1                | [&apos;0x0&apos;]</div><div class="line">[    0x32] | CALLDATALOAD         | None</div><div class="line">[    0x33] | DIV                  | None</div><div class="line">[    0x34] | AND                  | None</div><div class="line">[    0x35] | PUSH4                | [&apos;0x6b59084d&apos;]</div><div class="line">[    0x3a] | DUP2                 | None</div><div class="line">[    0x3b] | EQ                   | None</div><div class="line">[    0x3c] | PUSH2                | [&apos;0x66&apos;]</div><div class="line">[    0x3f] | JUMPI                | None</div><div class="line">[    0x40] | DUP1                 | None</div><div class="line">[    0x41] | PUSH4                | [&apos;0x8da5cb5b&apos;]</div><div class="line">[    0x46] | EQ                   | None</div><div class="line">[    0x47] | PUSH2                | [&apos;0xa4&apos;]</div><div class="line">[    0x4a] | JUMPI                | None</div><div class="line">[    0x4b] | DUP1                 | None</div><div class="line">[    0x4c] | PUSH4                | [&apos;0xcaf44683&apos;]</div><div class="line">[    0x51] | EQ                   | None</div><div class="line">[    0x52] | PUSH2                | [&apos;0xb9&apos;]</div><div class="line">[    0x55] | JUMPI                | None</div><div class="line">[    0x56] | DUP1                 | None</div><div class="line">[    0x57] | PUSH4                | [&apos;0xe3ac5d26&apos;]</div><div class="line">[    0x5c] | EQ                   | None</div><div class="line">[    0x5d] | PUSH2                | [&apos;0xd3&apos;]</div><div class="line">[    0x60] | JUMPI                | None</div><div class="line">[    0x61] | JUMPDEST             | None</div><div class="line">[    0x62] | PUSH1                | [&apos;0x0&apos;]</div><div class="line">[    0x64] | DUP1                 | None</div><div class="line">[    0x65] | REVERT               | None</div></pre></td></tr></table></figure>
<p>反编译出来的代码就是:</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></div><div class="line">    <span class="keyword">if</span> CALLDATASIZE &gt;= <span class="number">4</span>:</div><div class="line">        data = CALLDATA[:<span class="number">4</span>]</div><div class="line">        <span class="keyword">if</span> data == <span class="number">0x6b59084d</span>:</div><div class="line">            test1()</div><div class="line">        <span class="keyword">elif</span> data == <span class="number">0x8da5cb5b</span>:</div><div class="line">            owner()</div><div class="line">        <span class="keyword">elif</span> data == <span class="number">0xcaf44683</span>:</div><div class="line">            test2()</div><div class="line">        <span class="keyword">elif</span> data == <span class="number">0xe3ac5d26</span>:</div><div class="line">            prize()</div><div class="line">        <span class="keyword">else</span>:</div><div class="line">            <span class="keyword">pass</span></div><div class="line">    <span class="keyword">raise</span></div></pre></td></tr></table></figure>
<p>PS：因为个人习惯问题，反编译最终输出没有选择对应的Solidity代码，而是使用Python。</p>
<p>从上面的代码我们就能看出来，EVM是根据<code>CALLDATA</code>的前4字节来确定调用的函数的，这4个字节表示的是函数的sha3哈希值的前4字节:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">&gt; web3.sha3(&quot;test1()&quot;)</div><div class="line">&quot;0x6b59084dfb7dcf1c687dd12ad5778be120c9121b21ef90a32ff73565a36c9cd3&quot;</div><div class="line">&gt; web3.sha3(&quot;owner()&quot;)</div><div class="line">&quot;0x8da5cb5b36e7f68c1d2e56001220cdbdd3ba2616072f718acfda4a06441a807d&quot;</div><div class="line">&gt; web3.sha3(&quot;prize()&quot;)</div><div class="line">&quot;0xe3ac5d2656091dd8f25e87b604175717f3442b1e2af8ecd1b1f708bab76d9a91&quot;</div><div class="line"># 如果该函数有参数，则需要加上各个参数的类型</div><div class="line">&gt; web3.sha3(&quot;test2(uint256)&quot;)</div><div class="line">&quot;0xcaf446833eef44593b83316414b79e98fec092b78e4c1287e6968774e0283444&quot;</div></pre></td></tr></table></figure>
<p>所以可以去网上找个哈希表映射<a href="#jump6">[6]</a>，这样有概率可以通过hash值，得到函数名和参数信息，减小逆向的难度</p>
<h3 id="主函数中的函数"><a href="#主函数中的函数" class="headerlink" title="主函数中的函数"></a>主函数中的函数</h3><p>上面给出的测试智能合约中只有两个函数，但是反编译出来的主函数中，却有4个函数调用，其中两个是公有函数，另两个是公有变量</p>
<p>智能合约变量/函数类型只有两种，公有和私有，公有和私有的区别很简单，公有的是能别外部调用访问，私有的只能被本身调用访问</p>
<p>对于变量，不管是公有还是私有都能通过<code>getStorageAt</code>访问，但是这是属于以太坊层面的，在智能合约层面，把公有变量给编译成了一个公有函数，在这公有函数中返回<code>SLOAD(slot)</code>，而私有函数只能在其他函数中特定的地方调用<code>SLOAD(slot)</code>来访问</p>
<p>在上面测试的智能合约中, <code>test1()</code>函数等同于<code>owner()</code>，我们可以来看看各自的OPCODE:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line">; test1()</div><div class="line">; 0x66: loc_66</div><div class="line">[    0x66] | JUMPDEST             | None</div><div class="line">[    0x67] | CALLVALUE            | None</div><div class="line">[    0x68] | DUP1                 | None</div><div class="line">[    0x69] | ISZERO               | None</div><div class="line">[    0x6a] | PUSH2                | [&apos;0x72&apos;]</div><div class="line">[    0x6d] | JUMPI                | None</div><div class="line">[    0x6e] | PUSH1                | [&apos;0x0&apos;]</div><div class="line">[    0x70] | DUP1                 | None</div><div class="line">[    0x71] | REVERT               | None</div><div class="line">; 0x72: loc_72</div><div class="line">[    0x72] | JUMPDEST             | None</div><div class="line">[    0x73] | POP                  | None</div><div class="line">[    0x74] | PUSH2                | [&apos;0x7b&apos;]</div><div class="line">[    0x77] | PUSH2                | [&apos;0xfa&apos;]</div><div class="line">[    0x7a] | JUMP                 | None</div><div class="line">; 0xFA: loc_fa</div><div class="line">[    0xfa] | JUMPDEST             | None</div><div class="line">[    0xfb] | PUSH1                | [&apos;0x0&apos;]</div><div class="line">[    0xfd] | SLOAD                | None</div><div class="line">[    0xfe] | PUSH20               | [&apos;0xffffffffffffffffffffffffffffffffffffffff&apos;]</div><div class="line">[   0x113] | AND                  | None</div><div class="line">[   0x114] | SWAP1                | None</div><div class="line">[   0x115] | JUMP                 | None</div><div class="line">; 0x7B: loc_7b</div><div class="line">[    0x7b] | JUMPDEST             | None</div><div class="line">[    0x7c] | PUSH1                | [&apos;0x40&apos;]</div><div class="line">[    0x7e] | DUP1                 | None</div><div class="line">[    0x7f] | MLOAD                | None</div><div class="line">[    0x80] | PUSH20               | [&apos;0xffffffffffffffffffffffffffffffffffffffff&apos;]</div><div class="line">[    0x95] | SWAP1                | None</div><div class="line">[    0x96] | SWAP3                | None</div><div class="line">[    0x97] | AND                  | None</div><div class="line">[    0x98] | DUP3                 | None</div><div class="line">[    0x99] | MSTORE               | None</div><div class="line">[    0x9a] | MLOAD                | None</div><div class="line">[    0x9b] | SWAP1                | None</div><div class="line">[    0x9c] | DUP2                 | None</div><div class="line">[    0x9d] | SWAP1                | None</div><div class="line">[    0x9e] | SUB                  | None</div><div class="line">[    0x9f] | PUSH1                | [&apos;0x20&apos;]</div><div class="line">[    0xa1] | ADD                  | None</div><div class="line">[    0xa2] | SWAP1                | None</div><div class="line">[    0xa3] | RETURN               | None</div></pre></td></tr></table></figure>
<p>和<code>owner()</code>函数进行对比:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line">; owner()</div><div class="line">; 0xA4: loc_a4</div><div class="line">[    0xa4] | JUMPDEST             | None</div><div class="line">[    0xa5] | CALLVALUE            | None</div><div class="line">[    0xa6] | DUP1                 | None</div><div class="line">[    0xa7] | ISZERO               | None</div><div class="line">[    0xa8] | PUSH2                | [&apos;0xb0&apos;]</div><div class="line">[    0xab] | JUMPI                | None</div><div class="line">[    0xac] | PUSH1                | [&apos;0x0&apos;]</div><div class="line">[    0xae] | DUP1                 | None</div><div class="line">[    0xaf] | REVERT               | None</div><div class="line">; 0xB0: loc_b0</div><div class="line">[    0xb0] | JUMPDEST             | None</div><div class="line">[    0xb1] | POP                  | None</div><div class="line">[    0xb2] | PUSH2                | [&apos;0x7b&apos;]</div><div class="line">[    0xb5] | PUSH2                | [&apos;0x116&apos;]</div><div class="line">[    0xb8] | JUMP                 | None</div><div class="line">; 0x116: loc_116</div><div class="line">[   0x116] | JUMPDEST             | None</div><div class="line">[   0x117] | PUSH1                | [&apos;0x0&apos;]</div><div class="line">[   0x119] | SLOAD                | None</div><div class="line">[   0x11a] | PUSH20               | [&apos;0xffffffffffffffffffffffffffffffffffffffff&apos;]</div><div class="line">[   0x12f] | AND                  | None</div><div class="line">[   0x130] | DUP2                 | None</div><div class="line">[   0x131] | JUMP                 | None</div><div class="line">; 0x7B: loc_7b</div><div class="line">[    0x7b] | JUMPDEST             | None</div><div class="line">[    0x7c] | PUSH1                | [&apos;0x40&apos;]</div><div class="line">[    0x7e] | DUP1                 | None</div><div class="line">[    0x7f] | MLOAD                | None</div><div class="line">[    0x80] | PUSH20               | [&apos;0xffffffffffffffffffffffffffffffffffffffff&apos;]</div><div class="line">[    0x95] | SWAP1                | None</div><div class="line">[    0x96] | SWAP3                | None</div><div class="line">[    0x97] | AND                  | None</div><div class="line">[    0x98] | DUP3                 | None</div><div class="line">[    0x99] | MSTORE               | None</div><div class="line">[    0x9a] | MLOAD                | None</div><div class="line">[    0x9b] | SWAP1                | None</div><div class="line">[    0x9c] | DUP2                 | None</div><div class="line">[    0x9d] | SWAP1                | None</div><div class="line">[    0x9e] | SUB                  | None</div><div class="line">[    0x9f] | PUSH1                | [&apos;0x20&apos;]</div><div class="line">[    0xa1] | ADD                  | None</div><div class="line">[    0xa2] | SWAP1                | None</div><div class="line">[    0xa3] | RETURN               | None</div></pre></td></tr></table></figure>
<p>所以我们可以得出结论:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">address public a;</div><div class="line">会被编译成(==)</div><div class="line">function a() public returns (address) &#123;</div><div class="line">    return a;</div><div class="line">&#125;</div><div class="line"></div><div class="line">#</div><div class="line"></div><div class="line">address private a;</div><div class="line">function c() public returns (address) &#123;</div><div class="line">    return a;</div><div class="line">&#125;</div><div class="line">等同于下面的变量定义(≈)</div><div class="line">address public c;</div></pre></td></tr></table></figure>
<p>公有函数和私有函数的区别也很简单，公有函数会被编译进主函数中，能通过<code>CALLDATA</code>进行调用，而私有函数则只能在其他公有函数中进行调用，无法直接通过设置<code>CALLDATA</code>来调用私有函数</p>
<h3 id="回退函数和paypal"><a href="#回退函数和paypal" class="headerlink" title="回退函数和paypal"></a>回退函数和paypal</h3><p>在智能合约中，函数都能设置一个<code>paypal</code>，还有一个特殊的回退函数，下面用实例来介绍回退函数</p>
<p>比如之前的测试合约加上了回退函数:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">function() &#123;</div><div class="line">    prize += 1;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>则主函数的反编译代码就变成了:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">def main():</div><div class="line">    if CALLDATASIZE &gt;= 4:</div><div class="line">        data = CALLDATA[:4]</div><div class="line">        if data == 0x6b59084d:</div><div class="line">            return test1()</div><div class="line">        elif data == 0x8da5cb5b:</div><div class="line">            return owner()</div><div class="line">        elif data == 0xcaf44683:</div><div class="line">            return test2()</div><div class="line">        elif data == 0xe3ac5d26:</div><div class="line">            return prize()</div><div class="line">    assert msg.value == 0</div><div class="line">    prize += 1</div><div class="line">    exit()</div></pre></td></tr></table></figure>
<p>当<code>CALLDATA</code>和该合约中的函数匹配失败时，将会从抛异常，表示执行失败退出，变成调用回退函数</p>
<p>每一个函数，包括回退函数都可以加一个关键字: <code>paypal</code>，表示可以给该函数转帐，从OPCODE层面讲，没有<code>paypal</code>关键字的函数比有<code>paypal</code>的函数多了一段代码:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">JUMPDEST             | None</div><div class="line">CALLVALUE            | None</div><div class="line">DUP1                 | None</div><div class="line">ISZERO               | None</div><div class="line">PUSH2                | [&apos;0x8e&apos;]</div><div class="line">JUMPI                | None</div><div class="line">PUSH1                | [&apos;0x0&apos;]</div><div class="line">DUP1                 | None</div><div class="line">REVERT               | None</div></pre></td></tr></table></figure>
<p>反编译成python，就是:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">assert msg.value == 0</div></pre></td></tr></table></figure>
<p><code>REVERT</code>是异常退出指令，当交易的金额大于0时，则异常退出，交易失败</p>
<h3 id="函数参数"><a href="#函数参数" class="headerlink" title="函数参数"></a>函数参数</h3><p>函数获取数据的方式只有两种，一个是从storage中获取数据，另一个就是接受用户传参，当函数hash表匹配成功时，我们可以知道该函数的参数个数，和各个参数的类型，但是当hash表匹配失败时，我们仍然可以获取该函数参数的个数，因为获取参数和主函数、<code>paypal</code>检查一样，在OPCODE层面也有固定模型:</p>
<p>比如上面的测试合约，调动<code>test2</code>函数的固定模型就是: <code>main -&gt; paypal check -&gt; get args -&gt; 执行函数代码</code></p>
<p>获取参数的OPCODE如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">; 0xAF: loc_af</div><div class="line">[    0xaf] | JUMPDEST             | None</div><div class="line">[    0xb0] | POP                  | None</div><div class="line">[    0xb1] | PUSH2                | [&apos;0xd1&apos;]</div><div class="line">[    0xb4] | PUSH20               | [&apos;0xffffffffffffffffffffffffffffffffffffffff&apos;]</div><div class="line">[    0xc9] | PUSH1                | [&apos;0x4&apos;]</div><div class="line">[    0xcb] | CALLDATALOAD         | None</div><div class="line">[    0xcc] | AND                  | None</div><div class="line">[    0xcd] | PUSH2                | [&apos;0x18f&apos;]</div><div class="line">[    0xd0] | JUMP                 | None</div></pre></td></tr></table></figure>
<p>函数test2的参数<code>p = CALLDATA[4:4+0x20]</code></p>
<p>如果有第二个参数，则是<code>arg2 = CALLDATA[4+0x20:4+0x40]</code>，以此类推</p>
<p>所以智能合约中，调用函数的规则就是<code>data = sha3(func_name)[:4] + *args</code></p>
<p>但是，上面的规则仅限于定长类型的参数，如果参数是<code>string</code>这种不定长的变量类型时，固定模型仍然不变，但是在从<code>calldata</code>获取数据的方法，变得不同了，定长的变量是通过调用<code>CALLDATALOAD</code>，把值存入栈中，而<code>string</code>类型的变量，因为长度不定，会超过256bits的原因，使用的是<code>calldatacopy</code>把参数存入MEM</p>
<p>可以看看<code>function test3(string a) public {}</code>函数获取参数的代码:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div></pre></td><td class="code"><pre><div class="line">; 0xB2: loc_b2</div><div class="line">[    0xb2] | JUMPDEST             | None</div><div class="line">[    0xb3] | POP                  | None</div><div class="line">[    0xb4] | PUSH1                | [&apos;0x40&apos;]</div><div class="line">[    0xb6] | DUP1                 | None</div><div class="line">[    0xb7] | MLOAD                | None</div><div class="line">[    0xb8] | PUSH1                | [&apos;0x20&apos;]</div><div class="line">[    0xba] | PUSH1                | [&apos;0x4&apos;]</div><div class="line">[    0xbc] | DUP1                 | None</div><div class="line">[    0xbd] | CALLDATALOAD         | None</div><div class="line">[    0xbe] | DUP1                 | None</div><div class="line">[    0xbf] | DUP3                 | None</div><div class="line">[    0xc0] | ADD                  | None</div><div class="line">[    0xc1] | CALLDATALOAD         | None</div><div class="line">[    0xc2] | PUSH1                | [&apos;0x1f&apos;]</div><div class="line">[    0xc4] | DUP2                 | None</div><div class="line">[    0xc5] | ADD                  | None</div><div class="line">[    0xc6] | DUP5                 | None</div><div class="line">[    0xc7] | SWAP1                | None</div><div class="line">[    0xc8] | DIV                  | None</div><div class="line">[    0xc9] | DUP5                 | None</div><div class="line">[    0xca] | MUL                  | None</div><div class="line">[    0xcb] | DUP6                 | None</div><div class="line">[    0xcc] | ADD                  | None</div><div class="line">[    0xcd] | DUP5                 | None</div><div class="line">[    0xce] | ADD                  | None</div><div class="line">[    0xcf] | SWAP1                | None</div><div class="line">[    0xd0] | SWAP6                | None</div><div class="line">[    0xd1] | MSTORE               | None</div><div class="line">[    0xd2] | DUP5                 | None</div><div class="line">[    0xd3] | DUP5                 | None</div><div class="line">[    0xd4] | MSTORE               | None</div><div class="line">[    0xd5] | PUSH2                | [&apos;0xff&apos;]</div><div class="line">[    0xd8] | SWAP5                | None</div><div class="line">[    0xd9] | CALLDATASIZE         | None</div><div class="line">[    0xda] | SWAP5                | None</div><div class="line">[    0xdb] | SWAP3                | None</div><div class="line">[    0xdc] | SWAP4                | None</div><div class="line">[    0xdd] | PUSH1                | [&apos;0x24&apos;]</div><div class="line">[    0xdf] | SWAP4                | None</div><div class="line">[    0xe0] | SWAP3                | None</div><div class="line">[    0xe1] | DUP5                 | None</div><div class="line">[    0xe2] | ADD                  | None</div><div class="line">[    0xe3] | SWAP2                | None</div><div class="line">[    0xe4] | SWAP1                | None</div><div class="line">[    0xe5] | DUP2                 | None</div><div class="line">[    0xe6] | SWAP1                | None</div><div class="line">[    0xe7] | DUP5                 | None</div><div class="line">[    0xe8] | ADD                  | None</div><div class="line">[    0xe9] | DUP4                 | None</div><div class="line">[    0xea] | DUP3                 | None</div><div class="line">[    0xeb] | DUP1                 | None</div><div class="line">[    0xec] | DUP3                 | None</div><div class="line">[    0xed] | DUP5                 | None</div><div class="line">[    0xee] | CALLDATACOPY         | None</div><div class="line">[    0xef] | POP                  | None</div><div class="line">[    0xf0] | SWAP5                | None</div><div class="line">[    0xf1] | SWAP8                | None</div><div class="line">[    0xf2] | POP                  | None</div><div class="line">[    0xf3] | PUSH2                | [&apos;0x166&apos;]</div><div class="line">[    0xf6] | SWAP7                | None</div><div class="line">[    0xf7] | POP                  | None</div><div class="line">[    0xf8] | POP                  | None</div><div class="line">[    0xf9] | POP                  | None</div><div class="line">[    0xfa] | POP                  | None</div><div class="line">[    0xfb] | POP                  | None</div><div class="line">[    0xfc] | POP                  | None</div><div class="line">[    0xfd] | POP                  | None</div><div class="line">[    0xfe] | JUMP                 | None</div></pre></td></tr></table></figure>
<p>传入的变长参数是一个结构体:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">struct string_arg &#123;</div><div class="line">    uint offset;</div><div class="line">    uint length;</div><div class="line">    string data;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>offset+4</code>表示的是当前参数的<code>length</code>的偏移，length为data的长度，data就是用户输入的字符串数据</p>
<p>当有多个变长参数时: <code>function test3(string a, string b) public {}</code></p>
<p><code>calldata</code>的格式如下: <code>sha3(func)[:4] + a.offset + b.offset + a.length + a.data + b.length + b.data</code></p>
<p>翻译成py代码如下:</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">test3</span><span class="params">()</span>:</span></div><div class="line">    offset = data[<span class="number">4</span>:<span class="number">0x24</span>]</div><div class="line">    length = data[offset+<span class="number">4</span>:offset+<span class="number">4</span>+<span class="number">0x20</span>]</div><div class="line">    a = data[offset+<span class="number">4</span>+<span class="number">0x20</span>:length]</div><div class="line">    offset = data[<span class="number">0x24</span>:<span class="number">0x24</span>+<span class="number">0x20</span>]</div><div class="line">    length = data[offset+<span class="number">4</span>:offset+<span class="number">4</span>+<span class="number">0x20</span>]</div><div class="line">    b = data[offset+<span class="number">4</span>+<span class="number">0x20</span>:length]</div></pre></td></tr></table></figure>
<p>因为参数有固定的模型，因此就算没有从hash表中匹配到函数名，也可以判断出函数参数的个数，但是要想知道变量类型，只能区分出定长、变长变量，具体是<code>uint</code>还是<code>address</code>，则需要从函数代码，变量的使用中进行判断</p>
<h3 id="变量类型的分辨"><a href="#变量类型的分辨" class="headerlink" title="变量类型的分辨"></a>变量类型的分辨</h3><p>在智能合约的OPCDOE中，变量也是有特征的</p>
<p>比如一个<code>address</code>变量总会 <code>&amp; 0xffffffffffffffffffffffffffffffffffffffff</code>:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">PUSH1                | [&apos;0x0&apos;]</div><div class="line">SLOAD                | None</div><div class="line">PUSH20               | [&apos;0xffffffffffffffffffffffffffffffffffffffff&apos;]</div><div class="line">AND                  | None</div></pre></td></tr></table></figure>
<p>上一篇说的mapping和array的储存模型，可以根据SHA3的计算方式知道是映射变量还是数组变量</p>
<p>再比如，<code>uint</code>变量因为等同于<code>uint256</code>，所以使用<code>SLOAD</code>获取以后不会再进行<code>AND</code>计算，但是<code>uint8</code>却会计算<code>&amp; 0xff</code></p>
<p>所以我们可以<code>SLOAD</code>指令的参数和后面紧跟的计算，来判断出变量类型</p>
<h2 id="智能合约代码结构"><a href="#智能合约代码结构" class="headerlink" title="智能合约代码结构"></a>智能合约代码结构</h2><h3 id="部署合约"><a href="#部署合约" class="headerlink" title="部署合约"></a>部署合约</h3><p>在区块链上，要同步/发布任何信息，都是通过发送交易来进行的，用之前的测试合约来举例，合约地址为: <code>0xc9fbe313dc1d6a1c542edca21d1104c338676ffd</code>, 创建合约的交易地址为: <code>0x6cf9d5fe298c7e1b84f4805adddba43e7ffc8d8ffe658b4c3708f42ed94d90ed</code></p>
<p>查看下该交易的相关信息:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">&gt; eth.getTransaction(&quot;0x6cf9d5fe298c7e1b84f4805adddba43e7ffc8d8ffe658b4c3708f42ed94d90ed&quot;)</div><div class="line">&#123;</div><div class="line">  blockHash: &quot;0x7f684a294f39e16ba1e82a3b6d2fc3a1e82ef023b5fb52261f9a89d831a24ed5&quot;,</div><div class="line">  blockNumber: 3607048,</div><div class="line">  from: &quot;0x0109dea8b64d87a26e7fe9af6400375099c78fdd&quot;,</div><div class="line">  gas: 171331,</div><div class="line">  gasPrice: 1000000000,</div><div class="line">  hash: &quot;0x6cf9d5fe298c7e1b84f4805adddba43e7ffc8d8ffe658b4c3708f42ed94d90ed&quot;,</div><div class="line">  input: &quot;0x608060405234801561001057600080fd5b5060008054600160a060020a0319163317905561016f806100326000396000f3006080604052600436106100615763ffffffff7c01000000000000000000000000000000000000000000000000000000006000350416636b59084d81146100665780638da5cb5b146100a4578063caf44683146100b9578063e3ac5d26146100d3575b600080fd5b34801561007257600080fd5b5061007b6100fa565b6040805173ffffffffffffffffffffffffffffffffffffffff9092168252519081900360200190f35b3480156100b057600080fd5b5061007b610116565b3480156100c557600080fd5b506100d1600435610132565b005b3480156100df57600080fd5b506100e861013d565b60408051918252519081900360200190f35b60005473ffffffffffffffffffffffffffffffffffffffff1690565b60005473ffffffffffffffffffffffffffffffffffffffff1681565b600180549091019055565b600154815600a165627a7a7230582040d052fef9322403cb3c1de27683a42a845e091972de4c264134dd575b14ee4e0029&quot;,</div><div class="line">  nonce: 228,</div><div class="line">  r: &quot;0xa08f0cd907207af4de54f9f63f3c9a959c3e960ef56f7900d205648edbd848c6&quot;,</div><div class="line">  s: &quot;0x5bb99e4ab9fe76371e4d67a30208aeac558b2989a6c783d08b979239c8221a88&quot;,</div><div class="line">  to: null,</div><div class="line">  transactionIndex: 4,</div><div class="line">  v: &quot;0x2a&quot;,</div><div class="line">  value: 0</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们可以看出来，想一个空目标发送<code>OPCODE</code>的交易就是创建合约的交易，但是在交易信息中，却不包含合约地址，那么合约地址是怎么得到的呢?</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">function addressFrom(address _origin, uint _nonce) public pure returns (address) &#123;</div><div class="line">        if(_nonce == 0x00)     return address(keccak256(byte(0xd6), byte(0x94), _origin, byte(0x80)));</div><div class="line">        if(_nonce &lt;= 0x7f)     return address(keccak256(byte(0xd6), byte(0x94), _origin, byte(_nonce)));</div><div class="line">        if(_nonce &lt;= 0xff)     return address(keccak256(byte(0xd7), byte(0x94), _origin, byte(0x81), uint8(_nonce)));</div><div class="line">        if(_nonce &lt;= 0xffff)   return address(keccak256(byte(0xd8), byte(0x94), _origin, byte(0x82), uint16(_nonce)));</div><div class="line">        if(_nonce &lt;= 0xffffff) return address(keccak256(byte(0xd9), byte(0x94), _origin, byte(0x83), uint24(_nonce)));</div><div class="line">        return address(keccak256(byte(0xda), byte(0x94), _origin, byte(0x84), uint32(_nonce))); // more than 2^32 nonces not realistic</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>智能合约的地址由创建合约的账号和<code>nonce</code>决定，<code>nonce</code>用来记录用户发送的交易个数，在每个交易中都有该字段，现在根据上面的信息来计算下合约地址:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"># 创建合约的账号 from: &quot;0x0109dea8b64d87a26e7fe9af6400375099c78fdd&quot;,</div><div class="line"># nonce: 228 = 0xe4 =&gt; 0x7f &lt; 0xe4 &lt; 0xff</div><div class="line">&gt;&gt;&gt; sha3.keccak_256(binascii.unhexlify(&quot;d7&quot; + &quot;94&quot; + &quot;0109dea8b64d87a26e7fe9af6400375099c78fdd&quot; + &quot;81e4&quot;)).hexdigest()[-40:]</div><div class="line">&apos;c9fbe313dc1d6a1c542edca21d1104c338676ffd&apos;</div></pre></td></tr></table></figure>
<h3 id="创建合约代码"><a href="#创建合约代码" class="headerlink" title="创建合约代码"></a>创建合约代码</h3><p>一个智能合约的OPCODE分为两种，一个是编译器编译好后的创建合约代码，还是合约部署好以后runtime代码，之前我们看的，研究的都是runtime代码，现在来看看创建合约代码，创建合约代码可以在创建合约交易的<code>input</code>数据总获取，上面已经把数据粘贴出来了，反汇编出指令如下: </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line">; 0x0: main</div><div class="line">[     0x0] | PUSH1                | [&apos;0x80&apos;]</div><div class="line">[     0x2] | PUSH1                | [&apos;0x40&apos;]</div><div class="line">[     0x4] | MSTORE               | None</div><div class="line">[     0x5] | CALLVALUE            | None</div><div class="line">[     0x6] | DUP1                 | None</div><div class="line">[     0x7] | ISZERO               | None</div><div class="line">[     0x8] | PUSH2                | [&apos;0x10&apos;]</div><div class="line">[     0xb] | JUMPI                | None</div><div class="line">[     0xc] | PUSH1                | [&apos;0x0&apos;]</div><div class="line">[     0xe] | DUP1                 | None</div><div class="line">[     0xf] | REVERT               | None</div><div class="line">----------------------------------------------------------------</div><div class="line">; 0x10: loc_10</div><div class="line">[    0x10] | JUMPDEST             | None</div><div class="line">[    0x11] | POP                  | None</div><div class="line">[    0x12] | PUSH1                | [&apos;0x0&apos;]</div><div class="line">[    0x14] | DUP1                 | None</div><div class="line">[    0x15] | SLOAD                | None</div><div class="line">[    0x16] | PUSH1                | [&apos;0x1&apos;]</div><div class="line">[    0x18] | PUSH1                | [&apos;0xa0&apos;]</div><div class="line">[    0x1a] | PUSH1                | [&apos;0x2&apos;]</div><div class="line">[    0x1c] | EXP                  | None</div><div class="line">[    0x1d] | SUB                  | None</div><div class="line">[    0x1e] | NOT                  | None</div><div class="line">[    0x1f] | AND                  | None</div><div class="line">[    0x20] | CALLER               | None</div><div class="line">[    0x21] | OR                   | None</div><div class="line">[    0x22] | SWAP1                | None</div><div class="line">[    0x23] | SSTORE               | None</div><div class="line">[    0x24] | PUSH2                | [&apos;0x24f&apos;]</div><div class="line">[    0x27] | DUP1                 | None</div><div class="line">[    0x28] | PUSH2                | [&apos;0x32&apos;]</div><div class="line">[    0x2b] | PUSH1                | [&apos;0x0&apos;]</div><div class="line">[    0x2d] | CODECOPY             | None</div><div class="line">[    0x2e] | PUSH1                | [&apos;0x0&apos;]</div><div class="line">[    0x30] | RETURN               | None</div></pre></td></tr></table></figure>
<p>代码逻辑很简单，就是执行了合约的构造函数，并且返回了合约的runtime代码，该合约的构造函数为:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">function Test() &#123;</div><div class="line">    owner = msg.sender;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>因为没有<code>paypal</code>关键字，所以开头是一个check代码<code>assert msg.value == 0</code></p>
<p>然后就是对<code>owner</code>变量的赋值，当执行完构造函数后，就是把runtime代码复制到内存中:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">CODECOPY(0, 0x32, 0x24f)  # mem[0:0+0x24f] = CODE[0x32:0x32+0x24f]</div></pre></td></tr></table></figure>
<p>最后在把runtime代码返回: <code>return mem[0:0x24f]</code></p>
<p>在完全了解合约是如何部署的之后，也许可以写一个OPCODE混淆的CTF逆向题</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>通过了解EVM的数据结构模型，不仅可以加快对OPCODE的逆向速度，对于编写反编译脚本也有非常大的帮助，可以对反编译出来的代码进行优化，使得更加接近源码。</p>
<p>在对智能合约的OPCODE有了一定的了解后，后续准备先写一个EVM的调试器，虽然Remix已经有了一个非常优秀的调试器了，但是却需要有<code>Solidity</code>源代码，这无法满足我测试无源码的OPCODE的工作需求。所以请期待下篇《以太坊智能合约OPCODE逆向之调试器篇》</p>
<h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><ol>
<li><span id="jump1"><a href="https://github.com/comaeio/porosity" target="_blank" rel="external">https://github.com/comaeio/porosity</a></span></li>
<li><span id="jump2"><a href="https://github.com/meyer9/ethdasm" target="_blank" rel="external">https://github.com/meyer9/ethdasm</a></span></li>
<li><span id="jump3"><a href="https://github.com/trailofbits/evm-opcodes" target="_blank" rel="external">https://github.com/trailofbits/evm-opcodes</a></span></li>
<li><span id="jump4"><a href="http://solidity.readthedocs.io/en/v0.4.21/assembly.html" target="_blank" rel="external">http://solidity.readthedocs.io/en/v0.4.21/assembly.html</a></span></li>
<li><span id="jump5"><a href="https://github.com/trailofbits/ida-evm" target="_blank" rel="external">https://github.com/trailofbits/ida-evm</a></span></li>
<li><span id="jump6"><a href="https://github.com/trailofbits/ida-evm/blob/master/known_hashes.py" target="_blank" rel="external">https://github.com/trailofbits/ida-evm/blob/master/known_hashes.py</a></span></li>
</ol>
]]></content:encoded>
      
      <comments>//0x48.pw/2018/07/09/0x45/#disqus_thread</comments>
    </item>
    
    <item>
      <title>以太坊智能合约学习笔记1</title>
      <link>//0x48.pw/2018/06/22/0x44/</link>
      <guid>//0x48.pw/2018/06/22/0x44/</guid>
      <pubDate>Fri, 22 Jun 2018 08:40:35 GMT</pubDate>
      <description>
      
        &lt;p&gt;最近在学习智能合约，记录下学习笔记&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<p>最近在学习智能合约，记录下学习笔记</p>
<a id="more"></a>
<h2 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h2><p>以太坊的智能合约是使用<code>Solidity</code>编程语言，所以首先需要搭建相关的环境</p>
<ol>
<li>以太坊</li>
</ol>
<p>使用golang开发的客户端<code>geth</code>: <code>https://github.com/ethereum/go-ethereum</code></p>
<p>相关命令:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">$ geth account list      # 列出以太坊账号</div><div class="line">$ geth account new       # 如果没有账号使用该命令新建一个</div><div class="line">$ geth                   # 下面列出可能需要使用的启动参数</div><div class="line">--unlock addr            # 解锁账号, 也可以到控制台使用personal解锁</div><div class="line">--testnet                # 切换到Ropsten network测试网络</div><div class="line">--datadir dir            # 设置以太坊数据存储目录</div><div class="line">--rpc --rpcaddr 0.0.0.0 --rpccorsdomain &quot;*&quot;  # 开启RPC，默认端口8545，可以通过web3.js调用</div></pre></td></tr></table></figure>
<p>下面举例使用Ropsten测试网络:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">$ screen -S geth</div><div class="line">$ ./geth --testnet</div><div class="line">CTRL+A D</div><div class="line">$ ./geth attach</div><div class="line">&gt;</div></pre></td></tr></table></figure>
<ol>
<li>solc编译器</li>
</ol>
<p>geth最新版已经移除了solc编译器，所以需要我们自己在本地安装一个:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ npm install -g solc</div></pre></td></tr></table></figure>
<p>编译出abi:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ solcjs --abi -o output test.sol</div></pre></td></tr></table></figure>
<p>如果有导入第三方库:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">$ cat test.sol </div><div class="line">pragma solidity ^0.4.18;</div><div class="line"></div><div class="line">import &apos;zeppelin-solidity/contracts/ownership/Ownable.sol&apos;;</div><div class="line"></div><div class="line">contract King is Ownable &#123;</div><div class="line"></div><div class="line">  address public king;</div><div class="line">  uint public prize;</div><div class="line"></div><div class="line">  function King() public payable &#123;</div><div class="line">    king = msg.sender;</div><div class="line">    prize = msg.value;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  function() external payable &#123;</div><div class="line">    require(msg.value &gt;= prize || msg.sender == owner);</div><div class="line">    king.transfer(msg.value);</div><div class="line">    king = msg.sender;</div><div class="line">    prize = msg.value;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line">$ npm install zeppelin-solidity</div><div class="line">$ solcjs --abi -o output node_modules/zeppelin-solidity/contracts/ownership/Ownable.sol king.sol</div><div class="line">$ cat output/king_sol_King.abi </div><div class="line">[&#123;&quot;constant&quot;:false,&quot;inputs&quot;:[],&quot;name&quot;:&quot;renounceOwnership&quot;,&quot;outputs&quot;:[],&quot;payable&quot;:false,&quot;stateMutability&quot;:&quot;nonpayable&quot;,&quot;type&quot;:&quot;function&quot;&#125;,&#123;&quot;constant&quot;:true,&quot;inputs&quot;:[],&quot;name&quot;:&quot;owner&quot;,&quot;outputs&quot;:[&#123;&quot;name&quot;:&quot;&quot;,&quot;type&quot;:&quot;address&quot;&#125;],&quot;payable&quot;:false,&quot;stateMutability&quot;:&quot;view&quot;,&quot;type&quot;:&quot;function&quot;&#125;,&#123;&quot;constant&quot;:true,&quot;inputs&quot;:[],&quot;name&quot;:&quot;king&quot;,&quot;outputs&quot;:[&#123;&quot;name&quot;:&quot;&quot;,&quot;type&quot;:&quot;address&quot;&#125;],&quot;payable&quot;:false,&quot;stateMutability&quot;:&quot;view&quot;,&quot;type&quot;:&quot;function&quot;&#125;,&#123;&quot;constant&quot;:true,&quot;inputs&quot;:[],&quot;name&quot;:&quot;prize&quot;,&quot;outputs&quot;:[&#123;&quot;name&quot;:&quot;&quot;,&quot;type&quot;:&quot;uint256&quot;&#125;],&quot;payable&quot;:false,&quot;stateMutability&quot;:&quot;view&quot;,&quot;type&quot;:&quot;function&quot;&#125;,&#123;&quot;constant&quot;:false,&quot;inputs&quot;:[&#123;&quot;name&quot;:&quot;_newOwner&quot;,&quot;type&quot;:&quot;address&quot;&#125;],&quot;name&quot;:&quot;transferOwnership&quot;,&quot;outputs&quot;:[],&quot;payable&quot;:false,&quot;stateMutability&quot;:&quot;nonpayable&quot;,&quot;type&quot;:&quot;function&quot;&#125;,&#123;&quot;inputs&quot;:[],&quot;payable&quot;:true,&quot;stateMutability&quot;:&quot;payable&quot;,&quot;type&quot;:&quot;constructor&quot;&#125;,&#123;&quot;payable&quot;:true,&quot;stateMutability&quot;:&quot;payable&quot;,&quot;type&quot;:&quot;fallback&quot;&#125;,&#123;&quot;anonymous&quot;:false,&quot;inputs&quot;:[&#123;&quot;indexed&quot;:true,&quot;name&quot;:&quot;previousOwner&quot;,&quot;type&quot;:&quot;address&quot;&#125;],&quot;name&quot;:&quot;OwnershipRenounced&quot;,&quot;type&quot;:&quot;event&quot;&#125;,&#123;&quot;anonymous&quot;:false,&quot;inputs&quot;:[&#123;&quot;indexed&quot;:true,&quot;name&quot;:&quot;previousOwner&quot;,&quot;type&quot;:&quot;address&quot;&#125;,&#123;&quot;indexed&quot;:true,&quot;name&quot;:&quot;newOwner&quot;,&quot;type&quot;:&quot;address&quot;&#125;],&quot;name&quot;:&quot;OwnershipTransferred&quot;,&quot;type&quot;:&quot;event&quot;&#125;]</div></pre></td></tr></table></figure>
<ol>
<li>IDE</li>
</ol>
<p>ide使用的是remix-ide，可以使用在线版的: <a href="http://remix.ethereum.org/" target="_blank" rel="external">http://remix.ethereum.org/</a></p>
<p>也可以本地自己搭一个:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ npm install -g remix-ide</div><div class="line">$ remix-ide</div></pre></td></tr></table></figure>
<ol>
<li>以太坊数据查询</li>
</ol>
<p>公链数据查询: <a href="https://etherscan.io/" target="_blank" rel="external">https://etherscan.io/</a><br>Ropsten测试链: <a href="https://ropsten.etherscan.io/" target="_blank" rel="external">https://ropsten.etherscan.io/</a><br>其他查询网站: <a href="https://www.etherchain.org/" target="_blank" rel="external">https://www.etherchain.org/</a></p>
<h2 id="以太坊-区块链基础知识"><a href="#以太坊-区块链基础知识" class="headerlink" title="以太坊/区块链基础知识"></a>以太坊/区块链基础知识</h2><p>在以太坊中任何操作(转账，部署合约，调用合约函数)都是以交易的形式存在，每进行一次交易，都会加入pending列表中，同步给其他节点，当有一个节点挖出了一个区块，将会把pending列表中的所以交易打包</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div></pre></td><td class="code"><pre><div class="line">&gt; eth.blockNumber</div><div class="line">5833460                       # geth客户端同步的最大区块数</div><div class="line">&gt; eth.getBlock(0)             # 获取区块信息，0是创世区块</div><div class="line">&#123;</div><div class="line">  difficulty: 17179869184,</div><div class="line">  extraData: &quot;0x11bbe8db4e347b4e8c937c1c8370e4b5ed33adb3db69cbdb7a38e1e50b1b82fa&quot;,</div><div class="line">  gasLimit: 5000,</div><div class="line">  gasUsed: 0,</div><div class="line">  hash: &quot;0xd4e56740f876aef8c010b86a40d5f56745a118d0906a34e69aec8c0db1cb8fa3&quot;,</div><div class="line">  logsBloom: &quot;0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000&quot;,</div><div class="line">  miner: &quot;0x0000000000000000000000000000000000000000&quot;,</div><div class="line">  mixHash: &quot;0x0000000000000000000000000000000000000000000000000000000000000000&quot;,</div><div class="line">  nonce: &quot;0x0000000000000042&quot;,</div><div class="line">  number: 0,</div><div class="line">  parentHash: &quot;0x0000000000000000000000000000000000000000000000000000000000000000&quot;,</div><div class="line">  receiptsRoot: &quot;0x56e81f171bcc55a6ff8345e692c0f86e5b48e01b996cadc001622fb5e363b421&quot;,</div><div class="line">  sha3Uncles: &quot;0x1dcc4de8dec75d7aab85b567b6ccd41ad312451b948a7413f0a142fd40d49347&quot;,</div><div class="line">  size: 540,</div><div class="line">  stateRoot: &quot;0xd7f8974fb5ac78d9ac099b9ad5018bedc2ce0a72dad1827a1709da30580f0544&quot;,</div><div class="line">  timestamp: 0,</div><div class="line">  totalDifficulty: 17179869184,</div><div class="line">  transactions: [],</div><div class="line">  transactionsRoot: &quot;0x56e81f171bcc55a6ff8345e692c0f86e5b48e01b996cadc001622fb5e363b421&quot;,</div><div class="line">  uncles: []</div><div class="line">&#125;</div><div class="line">&gt; eth.getBlock(5833460)          # 获取最新区块信息</div><div class="line">&#123;</div><div class="line">  difficulty: 3405471720099834,</div><div class="line">  extraData: &quot;0x436f72746578&quot;,</div><div class="line">  gasLimit: 7992236,</div><div class="line">  gasUsed: 7978832,</div><div class="line">  hash: &quot;0x1d7b7d1e6926c048089ecf02b0ea30d87027b168c594f4ba8fa91043e9a2faca&quot;,</div><div class="line">  logsBloom: &quot;0x021000818840a288010400002000200000002c0000408204340201204c0801000488101400000000448040431001040242401800014004900410000008e0a0000000205428000418104c050842407088081000020824200000000100102900008260104c2222050285105082040008301000041149040000006023141080000000a000080000000081401589c08002005000018008800002020a000204002810428c100006c098008280480075000900010814888809101004800000008801001400080350000008482003a9403020a0420308002088080404000002122a2488009020042b220600119502c10400760422400000445002000048be1228000000&quot;,</div><div class="line">  miner: &quot;0x9435d50503aee35c8757ae4933f7a0ab56597805&quot;,</div><div class="line">  mixHash: &quot;0xec3cff1e31ea6049ca89447e43833c2abf9c3c34f15ab679be016656dd44fd6e&quot;,</div><div class="line">  nonce: &quot;0xa02c0ff7551c38a0&quot;,</div><div class="line">  number: 5833460,</div><div class="line">  parentHash: &quot;0xbeb2058d273049a7bedc78284bb4b3d29195e46d3183b559bdb5e1e597291588&quot;,</div><div class="line">  receiptsRoot: &quot;0xb935e9bbcf039e7359694f1070b82886f8248fb195c8db1e48afc3b1c0eb9dae&quot;,</div><div class="line">  sha3Uncles: &quot;0x1dcc4de8dec75d7aab85b567b6ccd41ad312451b948a7413f0a142fd40d49347&quot;,</div><div class="line">  size: 37212,</div><div class="line">  stateRoot: &quot;0x5416a9c99d906d546f61f537016eac65d3dbe7745f4f5d7686ec9656057d4f42&quot;,</div><div class="line">  timestamp: 1529659415,</div><div class="line">  totalDifficulty: 4.911074548581714109311e+21,</div><div class="line">  transactions: [&quot;0x5f2a644707ec534cda626d1fd8cb0f679d0b4f5c475f95183e3326e38ec596d4&quot;......]  # 区块中打包的交易地址</div><div class="line">  transactionsRoot: &quot;0x97331e3aadd2e144f30354051a687d554c451af8d86237b36cbdc711111ea14f&quot;,</div><div class="line">  uncles: []</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在以太坊中，重要的有三个地址，个人账户地址，合约地址，交易地址</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"># 获取交易地址信息</div><div class="line">&gt; eth.getTransaction(&quot;0x5f2a644707ec534cda626d1fd8cb0f679d0b4f5c475f95183e3326e38ec596d4&quot;)</div><div class="line">&#123;</div><div class="line">  blockHash: &quot;0x1d7b7d1e6926c048089ecf02b0ea30d87027b168c594f4ba8fa91043e9a2faca&quot;,</div><div class="line">  blockNumber: 5833460,</div><div class="line">  from: &quot;0xd2bb24e348651970e0a3ae50ea89e5ff2b37c09b&quot;,</div><div class="line">  gas: 45000,</div><div class="line">  gasPrice: 122000000000,</div><div class="line">  hash: &quot;0x5f2a644707ec534cda626d1fd8cb0f679d0b4f5c475f95183e3326e38ec596d4&quot;,</div><div class="line">  input: &quot;0x&quot;,</div><div class="line">  nonce: 21,</div><div class="line">  r: &quot;0x5b431a69cd3ea332aad413e3e63a88a03f33305445e430257ab05b6eed1c56&quot;,</div><div class="line">  s: &quot;0x395069ef7f4848d8019c5a63f16e21b0d56baca887aa5cd3cda76b2936bf77a2&quot;,</div><div class="line">  to: &quot;0x2737062e58d2d52e7726df72e1da0828f89bd3b7&quot;,</div><div class="line">  transactionIndex: 0,</div><div class="line">  v: &quot;0x25&quot;,</div><div class="line">  value: 34100000000000000</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>不管是个人账户还是合约地址，都能储存以太币余额，两者的区别是，个人账户地址的所有者具有该地址的公私钥，能进行签名，所以能向任意个人/合约地址转账，而合约地址不具有公私钥，所以如果一个合约不具有转账的函数，这个合约将会成为一个黑洞，以太币只能存进行，但任何人都没法取出来</p>
<p>个人账户和合约地址还有一个区别，合约地址能储存数据，个人账户不行:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&gt; eth.getCode(&quot;0xd2bb24e348651970e0a3ae50ea89e5ff2b37c09b&quot;)  # 个人账户地址</div><div class="line">&quot;0x&quot;</div><div class="line">&gt; eth.getCode(&quot;0x0b76544F6C413a555F309Bf76260d1E02377c02A&quot;) # 合约地址</div><div class="line">&quot;0x606060405236156101255763ffffffff7c01000000000000000000000000.......</div></pre></td></tr></table></figure>
<p>智能合约会被转换成字节码储存在区块中, 但是在<a href="https://etherscan.io/" target="_blank" rel="external">https://etherscan.io/</a>网站中，一些智能合约能查看源码，这是由于合约发布者在该网站主动公布了源码，否则我们只能获取到字节码，所以智能合约的反编译也是一个有必要的工作</p>
<p>在以太坊中，基本单位是Wei，我们可以使用下面的函数将其和ether进行转换:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&gt; web3.toWei(1)</div><div class="line">&quot;1000000000000000000&quot;</div><div class="line">&gt; web3.fromWei(1000000000000000000)</div><div class="line">&quot;1&quot;</div></pre></td></tr></table></figure>
<h2 id="通过命令行控制智能合约"><a href="#通过命令行控制智能合约" class="headerlink" title="通过命令行控制智能合约"></a>通过命令行控制智能合约</h2><p>测试代码:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">pragma solidity ^0.4.24;</div><div class="line"></div><div class="line">contract test&#123;</div><div class="line">    </div><div class="line">    address public owner;</div><div class="line">    uint256 public value;</div><div class="line">    </div><div class="line">    function test() &#123;</div><div class="line">        owner = msg.sender;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    function test1() returns (string)&#123;</div><div class="line">        return &quot;hello&quot;;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    function () payable &#123;</div><div class="line">        value = msg.value;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>使用remix-ide在ropsten测试链上进行部署，得到合约地址: <code>0x22BAf676C25fB4a9462a6f3571769Ad98Ce6B2Cb</code></p>
<p>在ide上获取该合约的abi，去掉回车:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; abi.replace(&quot;\n&quot;, &quot;&quot;).replace(&quot;\t&quot;, &quot;&quot;)</div><div class="line">&apos;[&#123;&quot;constant&quot;: false,&quot;inputs&quot;: [],&quot;name&quot;: &quot;test1&quot;,&quot;outputs&quot;: [&#123;&quot;name&quot;: &quot;&quot;,&quot;type&quot;: &quot;string&quot;&#125;],&quot;payable&quot;: false,&quot;stateMutability&quot;: &quot;nonpayable&quot;,&quot;type&quot;: &quot;function&quot;&#125;,&#123;&quot;payable&quot;: true,&quot;stateMutability&quot;: &quot;payable&quot;,&quot;type&quot;: &quot;fallback&quot;&#125;,&#123;&quot;inputs&quot;: [],&quot;payable&quot;: false,&quot;stateMutability&quot;: &quot;nonpayable&quot;,&quot;type&quot;: &quot;constructor&quot;&#125;,&#123;&quot;constant&quot;: true,&quot;inputs&quot;: [],&quot;name&quot;: &quot;owner&quot;,&quot;outputs&quot;: [&#123;&quot;name&quot;: &quot;&quot;,&quot;type&quot;: &quot;address&quot;&#125;],&quot;payable&quot;: false,&quot;stateMutability&quot;: &quot;view&quot;,&quot;type&quot;: &quot;function&quot;&#125;,&#123;&quot;constant&quot;: true,&quot;inputs&quot;: [],&quot;name&quot;: &quot;value&quot;,&quot;outputs&quot;: [&#123;&quot;name&quot;: &quot;&quot;,&quot;type&quot;: &quot;uint256&quot;&#125;],&quot;payable&quot;: false,&quot;stateMutability&quot;: &quot;view&quot;,&quot;type&quot;: &quot;function&quot;&#125;]&apos;</div></pre></td></tr></table></figure>
<p>然后在geth命令行进行操作:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">abi = [&#123;&quot;constant&quot;: false,&quot;inputs&quot;: [],&quot;name&quot;: &quot;test1&quot;,&quot;outputs&quot;: [&#123;&quot;name&quot;: &quot;&quot;,&quot;type&quot;: &quot;string&quot;&#125;],&quot;payable&quot;: false,&quot;stateMutability&quot;: &quot;nonpayable&quot;,&quot;type&quot;: &quot;function&quot;&#125;,&#123;&quot;payable&quot;: true,&quot;stateMutability&quot;: &quot;payable&quot;,&quot;type&quot;: &quot;fallback&quot;&#125;,&#123;&quot;inputs&quot;: [],&quot;payable&quot;: false,&quot;stateMutability&quot;: &quot;nonpayable&quot;,&quot;type&quot;: &quot;constructor&quot;&#125;,&#123;&quot;constant&quot;: true,&quot;inputs&quot;: [],&quot;name&quot;: &quot;owner&quot;,&quot;outputs&quot;: [&#123;&quot;name&quot;: &quot;&quot;,&quot;type&quot;: &quot;address&quot;&#125;],&quot;payable&quot;: false,&quot;stateMutability&quot;: &quot;view&quot;,&quot;type&quot;: &quot;function&quot;&#125;,&#123;&quot;constant&quot;: true,&quot;inputs&quot;: [],&quot;name&quot;: &quot;value&quot;,&quot;outputs&quot;: [&#123;&quot;name&quot;: &quot;&quot;,&quot;type&quot;: &quot;uint256&quot;&#125;],&quot;payable&quot;: false,&quot;stateMutability&quot;: &quot;view&quot;,&quot;type&quot;: &quot;function&quot;&#125;]</div><div class="line">contract = eth.contract(abi)</div><div class="line">test=contract.at(&quot;0x22BAf676C25fB4a9462a6f3571769Ad98Ce6B2Cb&quot;)</div></pre></td></tr></table></figure>
<p>然后我们可以对该合约进行操作:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&gt; test.owner()     # 部署人的地址</div><div class="line">&quot;0x0109dea8b64d87a26e7fe9af6400375099c78fdd&quot;</div><div class="line">&gt; test.test1(&#123;from:eth.accounts[0]&#125;)</div><div class="line">&quot;0xf642261cb4794ba71be3a1ecf0de0b6b613961a37a7b5e213dae06bd79e1177d&quot;</div></pre></td></tr></table></figure>
<p>因为调用函数需要消耗gas，所以需要指定是哪个账号调用该合约函数，在web3js中调用函数的参数分别是，该函数本身需要的参数，以太坊相关信息参数(一个字典)，回调函数</p>
<p>以太坊相关信息参数字典:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">from: addr,</div><div class="line">to: addr,</div><div class="line">value: 1    # 转账1wei</div><div class="line">gas: 1000   # 调用该函数的过程中只允许消耗1000gas</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>向智能合约转账触发回退函数:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">&gt; test.value()</div><div class="line">0</div><div class="line">&gt; eth.getBalance(test.address)</div><div class="line">0</div><div class="line">&gt; eth.sendTransaction(&#123;from:eth.accounts[0], to: test.address, value:web3.toWei(0.5)&#125;)</div><div class="line">&quot;0xb411711d15a49fdfa242f6be178d3e5aae24646569c60da9fe8f0da555416070&quot;</div><div class="line">&gt;eth.getBalance(test.address)</div><div class="line">500000000000000000</div><div class="line">&gt; test.value()</div><div class="line">500000000000000000</div></pre></td></tr></table></figure>
<p>因为该合约没有写转账代码，所以这0.5以太币就永远待在这个合约当中了，不过因为是在测试链中，所以舍得~</p>
]]></content:encoded>
      
      <comments>//0x48.pw/2018/06/22/0x44/#disqus_thread</comments>
    </item>
    
    <item>
      <title>以太坊智能合约Owner相关CVE漏洞分析</title>
      <link>//0x48.pw/2018/06/19/0x43/</link>
      <guid>//0x48.pw/2018/06/19/0x43/</guid>
      <pubDate>Tue, 19 Jun 2018 06:41:43 GMT</pubDate>
      <description>
      
        &lt;h1 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h1&gt;&lt;p&gt;最近学习了下以太坊的智能合约，而且也看到挺多厂家pr智能合约相关的漏洞，其中《ERC20智能合约整数溢出系列漏洞披露》&lt;a href=&quot;#jump1&quot;&gt;[1]&lt;/a&gt;文章中披露了6个CVE编号的漏洞，而这些漏洞都属于整型溢出漏洞范畴，其中5个漏洞均需要合约Owner才能触发利用。本文正是针对这些漏洞从合约代码及触发逻辑上做了详细分析，并提出了一些关于owner相关漏洞的思考。&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>最近学习了下以太坊的智能合约，而且也看到挺多厂家pr智能合约相关的漏洞，其中《ERC20智能合约整数溢出系列漏洞披露》<a href="#jump1">[1]</a>文章中披露了6个CVE编号的漏洞，而这些漏洞都属于整型溢出漏洞范畴，其中5个漏洞均需要合约Owner才能触发利用。本文正是针对这些漏洞从合约代码及触发逻辑上做了详细分析，并提出了一些关于owner相关漏洞的思考。</p>
<a id="more"></a>
<p>#漏洞分析</p>
<h2 id="1-CVE-2018-11809"><a href="#1-CVE-2018-11809" class="headerlink" title="1. CVE-2018-11809"></a>1. CVE-2018-11809</h2><p>该漏洞被称为“超额购币”，相关合约（EthLendToken）源码: <a href="https://etherscan.io/address/0x80fB784B7eD66730e8b1DBd9820aFD29931aab03#code" target="_blank" rel="external">https://etherscan.io/address/0x80fB784B7eD66730e8b1DBd9820aFD29931aab03#code</a></p>
<p>在合约代码中，<code>buyTokensPresale</code>和<code>buyTokensICO</code>两个函数都是存在整型上溢出的情况：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line">function buyTokensPresale() public payable onlyInState(State.PresaleRunning)</div><div class="line">    &#123;</div><div class="line">        // min - 1 ETH</div><div class="line">        require(msg.value &gt;= (1 ether / 1 wei));</div><div class="line">        uint newTokens = msg.value * PRESALE_PRICE;</div><div class="line"></div><div class="line">        require(presaleSoldTokens + newTokens &lt;= PRESALE_TOKEN_SUPPLY_LIMIT);</div><div class="line"></div><div class="line">        balances[msg.sender] += newTokens;</div><div class="line">        supply+= newTokens;</div><div class="line">        presaleSoldTokens+= newTokens;</div><div class="line">        totalSoldTokens+= newTokens;</div><div class="line"></div><div class="line">        LogBuy(msg.sender, newTokens);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    function buyTokensICO() public payable onlyInState(State.ICORunning)</div><div class="line">    &#123;</div><div class="line">        // min - 0.01 ETH</div><div class="line">        require(msg.value &gt;= ((1 ether / 1 wei) / 100));</div><div class="line">        uint newTokens = msg.value * getPrice();</div><div class="line"></div><div class="line">        require(totalSoldTokens + newTokens &lt;= TOTAL_SOLD_TOKEN_SUPPLY_LIMIT);</div><div class="line"></div><div class="line">        balances[msg.sender] += newTokens;</div><div class="line">        supply+= newTokens;</div><div class="line">        icoSoldTokens+= newTokens;</div><div class="line">        totalSoldTokens+= newTokens;</div><div class="line"></div><div class="line">        LogBuy(msg.sender, newTokens);</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>溢出点：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">require(presaleSoldTokens + newTokens &lt;= PRESALE_TOKEN_SUPPLY_LIMIT);</div><div class="line">require(totalSoldTokens + newTokens &lt;= TOTAL_SOLD_TOKEN_SUPPLY_LIMIT);</div></pre></td></tr></table></figure>
<p>拿<code>buyTokensPresale</code>函数举例，在理论上<code>presaleSoldTokens + newTokens</code>存在整型上溢出漏洞，会导致绕过<code>require</code>判断，造成超额购币。</p>
<p>接下来，我们再仔细分析一下，如果造成整型上溢出，先来看看<code>presaleSoldTokens</code>变量的最大值</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">uint public presaleSoldTokens = 0;</div><div class="line">require(presaleSoldTokens + newTokens &lt;= PRESALE_TOKEN_SUPPLY_LIMIT);</div><div class="line">presaleSoldTokens+= newTokens;</div></pre></td></tr></table></figure>
<p>该合约代码中，<code>presaleSoldTokens</code>变量相关的代码只有这三行，因为存在着require判断，所以不论<code>presaleSoldTokens + newTokens</code>是否溢出，<code>presaleSoldTokens &lt;= PRESALE_TOKEN_SUPPLY_LIMIT</code>恒成立，因为有着断言代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">assert(PRESALE_TOKEN_SUPPLY_LIMIT==60000000 * (1 ether / 1 wei));</div></pre></td></tr></table></figure>
<p>所以，<code>presaleSoldTokens &lt;= 60000000 * (1 ether / 1 wei)</code>，其中<code>1 ether / 1 wei = 1000000000000000000</code>，所以<code>max(presaleSoldTokens) == 6*(10^25)</code></p>
<p>再来看看变量<code>newTokens</code>，该变量的值取决于用户输出，是用户可控变量，相关代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">uint newTokens = msg.value * PRESALE_PRICE;</div><div class="line">uint public constant PRESALE_PRICE = 30000;</div></pre></td></tr></table></figure>
<p>如果我们向<code>buyTokensPresale</code>函数转账1 ether, <code>newTokens</code>的值为<code>1000000000000000000*30000=3*(10^22)</code></p>
<p>下面来计算一下，需要向该函数转账多少以太币，才能造成溢出</p>
<p>在以太坊智能合约中，<code>uint</code>默认代表的是<code>uint256</code>，取值范围是<code>0~2^256-1</code>，所以，需要<code>newTokens</code>的值大于<code>(2^256-1)-presaleSoldTokens</code>。</p>
<p>最后计算出，我们需要向<code>buyTokensPresale</code>函数转账:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; (2**256-1)-(6*(10**25))/(3*(10**22))</div><div class="line">115792089237316195423570985008687907853269984665640564039457584007913129637935L</div></pre></td></tr></table></figure>
<p>才可以造成整型上溢出，超额购币，整个以太坊公链，发展至今，以太币总余额有达到这个数吗？</p>
<p>虽然理论上该合约的确存在漏洞，但是实际却无法利用该漏洞</p>
<h2 id="2-CVE-2018-11810"><a href="#2-CVE-2018-11810" class="headerlink" title="2. CVE-2018-11810"></a>2. CVE-2018-11810</h2><p>该类漏洞被称为：“超额定向分配”</p>
<p>相关事例（ LGO ）源码：<a href="https://etherscan.io/address/0x123ab195dd38b1b40510d467a6a359b201af056f#code" target="_blank" rel="external">https://etherscan.io/address/0x123ab195dd38b1b40510d467a6a359b201af056f#code</a></p>
<p>根据该漏洞的描述：</p>
<blockquote>
<p>管理员绕过合约中规定的单地址发币上限，给指定地址分配超额的token</p>
</blockquote>
<p>跟上一个漏洞相比，因为该漏洞存在于<code>onlyOwner</code>的函数中，只能Owner(管理员)才能调用该漏洞，所以我认为该类漏洞可以算做是“后门“类漏洞。</p>
<p>所以该类漏洞的利用有两个思路：</p>
<ol>
<li>Owner留下来的“后门”，供自己使用，专门用来坑合约的其他使用者(所谓的”蜜罐合约“，就是这种情况)</li>
<li>该合约有其他漏洞，能让自己成为Owener，或者可以说，结合提权漏洞进行利用</li>
</ol>
<p>首先，我们先假设自己就是Owner，来研究该漏洞的利用流程，以下是存在漏洞的函数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div></pre></td><td class="code"><pre><div class="line">function allocate(address _address, uint256 _amount, uint8 _type) public onlyOwner returns (bool success) &#123;</div><div class="line">        // one allocations by address</div><div class="line">        require(allocations[_address] == 0);</div><div class="line"></div><div class="line">        if (_type == 0) &#123; // advisor</div><div class="line">            // check allocated amount</div><div class="line">            require(advisorsAllocatedAmount + _amount &lt;= ADVISORS_AMOUNT);</div><div class="line">            // increase allocated amount</div><div class="line">            advisorsAllocatedAmount += _amount;</div><div class="line">            // mark address as advisor</div><div class="line">            advisors[_address] = true;</div><div class="line">        &#125; else if (_type == 1) &#123; // founder</div><div class="line">            // check allocated amount</div><div class="line">            require(foundersAllocatedAmount + _amount &lt;= FOUNDERS_AMOUNT);</div><div class="line">            // increase allocated amount</div><div class="line">            foundersAllocatedAmount += _amount;</div><div class="line">            // mark address as founder</div><div class="line">            founders[_address] = true;</div><div class="line">        &#125; else &#123;</div><div class="line">            // check allocated amount</div><div class="line">            require(holdersAllocatedAmount + _amount &lt;= HOLDERS_AMOUNT + RESERVE_AMOUNT);</div><div class="line">            // increase allocated amount</div><div class="line">            holdersAllocatedAmount += _amount;</div><div class="line">        &#125;</div><div class="line">        // set allocation</div><div class="line">        allocations[_address] = _amount;</div><div class="line">        initialAllocations[_address] = _amount;</div><div class="line"></div><div class="line">        // increase balance</div><div class="line">        balances[_address] += _amount;</div><div class="line"></div><div class="line">        // update variables for bonus distribution</div><div class="line">        for (uint8 i = 0; i &lt; 4; i++) &#123;</div><div class="line">            // increase unspent amount</div><div class="line">            unspentAmounts[BONUS_DATES[i]] += _amount;</div><div class="line">            // initialize bonus eligibility</div><div class="line">            eligibleForBonus[BONUS_DATES[i]][_address] = true;</div><div class="line">            bonusNotDistributed[BONUS_DATES[i]][_address] = true;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        // add to initial holders list</div><div class="line">        initialHolders.push(_address);</div><div class="line"></div><div class="line">        Allocate(_address, _amount);</div><div class="line"></div><div class="line">        return true;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>该合约相当于一个代币分配的协议，Owner可以随意给人分配代币，但是不能超过如下的限制：</p>
<p>代币的总额: <code>uint256 constant INITIAL_AMOUNT  = 100 * onePercent;</code><br>给顾问5%: <code>uint256 constant ADVISORS_AMOUNT =   5 * onePercent;</code><br>创始人要15%: <code>uint256 constant FOUNDERS_AMOUNT =  15 * onePercent;</code><br>销售出了60%: <code>uint256 constant HOLDERS_AMOUNT  =  60 * onePercent;</code><br>保留了20%: <code>uint256 constant RESERVE_AMOUNT  =  20 * onePercent;</code></p>
<p>对应到下面三个判断：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">require(advisorsAllocatedAmount + _amount &lt;= ADVISORS_AMOUNT);</div><div class="line">require(foundersAllocatedAmount + _amount &lt;= FOUNDERS_AMOUNT);</div><div class="line">require(holdersAllocatedAmount + _amount &lt;= HOLDERS_AMOUNT + RESERVE_AMOUNT);</div></pre></td></tr></table></figure>
<p>跟上一个CVE一样，该漏洞本质上也是整型上溢出，但是上一个漏洞，用户可控的变量来至于向合约转账的以太币的数值，所以在实际情况中，基本不可能利用。但是在该漏洞中，用户可控的变量<code>_amount</code>，是由用户任意输入，使得该漏洞得以实现</p>
<p>下面，利用漏洞给顾问分配超过5%的代币：</p>
<ol>
<li>给顾问A分配<code>2*onePercent</code>数量的代币：<code>allocte(&quot;0xbd08e0cddec097db7901ea819a3d1fd9de8951a2&quot;, 362830104000000, 0)</code></li>
</ol>
<p><img src="//hcamael.oss-cn-beijing.aliyuncs.com/img/blockchain1.png?x-oss-process=style/blog_sy" alt="blockchain1"></p>
<ol>
<li><p>给顾问B分配一个巨大数量的代币，导致溢出：<code>allocte(&quot;0x63ac545c991243fa18aec41d4f6f598e555015dc&quot;, 115792089237316195423570985008687907853269984665640564039457583645083025639937, 0)</code></p>
</li>
<li><p>查看顾问B的代币数：<code>balanceOf(&quot;0x63ac545c991243fa18aec41d4f6f598e555015dc&quot;) =&gt; 115792089237316195423570985008687907853269984665640564039457583645083025639937</code></p>
</li>
</ol>
<p><img src="//hcamael.oss-cn-beijing.aliyuncs.com/img/blockchian2.png?x-oss-process=style/blog_sy" alt="blockchian2"></p>
<p>经过后续的审计，发现该合约代码中的<code>own</code>变量只能由Owner修改，所以该漏洞只能被Owner利用</p>
<h2 id="3-CVE-2018-11809"><a href="#3-CVE-2018-11809" class="headerlink" title="3. CVE-2018-11809"></a>3. CVE-2018-11809</h2><p>该漏洞被称为：”超额铸币“，但实际和之前的漏洞没啥区别</p>
<p>含有该漏洞的合约Playkey (PKT）源码：<a href="https://etherscan.io/address/0x2604fa406be957e542beb89e6754fcde6815e83f#code" target="_blank" rel="external">https://etherscan.io/address/0x2604fa406be957e542beb89e6754fcde6815e83f#code</a></p>
<p>存在漏洞的函数:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">function mint(address _holder, uint256 _value) external icoOnly &#123;</div><div class="line">  require(_holder != address(0));</div><div class="line">  require(_value != 0);</div><div class="line">  require(totalSupply + _value &lt;= tokenLimit);</div><div class="line"></div><div class="line">  balances[_holder] += _value;</div><div class="line">  totalSupply += _value;</div><div class="line">  Transfer(0x0, _holder, _value);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>比上一个漏洞的代码还更简单，只有ico(相当于之前的owner)能执行该函数，阅读全篇代码，ico是在合约部署的时候由创建人设置的，后续无法更改，所以该漏洞只能被ico(owner)利用</p>
<p>该合约本身的意图是，ico能随意给人分配代币，但是发行代币的总额度不能超过<code>tokenLimit</code>，但是通过整型上溢出漏洞，能让ico发行无限个代币，利用流程如下：</p>
<ol>
<li>部署合约，设置ico为自己账户地址，设置发行代币的上限为100000: <code>PTK(&quot;0x8a0b358029b81a52487acfc776fecca3ce2fbf4b&quot;, 100000)</code></li>
</ol>
<p><img src="//hcamael.oss-cn-beijing.aliyuncs.com/img/blockchain3.png?x-oss-process=style/blog_sy" alt="blockchain3"></p>
<ol>
<li>给账户A分配一定额度的代币: <code>mint(&quot;0xbd08e0cddec097db7901ea819a3d1fd9de8951a2&quot;, 50000)</code></li>
</ol>
<p><img src="//hcamael.oss-cn-beijing.aliyuncs.com/img/blockchain4.png?x-oss-process=style/blog_sy" alt="blockchain4"></p>
<ol>
<li>利用整型上溢出给账户B分配大量的代币: <code>mint(&quot;0x63ac545c991243fa18aec41d4f6f598e555015dc&quot;, 115792089237316195423570985008687907853269984665640564039457584007913129589938)</code></li>
<li>查看账户B的余额: <code>balanceOf(&quot;0x63ac545c991243fa18aec41d4f6f598e555015dc&quot;) =&gt; 115792089237316195423570985008687907853269984665640564039457584007913129589938</code></li>
</ol>
<p><img src="//hcamael.oss-cn-beijing.aliyuncs.com/img/blockchain5.png?x-oss-process=style/blog_sy" alt="blockchain5"></p>
<h2 id="4-CVE-2018-11812"><a href="#4-CVE-2018-11812" class="headerlink" title="4. CVE-2018-11812"></a>4. CVE-2018-11812</h2><p>该漏洞被称为：“随意铸币”</p>
<p>相关漏洞合约 Polymath (POLY)源码：<a href="https://etherscan.io/address/0x9992ec3cf6a55b00978cddf2b27bc6882d88d1ec#code" target="_blank" rel="external">https://etherscan.io/address/0x9992ec3cf6a55b00978cddf2b27bc6882d88d1ec#code</a></p>
<p>具有漏洞的函数:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">function mintToken(address target, uint256 mintedAmount) onlyOwner &#123;</div><div class="line">    balanceOf[target] += mintedAmount;</div><div class="line">    Transfer(0, owner, mintedAmount);</div><div class="line">    Transfer(owner, target, mintedAmount);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个漏洞很简单，也很好理解，Owner可以随意增加任意账户的代币余额，可以想象成，银行不仅能随心所欲的印钞票，还能随心所以的扣你的钱</p>
<p>因为Owner是在合约部署的时候被设置成合约部署者的账户地址，之后也只有Owner能修改Own账户地址，所以该漏洞只能被Owner利用</p>
<p>这个我觉得与其说是漏洞，不如说是Owner留下的“后门”</p>
<h2 id="5-CVE-2018-11687"><a href="#5-CVE-2018-11687" class="headerlink" title="5. CVE-2018-11687"></a>5. CVE-2018-11687</h2><p>该漏洞被称为：“下溢增持”</p>
<p>相关漏洞合约Bitcoin Red (BTCR)源码：<a href="https://etherscan.io/address/0x6aac8cb9861e42bf8259f5abdc6ae3ae89909e11#code" target="_blank" rel="external">https://etherscan.io/address/0x6aac8cb9861e42bf8259f5abdc6ae3ae89909e11#code</a></p>
<p>相关的漏洞函数:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">function distributeBTR(address[] addresses) onlyOwner &#123;</div><div class="line">    for (uint i = 0; i &lt; addresses.length; i++) &#123;</div><div class="line">        balances[owner] -= 2000 * 10**8;</div><div class="line">        balances[addresses[i]] += 2000 * 10**8;</div><div class="line">        Transfer(owner, addresses[i], 2000 * 10**8);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>该合约限制了发行代币的上限: <code>uint256 _totalSupply = 21000000 * 10**8;</code></p>
<p>并且在合约部署的时候把能发行的合约都分配给了Owner: <code>balances[owner] = 21000000 * 10**8;</code></p>
<p>然后Owner可以把自己账户的代币，任意分配给其他账户，分配的代码就是上面的函数，给别人分配一定额度的代币时，自己减去相应额度的代币，保证该合约总代币数不变</p>
<p>但是因为没有判断Owner的账户是否有足够的余额，所以导致了减法的整型下溢出，同样也存在整型上溢出，但是因为uint256的上限是<code>2^256-1</code>，但是利用过于繁琐，需要运行非常多次的<code>balances[addresses[i]] += 2000 * 10**8;</code></p>
<p>而减法的利用就很简单了，或者我们可以根本不考虑这个减法，Owner可以给任意账户分配<code>2000 * 10**8</code>倍数的代币，该漏洞的功能和上一个漏洞的基本一致，可以任意发行代币或者减少其他账户的代币数</p>
<p>因为Owner是在合约部署的时候被设置为部署合约人的账户地址，后续没有修改own的功能，所以该漏洞也只有Owner可以利用</p>
<h2 id="6-CVE-2018-11811"><a href="#6-CVE-2018-11811" class="headerlink" title="6. CVE-2018-11811"></a>6. CVE-2018-11811</h2><p>该漏洞被称为：“高卖低收”</p>
<p>相关漏洞合约 Internet Node Token (INT)源码：<a href="https://etherscan.io/address/0x0b76544f6c413a555f309bf76260d1e02377c02a" target="_blank" rel="external">https://etherscan.io/address/0x0b76544f6c413a555f309bf76260d1e02377c02a</a></p>
<p>在该CVE的描述中，存在漏洞的函数是:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">function sell(uint256 amount) &#123;</div><div class="line">  require(this.balance &gt;= amount * sellPrice);      // checks if the contract has enough ether to buy</div><div class="line">  _transfer(msg.sender, this, amount);              // makes the transfers</div><div class="line">  msg.sender.transfer(amount * sellPrice);          // sends ether to the seller. It&apos;s important to do this last to avoid recursion attacks</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>并且描述的漏洞原理是: </p>
<blockquote>
<p>sellPrice被修改为精心构造的大数后，可导致amount * sellPrice的结果大于整数变量(uint256)最大值，发生整数溢出，从而变为一个极小值甚至归零`</p>
</blockquote>
<p>相关函数如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">function buy() payable &#123;</div><div class="line">  uint amount = msg.value / buyPrice;               // calculates the amount</div><div class="line">  _transfer(this, msg.sender, amount);              // makes the transfers</div><div class="line">&#125;</div><div class="line">  </div><div class="line">function setPrices(uint256 newSellPrice, uint256 newBuyPrice) onlyOwner &#123;</div><div class="line">  sellPrice = newSellPrice;</div><div class="line">  buyPrice = newBuyPrice;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>该漏洞的利用流程如下：</p>
<ol>
<li>管理员设置<code>buyPrice = 1 ether</code>, <code>sellPrice = 2^255</code></li>
<li>用户A买了两个以太币价格的代币: buy({value:toWei(2)})</li>
<li>用户A卖掉两个代币: send(2)</li>
<li>用户A将会收到<code>2*sellPrice = 2^256</code>价格的Wei</li>
<li>但是因为<code>transfer</code>的参数是uint256, 所以发生了溢出，用户A实际得到0Wei</li>
</ol>
<p>表面上看这个漏洞还是有危害的，但是我们仔细想想，这个漏洞其实是比较多余的，我们可以使用更简单的步骤达到相同的目的:</p>
<ol>
<li>管理员设置<code>buyPrice = 1 ether</code>, <code>sellPrice = 0</code></li>
<li>用户A买了两个以太币价格的代币: buy({value:toWei(2)})</li>
<li>用户A卖掉两个代币: send(2)</li>
<li>用户A将会收到<code>2*sellPrice = 0</code>价格的Wei</li>
</ol>
<p>我认为该合约最大的问题在于Owner可以随意设置代币的买入和卖出价格。</p>
<p>顺带提一下这个问题也是前面peckshield公布的“tradeTrap”漏洞(<a href="https://peckshield.com/2018/06/11/tradeTrap/" target="_blank" rel="external">https://peckshield.com/2018/06/11/tradeTrap/</a>)提到的“Security Issue 2: Manipulatable Prices and Unfair Arbitrage” 是同一个问题。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>经过上面的分析，在这6个CVE中，虽然都是整型溢出，但第一个CVE属于理论存在，但实际不可实现的整型上溢出漏洞，剩下5个CVE都属于对管理者有利，会损害用户利用的漏洞，或者可以称为“后门”，也正是这个原因也导致了一些关于需要Owner触发漏洞意义讨论<a href="#jump2">[2]</a> </p>
<p>如果我们把智能合约类比为传统合同，智能合约代码就是传统合同的内容，但是和传统的合同相比，智能合约拥有三个利益团体，一个是编写合约代码的人(智能合约中的Owner，或者我们可以称为甲方)，使用该合约的其他人(我们可以称为乙方)，跟该智能合约无关的其他人(比如利用合约漏洞获利的黑客)。从这个角度来看Owner条件下触发的漏洞在理论上是可以损害到乙方的利益，如对于存在“恶意”的owner或者黑客配合其他漏洞获取到owner权限的场景上来说，还是有一定意义的。</p>
<p>另外从整个上市交易流程来看，我们还需要关注到“交易所”这个环节，交易所的风控体系在某种程度上可以限制这种“恶意”的owner或黑客利用。</p>
<p>由此可见合约审计对于“甲方”、“乙方”、交易所都有重要的意义。</p>
<h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><ol>
<li><span id="jump1"><a href="https://www.anquanke.com/post/id/147913" target="_blank" rel="external">https://www.anquanke.com/post/id/147913</a></span></li>
<li><span id="jump2"><a href="https://mp.weixin.qq.com/s/6PKWXJXAKVCu5bJYlKy2Aw" target="_blank" rel="external">https://mp.weixin.qq.com/s/6PKWXJXAKVCu5bJYlKy2Aw</a></span></li>
</ol>
]]></content:encoded>
      
      <comments>//0x48.pw/2018/06/19/0x43/#disqus_thread</comments>
    </item>
    
  </channel>
</rss>
