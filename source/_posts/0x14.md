title: 0CTF RSA?总结 || RSA学习笔记
date: 2016-03-17 09:18:02
tags: Crypto
categories: H-blog
---
![]()
<!--more-->
*果然不是信息安全专业的，只是自学会有很多技能点的缺失。*
该题用的是中国剩余定理，顺便学了一遍RSA，发现了数学技能点的缺失

(PS: ^表示为次方，xor才是异或，％和mod为求余，/表示为整除)

# RSA学习笔记

先来学学前置技能
## 前置技能
### 学前符号助记

$ x = y\ (mod\ n) $         可以看成是        $ x \% n = y$
$ x \equiv y\ (mod\ n)$      可以看成是        $ x \% n = y \% n$

### 欧拉函数

$$\phi(q) = \prod_{k=1}^∞ (1 - q^k)$$

然后在RSA中用到的性质： 
> m是素数时，有 $\phi(m) = m - 1$

> 当m, n互质时，有 $\phi(m\*n) = \phi(m) \* \phi(n)$

### 欧拉定理
> 设p和q互质，则 $q^{p-1} \equiv 1\ (mod\ p)$

根据前面这说的该公式的意义为： $q^{p-1} \% p = 1 \% p$
所以最后可以得出：$q^{p-1} \% p = 1$

### 模反元素

设x为q的模反元素，则x必须满足：
> $q \* x \equiv 1\ (mod\ p) \Longrightarrow (q\*x) \% p = 1$

性质：
> x为q的模反元素，则$x + kp$ 都是q的模反元素(k为整数)

### 模逆元
也就是上面说的模反元素的公式：$q \* x \equiv 1\ (mod\ p)$等同于$x^{-1} \equiv q\ (mod\ p)$

### 中国剩余定理之Gauss's algorithm
对于$e = 3$然后存在三个$n => n_1, n_2, n_3$
> $N = n_1 \* n_2 \* n_3$
> $N_1 = N / n_1 = n_2 \* n_3$
> $N_2 = N / n_2 = n_1 \* n_3$
> $N_3 = N / n_3 = n_2 \* n_1$
> $d_1 = N^{-1}_1 (mod\ n_1)$
> $d_2 = N^{-1}_2 (mod\ n_2)$
> $d_3 = N^{-1}_3 (mod\ n_3)$

有明文m，可得
> $c_1 = m \% n_1$
> $c_2 = m \% n_2$
> $c_3 = m \% n_3$
> $x = m^3$

然后：
$$x \equiv (c_1N_1d_1 + c_2N_2d_2 + c_3N_3d_3) (mod\ N)$$

### Other
经常看到的两个定义：
> $lcm(x, y)$     x和y的最小公倍数
> $gcd(e, l)$      e和l的最大公约数

## RSA密钥生成
前置技能学完了，开始研究RSA了
在密钥中包含了两个数据：
公钥：(N, e)
私钥：(N, d)
下面来看看怎么求N, e, d这三个数

* 搞出两个超大的互质数设为p和q
> p和q互质
* p和q相乘得出密钥长度N
> $N = p \* q$
* 计算N的欧拉函数
> $\phi(N) = \phi(p\*q) = \phi(p) \* \phi(q) = (p - 1) \* (q - 1)$
* 然后通过随机数生成方法随机出一个e，必须满足两个条件
> $1 < e < \phi(N)$ 还有 e和$\phi(n)$为互质数
* 再随机出一个d, 为e的模反元素
> $e \* d \% \phi(N) = 1$

好了，三个值求出来了，现在来看看加解密
加解密都是对字符的二进制进行计算
假设明文是字符串`mingwen`则被加密的
$m = 0b01101101011010010110111001100111011101110110010101101110 = 30796695364658542$ 
### 加密
加密公式：密文$c = m^e \% N$
### 解密
解密公式：明文$m = c^d \% N$

### openssl简单用法小记
再来用openssl来生成个公钥私钥对
#### 先生成私钥
```
$ openssl genrsa -out private.pem 1024
Generating RSA private key, 1024 bit long modulus
.......++++++
........++++++
e is 65537 (0x10001)
```

这里的e就是上面计算中的e，1024为上面计算中N的bits长度
```
$ cat private.pem 
-----BEGIN RSA PRIVATE KEY-----
xxxxxxxxxxxxxxxxxxxxxxxxxxx
-----END RSA PRIVATE KEY-----
```

这就是私钥
#### 再生成公钥
```
$ openssl rsa -in private.pem -pubout -out public.pem
writing RSA key
$ cat public.pem 
-----BEGIN PUBLIC KEY-----
xxxxxxxxxxxxxxxxxxxxxxxxx
-----END PUBLIC KEY-----
```

#### 查看密钥信息
查看公钥信息
```
$ openssl rsa -in public.pem -pubin -text
Public-Key: (1024 bit)
Modulus:
    xxxxxxxxxxxxx
Exponent: 65537 (0x10001)
writing RSA key
-----BEGIN PUBLIC KEY-----
xxxxxxxxxxxx
-----END PUBLIC KEY-----
```

Modulus就是上面计算过程中的N，e为0x10001
查看私钥信息
```
$ openssl rsa -in private.pem -text
Private-Key: (1024 bit)
modulus:
    xxxxxxxxxxx
publicExponent: 65537 (0x10001)
privateExponent:
    xxxxxxxxxxx
prime1:
    xxxxxxxxxxxxxx
prime2:
    xxxxxxxxxxxx
exponent1:
    xxxxxxxxxxxx
exponent2:
    xxxxxxxxxxx
coefficient:
    xxxxxxxxxx
writing RSA key
-----BEGIN RSA PRIVATE KEY-----
xxxxxxxxxxxx
-----END RSA PRIVATE KEY-----
```

私钥藏了所有的信息啊。。所以说如果私钥泄露了。。就GG了。。
$modulus = N$
$publicExponent = e$
$privateExponent = d$
$prime1 = p$
$prime2 = q$
$exponent1 = d \% (p-1)$
$exponent2 = d \% (q-1)$
$coefficient = q^{-1} \% p$

# RSA?
然后来扯0CTF的RSA?这题，首先查看公钥的信息：
```
$ openssl rsa -in public.pem -pubin -text
Public-Key: (314 bit)
Modulus:
    02:ca:a9:c0:9d:c1:06:1e:50:7e:5b:7f:39:dd:e3:
    45:5f:cf:e1:27:a2:c6:9b:62:1c:83:fd:9d:3d:3e:
    aa:3a:ac:42:14:7c:d7:18:8c:53
Exponent: 3 (0x3)
writing RSA key
-----BEGIN PUBLIC KEY-----
MEEwDQYJKoZIhvcNAQEBBQADMAAwLQIoAsqpwJ3BBh5Qflt/Od3jRV/P4Seixpti
HIP9nT0+qjqsQhR81xiMUwIBAw==
-----END PUBLIC KEY-----
```

从这里可以得到
$N = 0x2CAA9C09DC1061E507E5B7F39DDE3455FCFE127A2C69B621C83FD9D3D3EAA3AAC42147CD7188C53$
$e = 3$

然后wp中用一个叫YAFU的软件因式分解出了三个值
$p = 26440615366395242196516853423447$
$q = 27038194053540661979045656526063$
$r = 32581479300404876772405716877547$

接下来：
$\phi(p\*q\*r) = \phi(N) = \phi(q) \* \phi(p) \* \phi(r) = (p-1) \* (q-1) \* (r-1)$
$\phi(N) = 2329271097867038040364127327000042742184870900536 0280557445800298810723014218767619832560713992$

但是这时候出问题了，上面说了e和$\phi(N)$ 要互质数，但是 $\phi(N) \% e = 0$
所以这时候就要用到中国剩余定理了，参考文档<http://www.di-mgt.com.au/crt.html#gaussalg>, 原谅我数学不行，只能把结论拿来用了。。

在本题中，$e = 3$，N分解出了$p, q, r$分别对应$n_1, n_2, n_3$
然后$d_i$使用扩展欧几里德可以算出

### 欧几里德算法
已知a, b 求 $ax + by = gcd(a, b) = d$中的x, y
公式：
$$gcd(a,b) = gcd(b, a\ mod\ b)$$
Python实现该算法：
```
def gcd(a, b):
    while b:
        a, b = b, a % b
    return a

def gcd(a, b):
    if b == 0:
        return a
    else:
        return gcd(b, a%b)
```
扩展算法：







```
def extended_gcd(aa, bb):
    lastremainder, remainder = abs(aa), abs(bb)
    x, lastx, y, lasty = 0, 1, 1, 0
    while remainder:
        lastremainder, (quotient, remainder) = remainder, divmod(lastremainder, remainder)
        x, lastx = lastx - quotient * x, x
        y, lasty = lasty - quotient * y, y
    return lastremainder, lastx * (-1 if aa < 0 else 1), lasty * (-1 if bb < 0 else 1）
```

